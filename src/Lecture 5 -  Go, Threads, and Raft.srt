1
00:00:00,520 --> 00:00:02,509
hey the TAS are going to be giving a

2
00:00:02,710 --> 00:00:06,019
lecture on concurrency and go basically

3
00:00:06,219 --> 00:00:07,660
this lecture is going to be full of

4
00:00:07,860 --> 00:00:10,310
design patterns and practical tips to

5
00:00:10,509 --> 00:00:13,429
help you with the labs we're going to be

6
00:00:13,628 --> 00:00:15,290
covering briefly the code memory model

7
00:00:15,490 --> 00:00:16,970
the reading which we went over and then

8
00:00:17,170 --> 00:00:18,620
spend most of the lecture talking about

9
00:00:18,820 --> 00:00:20,000
concurrency primitives and go

10
00:00:20,199 --> 00:00:22,460
concurrency patterns and go how you do

11
00:00:22,660 --> 00:00:23,990
things that you will need to do in the

12
00:00:24,190 --> 00:00:26,030
labs and then finally we'll talk through

13
00:00:26,230 --> 00:00:27,769
some debugging tips and techniques and

14
00:00:27,969 --> 00:00:29,210
show you some interesting tools that you

15
00:00:29,410 --> 00:00:30,800
might want to use when debugging the

16
00:00:31,000 --> 00:00:34,369
labs so very briefly on the go memory

17
00:00:34,570 --> 00:00:36,439
model on the reading so why did we

18
00:00:36,640 --> 00:00:38,628
assign this reading well the goal was to

19
00:00:38,829 --> 00:00:40,669
give you some concrete examples of

20
00:00:40,869 --> 00:00:42,948
correct ways to write threaded code and

21
00:00:43,149 --> 00:00:45,140
go so the document like in the second

22
00:00:45,340 --> 00:00:46,159
half of the document has some examples

23
00:00:46,359 --> 00:00:48,259
of crack code and an incorrect code and

24
00:00:48,460 --> 00:00:50,929
how it can go wrong so one thing you

25
00:00:51,130 --> 00:00:52,608
might have noticed in the document is

26
00:00:52,808 --> 00:00:54,589
early on it says if you need to read and

27
00:00:54,789 --> 00:00:56,089
understand this you're being too clever

28
00:00:56,289 --> 00:00:58,390
and we think that that's good advice so

29
00:00:58,590 --> 00:01:01,219
focus on how to write correct code don't

30
00:01:01,420 --> 00:01:03,108
focus way too much on the happens before

31
00:01:03,308 --> 00:01:04,759
relation and being able to reason about

32
00:01:04,959 --> 00:01:06,618
exactly why incorrect code is incorrect

33
00:01:06,819 --> 00:01:08,118
like we don't really care we just want

34
00:01:08,319 --> 00:01:09,168
to be able to write correct code and

35
00:01:09,368 --> 00:01:10,238
call it a day

36
00:01:10,438 --> 00:01:13,759
one question that came up in the lecture

37
00:01:13,959 --> 00:01:16,338
questions was like talking about

38
00:01:16,539 --> 00:01:18,259
goroutines in relation to performance

39
00:01:18,459 --> 00:01:20,599
and so we just wanted to say that

40
00:01:20,799 --> 00:01:22,278
goroutines and like in general

41
00:01:22,478 --> 00:01:24,709
concurrency can be used for a couple

42
00:01:24,909 --> 00:01:26,599
different reasons and the reason we use

43
00:01:26,799 --> 00:01:28,789
concurrency in the labs is not

44
00:01:28,989 --> 00:01:30,709
necessarily for performance like we're

45
00:01:30,909 --> 00:01:33,109
not going for parallelism using multiple

46
00:01:33,310 --> 00:01:34,640
cores on a single machine in order to be

47
00:01:34,840 --> 00:01:36,109
able to do more work on the CPU

48
00:01:36,310 --> 00:01:37,908
concurrency gets us something else

49
00:01:38,108 --> 00:01:40,219
besides performance through parallelism

50
00:01:40,420 --> 00:01:42,438
it can get us better expert Civet ii

51
00:01:42,638 --> 00:01:43,698
like we want to write down some ideas

52
00:01:43,899 --> 00:01:46,218
and it happens to be that writing down

53
00:01:46,418 --> 00:01:48,468
code that uses threads is a clean way of

54
00:01:48,668 --> 00:01:51,198
expressing those ideas and so the

55
00:01:51,399 --> 00:01:52,759
takeaway from that is when you use

56
00:01:52,959 --> 00:01:55,728
threads in lab 2 and Beyond don't try to

57
00:01:55,929 --> 00:01:57,140
do fancy things you might do if you're

58
00:01:57,340 --> 00:01:58,968
going for performance especially CPU

59
00:01:59,168 --> 00:02:00,618
performance like we don't care to do

60
00:02:00,819 --> 00:02:02,238
things like using fine-grained locking

61
00:02:02,438 --> 00:02:05,899
or other techniques use basically write

62
00:02:06,099 --> 00:02:08,149
code that's easy to reason about use big

63
00:02:08,348 --> 00:02:10,160
locks to protect large critical sections

64
00:02:10,360 --> 00:02:12,140
and just like don't worry about

65
00:02:12,340 --> 00:02:13,700
performance in the sense of CPU

66
00:02:13,900 --> 00:02:16,409
performance

67
00:02:16,539 --> 00:02:18,599
so with that that's all we're going to

68
00:02:18,799 --> 00:02:20,160
say about the memory model and spend

69
00:02:20,360 --> 00:02:21,830
most of this lecture just talking about

70
00:02:22,030 --> 00:02:25,380
go code and go concurrency patterns and

71
00:02:25,580 --> 00:02:27,060
as we go through these examples feel

72
00:02:27,259 --> 00:02:28,439
free to ask any questions about what's

73
00:02:28,639 --> 00:02:29,610
on the screen or anything else you might

74
00:02:29,810 --> 00:02:32,550
think about so I'm going to start off

75
00:02:32,750 --> 00:02:34,770
talking about concurrency primitives and

76
00:02:34,969 --> 00:02:37,679
go so the first thing is closures this

77
00:02:37,878 --> 00:02:38,610
is something that will almost certainly

78
00:02:38,810 --> 00:02:41,670
be helpful in the labs and this is

79
00:02:41,870 --> 00:02:44,160
related to go routines so here's this

80
00:02:44,360 --> 00:02:46,230
example program on the screen and what

81
00:02:46,430 --> 00:02:48,270
it does is the main function declares a

82
00:02:48,469 --> 00:02:50,039
bunch of variables and then spawns this

83
00:02:50,239 --> 00:02:51,360
go routine in here with this go

84
00:02:51,560 --> 00:02:53,189
statement and we noticed that the score

85
00:02:53,389 --> 00:02:55,110
routine is not taking it as an argument

86
00:02:55,310 --> 00:02:57,450
a function call to some function defined

87
00:02:57,650 --> 00:02:58,980
elsewhere but this anonymous function

88
00:02:59,180 --> 00:03:01,200
just defined in line here so this is a

89
00:03:01,400 --> 00:03:02,580
handy pattern this is something called a

90
00:03:02,780 --> 00:03:04,560
closure and one neat thing about this is

91
00:03:04,759 --> 00:03:06,629
that this function that's defined here

92
00:03:06,829 --> 00:03:08,280
can refer to variables from the

93
00:03:08,479 --> 00:03:10,409
enclosing scope so for example this

94
00:03:10,609 --> 00:03:12,509
function can mutate this variable a

95
00:03:12,709 --> 00:03:15,450
that's defined up here or refer to this

96
00:03:15,650 --> 00:03:19,349
weight group that's defined up here so

97
00:03:19,549 --> 00:03:23,280
if we go run this example it does what

98
00:03:23,479 --> 00:03:23,939
you think it does

99
00:03:24,139 --> 00:03:27,780
the weight group dot done here let's the

100
00:03:27,979 --> 00:03:29,219
main thread continue past this point it

101
00:03:29,419 --> 00:03:30,480
prints out this variable which has been

102
00:03:30,680 --> 00:03:32,129
mutated by this concurrently running

103
00:03:32,329 --> 00:03:34,200
thread that finished before this weight

104
00:03:34,400 --> 00:03:38,490
happened so this is a useful pattern to

105
00:03:38,689 --> 00:03:41,550
be able to use one like the reason we're

106
00:03:41,750 --> 00:03:46,349
pointing this out is because you might

107
00:03:46,549 --> 00:03:47,520
have code that looks like this in your

108
00:03:47,719 --> 00:03:49,890
labs very similar to the previous

109
00:03:50,090 --> 00:03:51,990
example except this is code that is

110
00:03:52,189 --> 00:03:53,430
spawning a bunch of threads in a loop

111
00:03:53,629 --> 00:03:55,770
this is useful for example when you want

112
00:03:55,969 --> 00:03:58,080
to send our pcs in parallel right so

113
00:03:58,280 --> 00:04:00,719
like in lab two if you have a candidate

114
00:04:00,919 --> 00:04:02,340
asking for votes you want to ask for

115
00:04:02,539 --> 00:04:04,050
votes from all the followers in parallel

116
00:04:04,250 --> 00:04:05,969
not one after the other because the RPC

117
00:04:06,169 --> 00:04:07,259
is a blocking operation that might take

118
00:04:07,459 --> 00:04:09,270
some time or similarly the leader might

119
00:04:09,469 --> 00:04:10,710
want to send append entries to all the

120
00:04:10,909 --> 00:04:12,270
followers you want to do it in parallel

121
00:04:12,469 --> 00:04:14,340
not in series and so threads are a clean

122
00:04:14,539 --> 00:04:16,860
way to express this idea and so you

123
00:04:17,060 --> 00:04:18,240
might have code that looks kind of like

124
00:04:18,439 --> 00:04:20,430
this at a high level in a for loop you

125
00:04:20,629 --> 00:04:23,550
spawn a bunch of go routines one thing

126
00:04:23,750 --> 00:04:24,660
to be careful about here this is

127
00:04:24,860 --> 00:04:25,889
something that was talked about in a

128
00:04:26,089 --> 00:04:27,259
previous lecture

129
00:04:27,459 --> 00:04:30,860
is identifier capture and goroutines and

130
00:04:31,060 --> 00:04:33,050
mutation of that identifier in the outer

131
00:04:33,250 --> 00:04:34,879
scope so we see here that we have this

132
00:04:35,079 --> 00:04:36,800
eye that's being mutated by this for

133
00:04:37,000 --> 00:04:38,809
loop and then we want to use that value

134
00:04:39,009 --> 00:04:41,240
inside the square root een and the way

135
00:04:41,439 --> 00:04:42,410
we do that like the correct way of

136
00:04:42,610 --> 00:04:44,540
writing this code is to pass this value

137
00:04:44,740 --> 00:04:46,520
I as an argument to this function and

138
00:04:46,720 --> 00:04:49,100
this function or you can rename it to X

139
00:04:49,300 --> 00:04:50,749
inside here and then use the value

140
00:04:50,949 --> 00:04:53,020
inside and so if we run this program

141
00:04:53,220 --> 00:04:55,430
so here I've kind of stubbed out to send

142
00:04:55,629 --> 00:04:56,838
our PC thing was actually just prints

143
00:04:57,038 --> 00:04:59,480
out the index this I might be like the

144
00:04:59,680 --> 00:05:01,249
index of the follower trying to send an

145
00:05:01,449 --> 00:05:04,249
RPC to here prints out the numbers 0

146
00:05:04,449 --> 00:05:05,930
through 4 in some order so this is what

147
00:05:06,129 --> 00:05:07,639
we want like send our PCs to all the

148
00:05:07,839 --> 00:05:09,439
followers the reason we're showing you

149
00:05:09,639 --> 00:05:11,028
this code is because there's a variation

150
00:05:11,228 --> 00:05:13,550
of this code which looks really similar

151
00:05:13,750 --> 00:05:15,170
and maybe intuitively you might think it

152
00:05:15,370 --> 00:05:16,338
does the right thing but in fact it

153
00:05:16,538 --> 00:05:18,110
doesn't so in this code the only thing

154
00:05:18,310 --> 00:05:21,319
that's changed is we've gotten rid of

155
00:05:21,519 --> 00:05:23,270
this argument here that we're explicitly

156
00:05:23,470 --> 00:05:26,240
passing and instead we're letting this I

157
00:05:26,439 --> 00:05:29,088
refer to the eye from the outer scope so

158
00:05:29,288 --> 00:05:30,050
you might think that when you run this

159
00:05:30,250 --> 00:05:33,379
it does the same thing but in fact in

160
00:05:33,579 --> 00:05:35,649
this particular run it printed 4 5 5 5 5

161
00:05:35,848 --> 00:05:39,379
so this would do the wrong thing and the

162
00:05:39,579 --> 00:05:41,300
reason for this is that this I is being

163
00:05:41,500 --> 00:05:43,550
mutated by this outer scope and by the

164
00:05:43,750 --> 00:05:44,990
time this go routine ends up actually

165
00:05:45,189 --> 00:05:47,060
executing this line well the for loop

166
00:05:47,259 --> 00:05:49,399
has already changed the value of I so

167
00:05:49,598 --> 00:05:52,249
this doesn't do the right thing so at a

168
00:05:52,449 --> 00:05:54,740
high level if you're spawning goroutines

169
00:05:54,939 --> 00:05:57,319
in a loop just make sure that you use

170
00:05:57,519 --> 00:06:00,259
this pattern here and everything will

171
00:06:00,459 --> 00:06:02,860
work right any questions about that

172
00:06:03,060 --> 00:06:04,879
so it's just like a small gotcha but

173
00:06:05,079 --> 00:06:05,899
we've seen this a whole bunch of times

174
00:06:06,098 --> 00:06:06,980
in office hours so I just wanted to

175
00:06:07,180 --> 00:06:10,520
point this out all right so moving on to

176
00:06:10,720 --> 00:06:13,218
other patterns that you might want to

177
00:06:13,418 --> 00:06:17,300
use in your code oftentimes you want

178
00:06:17,500 --> 00:06:19,100
code that periodically does something a

179
00:06:19,300 --> 00:06:22,189
very simple way to do that is to have a

180
00:06:22,389 --> 00:06:24,528
separate function that in an infinite

181
00:06:24,728 --> 00:06:26,749
loop does something in this case we're

182
00:06:26,949 --> 00:06:29,270
just printing out tick and then use this

183
00:06:29,470 --> 00:06:31,040
time dot sleep to wait for a certain

184
00:06:31,240 --> 00:06:34,218
amount of time so very simple pattern

185
00:06:34,418 --> 00:06:34,550
here

186
00:06:34,750 --> 00:06:35,870
you don't need anything fancier than

187
00:06:36,069 --> 00:06:39,269
this to do something periodically

188
00:06:41,399 --> 00:06:43,550
one modification of this that you might

189
00:06:43,750 --> 00:06:44,780
want is you want to do something

190
00:06:44,980 --> 00:06:47,270
periodically until something happens for

191
00:06:47,470 --> 00:06:49,069
example you might want to start up a

192
00:06:49,269 --> 00:06:51,079
raft here and then periodically send

193
00:06:51,279 --> 00:06:54,650
heartbeats but when we call dot kill on

194
00:06:54,850 --> 00:06:56,600
the raft instance you want to actually

195
00:06:56,800 --> 00:06:57,980
shut down all these goroutines so you

196
00:06:58,180 --> 00:06:59,120
don't have all these random goroutines

197
00:06:59,319 --> 00:07:01,579
still running in the background and so

198
00:07:01,779 --> 00:07:02,810
the pattern for that looks something

199
00:07:03,009 --> 00:07:08,000
like this you have a goroutine that will

200
00:07:08,199 --> 00:07:10,550
run in an infinite loop and do something

201
00:07:10,750 --> 00:07:13,040
and then wait for a little bit and then

202
00:07:13,240 --> 00:07:13,939
you can just have a shared variable

203
00:07:14,139 --> 00:07:16,370
between whatever control thread is going

204
00:07:16,569 --> 00:07:17,870
to decide whether this goroutine should

205
00:07:18,069 --> 00:07:19,970
die or not so in this example we have

206
00:07:20,170 --> 00:07:21,470
this variable done that's a global

207
00:07:21,670 --> 00:07:23,360
variable and what main does is it waits

208
00:07:23,560 --> 00:07:26,780
for awhile and sets done to true and in

209
00:07:26,980 --> 00:07:28,430
this go routine that's ticking and doing

210
00:07:28,629 --> 00:07:30,800
work periodically we're just checking

211
00:07:31,000 --> 00:07:32,449
the value of done and if done is set

212
00:07:32,649 --> 00:07:34,040
then we terminate the square-root eeen

213
00:07:34,240 --> 00:07:37,910
and here since done is a shared variable

214
00:07:38,110 --> 00:07:39,980
being mutated and read by multiple

215
00:07:40,180 --> 00:07:41,480
threads we need to make sure that we

216
00:07:41,680 --> 00:07:44,420
guard the use of this with a lock so

217
00:07:44,620 --> 00:07:45,740
that's where this mute outlaw can mute

218
00:07:45,939 --> 00:07:48,860
it unlock comes in for the purpose of

219
00:07:49,060 --> 00:07:50,000
the labs you can actually write

220
00:07:50,199 --> 00:07:51,139
something a little bit simpler than this

221
00:07:51,339 --> 00:07:55,280
so we have this method RF killed on your

222
00:07:55,480 --> 00:07:57,110
raft instance so you might have code

223
00:07:57,310 --> 00:07:58,280
that looks a little bit more like this

224
00:07:58,480 --> 00:08:01,040
so while you're wrapped instance is not

225
00:08:01,240 --> 00:08:02,480
dead you want to periodically do some

226
00:08:02,680 --> 00:08:10,360
work any questions about that so far

227
00:08:10,560 --> 00:08:13,800
yeah question

228
00:08:21,778 --> 00:08:25,158
does using the locking mechanisms for

229
00:08:25,358 --> 00:08:30,049
channels make it so that any right

230
00:08:30,249 --> 00:08:32,718
stunts any variables and those functions

231
00:08:32,918 --> 00:08:35,958
are to be observed by the fencer would

232
00:08:36,158 --> 00:08:41,218
you need to send done across the channel

233
00:08:41,759 --> 00:08:43,998
okay so let me try to simplify the

234
00:08:44,198 --> 00:08:45,469
question a bit I think the question is

235
00:08:45,669 --> 00:08:47,628
do you need to use locks here can you

236
00:08:47,828 --> 00:08:51,169
use channels instead and R and can you

237
00:08:51,370 --> 00:08:52,488
get away with not using locks and like

238
00:08:52,688 --> 00:08:53,479
what's the difference between nothing

239
00:08:53,679 --> 00:08:55,159
versus channels vs locks is that

240
00:08:55,360 --> 00:09:08,419
basically what you're asking I think the

241
00:09:08,620 --> 00:09:10,758
question is this done does it not need

242
00:09:10,958 --> 00:09:12,709
to be sent across a channel does just

243
00:09:12,909 --> 00:09:14,899
using these locks ensure that this read

244
00:09:15,100 --> 00:09:17,808
here observes the write done by a thread

245
00:09:18,009 --> 00:09:21,258
okay so the answer is yes basically at a

246
00:09:21,458 --> 00:09:23,688
high level if you want to ensure cross

247
00:09:23,889 --> 00:09:25,188
thread communication make sure you use

248
00:09:25,389 --> 00:09:27,229
go synchronization primitives whether

249
00:09:27,429 --> 00:09:29,868
it's channels or locks and condition

250
00:09:30,068 --> 00:09:33,169
variables and so here because of the use

251
00:09:33,370 --> 00:09:35,299
of locks after this thread writes done

252
00:09:35,500 --> 00:09:38,149
and does unlock the next lock that

253
00:09:38,350 --> 00:09:40,488
happens is guaranteed to observe the

254
00:09:40,688 --> 00:09:42,678
writes done before that before this

255
00:09:42,879 --> 00:09:44,358
unlock happened so you have this write

256
00:09:44,558 --> 00:09:46,159
happened and this unlock happened then

257
00:09:46,360 --> 00:09:47,928
one of these locks happens and then the

258
00:09:48,129 --> 00:09:49,578
next done will be guaranteed to observe

259
00:09:49,778 --> 00:09:55,588
that write of true question

260
00:10:02,750 --> 00:10:05,370
that's a good question in this

261
00:10:05,570 --> 00:10:07,169
particular code it doesn't matter but it

262
00:10:07,370 --> 00:10:08,759
would be cleaner to do it so the

263
00:10:08,960 --> 00:10:10,709
question is why don't we do mu dot

264
00:10:10,909 --> 00:10:13,889
unlock here before returning and the

265
00:10:14,090 --> 00:10:15,959
answer is in here there's no more like

266
00:10:16,159 --> 00:10:17,339
the program's done so it doesn't

267
00:10:17,539 --> 00:10:18,629
actually end up mattering but you're

268
00:10:18,830 --> 00:10:21,029
right that like in general we would want

269
00:10:21,230 --> 00:10:23,370
to ensure that we unlock before we

270
00:10:23,570 --> 00:10:27,580
return yeah thanks for pointing that out

271
00:10:41,528 --> 00:10:43,319
so I'm not sure entirely what the

272
00:10:43,519 --> 00:10:44,729
question is but maybe something like can

273
00:10:44,929 --> 00:10:46,559
both of these acquire the lock at the

274
00:10:46,759 --> 00:11:00,539
same time is that the question and we'll

275
00:11:00,740 --> 00:11:02,879
talk a little bit more about locks in

276
00:11:03,080 --> 00:11:04,379
just a moment but at a high level the

277
00:11:04,580 --> 00:11:07,709
semantics of a lock are the lock is

278
00:11:07,909 --> 00:11:09,389
either held by somebody or not held by

279
00:11:09,589 --> 00:11:10,919
somebody and if it's not held by

280
00:11:11,120 --> 00:11:12,659
somebody then if someone calls lock they

281
00:11:12,860 --> 00:11:14,129
have the chance to acquire the lock and

282
00:11:14,330 --> 00:11:16,799
if before they call unlock somebody else

283
00:11:17,000 --> 00:11:18,779
calls lock that other thread is going to

284
00:11:18,980 --> 00:11:20,758
be blocked until the unlock happens then

285
00:11:20,958 --> 00:11:22,709
the lock is free again so at a high

286
00:11:22,909 --> 00:11:24,799
level between the lock and the unlock

287
00:11:25,000 --> 00:11:27,629
for any particular lock like any only a

288
00:11:27,830 --> 00:11:28,948
single thread can be executing what's

289
00:11:29,149 --> 00:11:30,179
called a critical section between the

290
00:11:30,379 --> 00:11:34,828
lock and unlock regions any other

291
00:11:35,028 --> 00:11:37,419
questions

292
00:12:02,899 --> 00:12:05,558
so the question is related to timing

293
00:12:05,759 --> 00:12:07,808
like when you set done equals true and

294
00:12:08,009 --> 00:12:09,729
then you unlock you have no guarantee in

295
00:12:09,929 --> 00:12:11,769
terms of real time like when periodic

296
00:12:11,970 --> 00:12:13,240
will end up being scheduled and observe

297
00:12:13,440 --> 00:12:14,438
this right and actually end up

298
00:12:14,639 --> 00:12:17,289
terminating and so yes if you want to

299
00:12:17,490 --> 00:12:19,179
mean to actually ensure that periodic

300
00:12:19,379 --> 00:12:20,740
has exited for some particular reason

301
00:12:20,940 --> 00:12:22,568
then you could write some code that

302
00:12:22,769 --> 00:12:23,889
communicates back from periodic

303
00:12:24,089 --> 00:12:25,539
acknowledging this but in this

304
00:12:25,740 --> 00:12:27,039
particular case like the only reason we

305
00:12:27,240 --> 00:12:28,359
have the sleep here is just to

306
00:12:28,559 --> 00:12:35,589
demonstrate that the sleep here is just

307
00:12:35,789 --> 00:12:37,118
to demonstrate that tick prints for a

308
00:12:37,318 --> 00:12:39,368
while and then periodic as indeed cancel

309
00:12:39,568 --> 00:12:40,839
it because it stops being printed before

310
00:12:41,039 --> 00:12:44,109
I get my shell prompt back and in

311
00:12:44,309 --> 00:12:45,459
general for a lot of these background

312
00:12:45,659 --> 00:12:46,929
threads like you can just say that you

313
00:12:47,129 --> 00:12:47,979
want to kill them and it doesn't matter

314
00:12:48,179 --> 00:12:49,688
if they're killed within 1 second or

315
00:12:49,889 --> 00:12:51,128
within 2 seconds or one exactly go

316
00:12:51,328 --> 00:12:52,688
schedules it because this thread is

317
00:12:52,889 --> 00:12:54,639
going to just observe this right to done

318
00:12:54,839 --> 00:12:56,289
and then exit do no more works it

319
00:12:56,490 --> 00:12:58,179
doesn't really matter and also another

320
00:12:58,379 --> 00:13:00,758
thing in go is that if you spawn a bunch

321
00:13:00,958 --> 00:13:01,959
of goo routines one of them is the main

322
00:13:02,159 --> 00:13:04,688
go routine this one here and the way go

323
00:13:04,889 --> 00:13:06,309
works is that if the main goroutine

324
00:13:06,509 --> 00:13:08,349
exits the whole program terminates and

325
00:13:08,549 --> 00:13:11,778
all go routines are terminated

326
00:13:27,950 --> 00:13:31,000
that's a great question okay so I think

327
00:13:31,200 --> 00:13:32,139
the question is something like why do

328
00:13:32,340 --> 00:13:33,490
you need locks at all like can you just

329
00:13:33,690 --> 00:13:36,099
delete all the locks and then like

330
00:13:36,299 --> 00:13:37,779
looking at this code it looks like okay

331
00:13:37,980 --> 00:13:39,579
main does a right to true at some point

332
00:13:39,779 --> 00:13:41,559
and periodic is repeatedly reading it so

333
00:13:41,759 --> 00:13:42,819
at some point it should observe this

334
00:13:43,019 --> 00:13:45,669
read right well it turns out that like

335
00:13:45,870 --> 00:13:47,889
this is why go has this fancy memory

336
00:13:48,090 --> 00:13:49,359
model and you have this whole thing on

337
00:13:49,559 --> 00:13:50,799
that happens before relation the

338
00:13:51,000 --> 00:13:52,870
compiler is allowed to take this code

339
00:13:53,070 --> 00:13:55,689
and emit a kind of low-level machine

340
00:13:55,889 --> 00:13:57,039
code that does something a little bit

341
00:13:57,240 --> 00:13:57,879
different than what you intuitively

342
00:13:58,080 --> 00:14:00,459
thought would happen here and we can

343
00:14:00,659 --> 00:14:02,439
talk about that in detail offline after

344
00:14:02,639 --> 00:14:05,649
the lecture and office hours but at a

345
00:14:05,850 --> 00:14:06,909
high level I think one rule you can

346
00:14:07,110 --> 00:14:08,889
follow is if you have accesses to shared

347
00:14:09,090 --> 00:14:10,509
variables and you want to be able to

348
00:14:10,710 --> 00:14:11,859
observe them across different threads

349
00:14:12,059 --> 00:14:14,259
you need to be holding a lock before you

350
00:14:14,460 --> 00:14:15,759
read or write those shared variables in

351
00:14:15,960 --> 00:14:18,069
this particular case I think the go

352
00:14:18,269 --> 00:14:19,449
compiler would be allowed to optimize

353
00:14:19,649 --> 00:14:21,339
this to like lift the read of done

354
00:14:21,539 --> 00:14:24,279
outside the four so read this shared

355
00:14:24,480 --> 00:14:27,189
variable once and then if done is false

356
00:14:27,389 --> 00:14:29,409
then set like make the inside be an

357
00:14:29,610 --> 00:14:32,379
infinite loop because like now the way

358
00:14:32,580 --> 00:14:34,329
this thread is written it had uses no

359
00:14:34,529 --> 00:14:35,620
synchronization primitives there's no

360
00:14:35,820 --> 00:14:37,479
mutex lock or unlock no channel sends or

361
00:14:37,679 --> 00:14:38,949
receives and so it's actually not

362
00:14:39,149 --> 00:14:40,929
guaranteed to observe any mutations done

363
00:14:41,129 --> 00:14:42,990
by other concurrently running threads

364
00:14:43,190 --> 00:14:45,490
and if you look on Piazza I've actually

365
00:14:45,690 --> 00:14:47,529
like written a particular go program

366
00:14:47,730 --> 00:14:49,389
that is optimized in the unintuitive way

367
00:14:49,590 --> 00:14:50,740
like it'll produce code that does an

368
00:14:50,940 --> 00:14:51,939
infinite loop even though looking at it

369
00:14:52,139 --> 00:14:54,189
like you might think that oh the obvious

370
00:14:54,389 --> 00:14:56,019
way to compile this code will produce

371
00:14:56,220 --> 00:14:59,829
something that terminates yeah so the

372
00:15:00,029 --> 00:15:02,649
memory model is pretty fancy and it's

373
00:15:02,850 --> 00:15:04,359
really hard to think about why exactly

374
00:15:04,559 --> 00:15:06,039
incorrect programs are incorrect but if

375
00:15:06,240 --> 00:15:08,679
you follow some general rules like whole

376
00:15:08,879 --> 00:15:09,879
blocks before you mutate shared

377
00:15:10,080 --> 00:15:11,319
variables then you can avoid thinking

378
00:15:11,519 --> 00:15:14,990
about some of these nasty issues

379
00:15:15,289 --> 00:15:19,000
any other questions all right so let's

380
00:15:19,200 --> 00:15:21,479
talk a little bit more about mutexes now

381
00:15:21,679 --> 00:15:24,819
so why do you need mutex is at a high

382
00:15:25,019 --> 00:15:28,000
level whenever you have concurrent

383
00:15:28,200 --> 00:15:29,889
access but by different threads to some

384
00:15:30,090 --> 00:15:32,618
shared data you want to ensure that

385
00:15:32,818 --> 00:15:35,558
reads and writes of that data are atomic

386
00:15:35,759 --> 00:15:38,468
so here's one example of program that

387
00:15:38,668 --> 00:15:40,328
declares a counter and then spawns a

388
00:15:40,528 --> 00:15:40,748
goroutine

389
00:15:40,948 --> 00:15:42,248
actually spawns a thousand go routines

390
00:15:42,448 --> 00:15:44,139
that each update the counter value and

391
00:15:44,339 --> 00:15:46,448
increment it by one and you might think

392
00:15:46,649 --> 00:15:48,008
that looking at this intuitively when I

393
00:15:48,208 --> 00:15:49,238
print out the value of the counter at

394
00:15:49,438 --> 00:15:51,728
the end it should print a thousand but

395
00:15:51,928 --> 00:15:53,498
it turns out that we missed some of the

396
00:15:53,698 --> 00:15:55,389
updates here and in this particular case

397
00:15:55,589 --> 00:15:58,988
it only printed 947 so what's going on

398
00:15:59,188 --> 00:16:02,858
here is that this update here is not

399
00:16:03,058 --> 00:16:04,808
really protected in any way and so these

400
00:16:05,009 --> 00:16:06,548
threads running concurrently can read

401
00:16:06,749 --> 00:16:08,288
the value of counter and update it and

402
00:16:08,489 --> 00:16:11,468
clobber other threads updates of this

403
00:16:11,668 --> 00:16:13,209
value like basically we want to ensure

404
00:16:13,409 --> 00:16:15,908
that this entire section here happens

405
00:16:16,109 --> 00:16:18,188
atomically and so the way you make

406
00:16:18,389 --> 00:16:22,238
blocks of code run atomically are by

407
00:16:22,438 --> 00:16:25,149
using locks and so in this code example

408
00:16:25,350 --> 00:16:28,838
we've fixed this bug we create a lock

409
00:16:29,038 --> 00:16:30,758
and then all these go routines that

410
00:16:30,958 --> 00:16:33,188
modify this counter value first grab the

411
00:16:33,389 --> 00:16:35,858
lock then update the counter value and

412
00:16:36,058 --> 00:16:37,598
then unlock and we see that we're using

413
00:16:37,798 --> 00:16:39,788
this defer keyword here what this does

414
00:16:39,989 --> 00:16:42,788
is basically the same as putting this

415
00:16:42,989 --> 00:16:45,278
code down here so we grab a lock do some

416
00:16:45,479 --> 00:16:47,318
update then unlock defer is just a nice

417
00:16:47,519 --> 00:16:51,338
way of remembering to do this you might

418
00:16:51,538 --> 00:16:53,139
forget to write the unlock later and so

419
00:16:53,339 --> 00:16:54,788
what defer does is it you can think of

420
00:16:54,989 --> 00:16:56,708
it as like scheduling this to run at the

421
00:16:56,908 --> 00:16:59,228
end of the current function body and so

422
00:16:59,428 --> 00:17:00,488
this is a really common pattern you'll

423
00:17:00,688 --> 00:17:02,798
see for example in your RPC handlers for

424
00:17:02,999 --> 00:17:05,198
the lab so oftentimes RPC handlers will

425
00:17:05,398 --> 00:17:08,019
manipulate either read or write data on

426
00:17:08,220 --> 00:17:10,178
the RAF structure right and those

427
00:17:10,378 --> 00:17:11,799
updates should be synchronized with

428
00:17:12,000 --> 00:17:13,719
other concurrently happening updates and

429
00:17:13,919 --> 00:17:15,638
so oftentimes the pattern for RPC

430
00:17:15,838 --> 00:17:16,838
handles would be like grab the lock

431
00:17:17,038 --> 00:17:18,848
differ unlock and then go do some work

432
00:17:19,048 --> 00:17:26,729
inside so we can see if we run this code

433
00:17:26,929 --> 00:17:29,409
it produces the expected results so it

434
00:17:29,609 --> 00:17:30,759
prints out a thousand and we haven't

435
00:17:30,960 --> 00:17:34,358
lost any of these updates and so what at

436
00:17:34,558 --> 00:17:35,799
a high level what a lock or a mutex can

437
00:17:36,000 --> 00:17:38,409
do is guarantee mutual exclusion for a

438
00:17:38,609 --> 00:17:40,178
region of code which we call a critical

439
00:17:40,378 --> 00:17:41,619
section so in here this is the critical

440
00:17:41,819 --> 00:17:43,539
section and it ensures that none of

441
00:17:43,740 --> 00:17:45,279
these critical sections execute

442
00:17:45,480 --> 00:17:46,059
concurrently with

443
00:17:46,259 --> 00:17:47,619
ones they're all serialized happened one

444
00:17:47,819 --> 00:17:51,349
after another question

445
00:18:00,599 --> 00:18:02,899
yes so this is a good observation this

446
00:18:03,099 --> 00:18:04,069
particular could is actually not

447
00:18:04,269 --> 00:18:05,450
guaranteed to produce a thousand

448
00:18:05,650 --> 00:18:07,190
depending on how thread scheduling end

449
00:18:07,390 --> 00:18:08,750
up ends up happening because all the

450
00:18:08,950 --> 00:18:10,759
mean guru teen does is it waits for one

451
00:18:10,960 --> 00:18:12,230
second which is some arbitrary unit of

452
00:18:12,430 --> 00:18:13,879
time and then it prints out the value of

453
00:18:14,079 --> 00:18:15,769
the counter I just want to keep this

454
00:18:15,970 --> 00:18:17,329
example as simple as possible a

455
00:18:17,529 --> 00:18:18,649
different way to write this code that

456
00:18:18,849 --> 00:18:20,389
would be guaranteed to print a thousand

457
00:18:20,589 --> 00:18:22,519
would be to have the main goroutine wait

458
00:18:22,720 --> 00:18:24,169
for all these thousand threads to finish

459
00:18:24,369 --> 00:18:25,099
so you could do this using a weight

460
00:18:25,299 --> 00:18:26,690
group for example but we didn't want to

461
00:18:26,890 --> 00:18:28,129
put two synchronization primitives like

462
00:18:28,329 --> 00:18:29,629
weight groups and mutex is in the same

463
00:18:29,829 --> 00:18:31,220
example so that's why we're at this code

464
00:18:31,420 --> 00:18:32,899
that is like technically incorrect but I

465
00:18:33,099 --> 00:18:34,220
think it still demonstrates the point of

466
00:18:34,420 --> 00:18:43,220
locks any other questions great so at a

467
00:18:43,420 --> 00:18:44,690
very high level you can think of locks

468
00:18:44,890 --> 00:18:46,730
is like you grab the lock you mutate the

469
00:18:46,930 --> 00:18:49,190
shared data and then you unlock so does

470
00:18:49,390 --> 00:18:52,069
this pattern always work well turns out

471
00:18:52,269 --> 00:18:57,109
that that's like a useful starting point

472
00:18:57,309 --> 00:18:58,549
for how to think about locks but it's

473
00:18:58,750 --> 00:19:00,980
not really the complete story so here's

474
00:19:01,180 --> 00:19:03,289
some code this doesn't fit on the screen

475
00:19:03,490 --> 00:19:04,579
but I'll explain it to you we can scroll

476
00:19:04,779 --> 00:19:06,349
through it it basically implements a

477
00:19:06,549 --> 00:19:08,629
bank at a high level so I have Alice and

478
00:19:08,829 --> 00:19:09,950
Bob who both start out with some

479
00:19:10,150 --> 00:19:12,230
balances and then I keep track of what

480
00:19:12,430 --> 00:19:14,210
the total balances like the total amount

481
00:19:14,410 --> 00:19:16,039
of money I store in my bank and then I'm

482
00:19:16,240 --> 00:19:17,809
going to spawn to go routines that will

483
00:19:18,009 --> 00:19:19,129
transfer money back and forth between

484
00:19:19,329 --> 00:19:21,500
our Alice and Bob so this one girl

485
00:19:21,700 --> 00:19:23,529
routine that a thousand times will

486
00:19:23,730 --> 00:19:26,269
reduce one from Alice and send it to Bob

487
00:19:26,470 --> 00:19:28,639
and concurrently running I have this

488
00:19:28,839 --> 00:19:29,930
other go routine that in a loop will

489
00:19:30,130 --> 00:19:31,700
reduce one from Bob and send it to Alice

490
00:19:31,900 --> 00:19:35,149
and notice that I have this mutex here

491
00:19:35,349 --> 00:19:37,940
and whenever I manipulate these shared

492
00:19:38,140 --> 00:19:39,319
variables between these two different

493
00:19:39,519 --> 00:19:39,589
threads

494
00:19:39,789 --> 00:19:41,980
I'm always locking the mutex and this

495
00:19:42,180 --> 00:19:44,690
update only happens while this lock is

496
00:19:44,890 --> 00:19:49,039
held right and so is this code correct

497
00:19:49,240 --> 00:19:53,720
or incorrect there actually isn't really

498
00:19:53,920 --> 00:19:54,919
a straightforward answer to that

499
00:19:55,119 --> 00:19:57,319
question it depends on like what are the

500
00:19:57,519 --> 00:19:59,509
semantics of my bank like what behavior

501
00:19:59,710 --> 00:20:02,809
do I expect so I'm going to introduce

502
00:20:03,009 --> 00:20:04,069
another thread here I'll call this one

503
00:20:04,269 --> 00:20:05,930
the audit thread and what this is going

504
00:20:06,130 --> 00:20:07,339
to do is every once in a while I'll

505
00:20:07,539 --> 00:20:08,839
check it check the sum of all the

506
00:20:09,039 --> 00:20:10,639
accounts in my bank and make sure that

507
00:20:10,839 --> 00:20:12,200
the sum is the same as what it started

508
00:20:12,400 --> 00:20:12,909
out as

509
00:20:13,109 --> 00:20:14,259
right click if I only allow transfers

510
00:20:14,460 --> 00:20:15,700
within my bank the total amount should

511
00:20:15,900 --> 00:20:18,098
never change so now given this other

512
00:20:18,298 --> 00:20:19,930
thread so what this does is it grabs the

513
00:20:20,130 --> 00:20:22,479
lock then sums up Alice Plus Bob and

514
00:20:22,679 --> 00:20:24,129
compares it to the total and if it

515
00:20:24,329 --> 00:20:25,779
doesn't match then it says that though

516
00:20:25,980 --> 00:20:27,279
I've observed some violation that my

517
00:20:27,480 --> 00:20:34,119
total is no longer what it should be if

518
00:20:34,319 --> 00:20:36,309
I run this code I actually see that a

519
00:20:36,509 --> 00:20:37,180
whole bunch of times

520
00:20:37,380 --> 00:20:39,519
this concurrently running thread does

521
00:20:39,720 --> 00:20:41,289
indeed observe that Alice Plus Bob is

522
00:20:41,490 --> 00:20:43,509
not equal to the overall sum so what

523
00:20:43,710 --> 00:20:45,549
went wrong here like we're following our

524
00:20:45,750 --> 00:20:47,710
basic rule of whenever we're accessing

525
00:20:47,910 --> 00:20:49,299
data that's shared between threads we

526
00:20:49,500 --> 00:20:52,119
grab a lock it is indeed true that no

527
00:20:52,319 --> 00:20:53,940
updates to these shared variables happen

528
00:20:54,140 --> 00:21:15,339
while the lock is not held exactly so

529
00:21:15,539 --> 00:21:16,719
let me repeat that for everybody to hear

530
00:21:16,919 --> 00:21:19,358
what we intended here was for this

531
00:21:19,558 --> 00:21:21,309
decrement and increment to happen

532
00:21:21,509 --> 00:21:23,319
atomically but instead of what we ended

533
00:21:23,519 --> 00:21:25,389
up writing was code that decrement

534
00:21:25,589 --> 00:21:26,919
atomically and then increments

535
00:21:27,119 --> 00:21:28,719
atomically and so in this particular

536
00:21:28,919 --> 00:21:30,759
code actually like we won't lose money

537
00:21:30,960 --> 00:21:32,529
in the long term like if we let these

538
00:21:32,730 --> 00:21:33,819
threads run and then wait till they

539
00:21:34,019 --> 00:21:35,829
finish and then check the total it will

540
00:21:36,029 --> 00:21:37,629
indeed be what it started out as but

541
00:21:37,829 --> 00:21:39,339
while these are running since this

542
00:21:39,539 --> 00:21:41,649
entire block of code is not atomic we

543
00:21:41,849 --> 00:21:43,979
can temporarily observe these violations

544
00:21:44,179 --> 00:21:46,690
and so at a higher level the way should

545
00:21:46,890 --> 00:21:49,059
think about locking is not just like

546
00:21:49,259 --> 00:21:51,460
locks are to protect access to shared

547
00:21:51,660 --> 00:21:53,440
data but locks are meant to protect

548
00:21:53,640 --> 00:21:55,750
invariants you have some shared data

549
00:21:55,950 --> 00:21:57,190
that multiple people might access and

550
00:21:57,390 --> 00:21:58,569
there's some properties that hold on

551
00:21:58,769 --> 00:22:00,608
that shared data like for example here I

552
00:22:00,808 --> 00:22:02,469
is the programmer decided that I want

553
00:22:02,669 --> 00:22:04,119
this property that alice + Bob should

554
00:22:04,319 --> 00:22:05,559
equal some constant and that should

555
00:22:05,759 --> 00:22:07,329
always be that way I want that property

556
00:22:07,529 --> 00:22:09,039
to hold but then it may be the case that

557
00:22:09,240 --> 00:22:09,940
different threads running concurrently

558
00:22:10,140 --> 00:22:12,190
are making changes to this data and

559
00:22:12,390 --> 00:22:14,409
might temporarily break this invariant

560
00:22:14,609 --> 00:22:16,450
here right like here when I decrement

561
00:22:16,650 --> 00:22:18,940
from Alice temporarily the sum Alice

562
00:22:19,140 --> 00:22:20,559
Plus Bob has changed but then this

563
00:22:20,759 --> 00:22:22,358
thread eventually ends up restoring this

564
00:22:22,558 --> 00:22:25,029
invariant here and so locks are meant to

565
00:22:25,230 --> 00:22:25,799
protect and vary

566
00:22:26,000 --> 00:22:27,750
at a high level you grab a lock then you

567
00:22:27,950 --> 00:22:29,039
do some work that might temporarily

568
00:22:29,240 --> 00:22:31,169
break the invariant but then you restore

569
00:22:31,369 --> 00:22:32,608
the invariant before you release the

570
00:22:32,808 --> 00:22:34,078
lock so nobody can observe these in

571
00:22:34,278 --> 00:22:36,209
progress updates and so the correct way

572
00:22:36,409 --> 00:22:38,250
to write this code is to actually have

573
00:22:38,450 --> 00:22:39,598
less use of lock and unlock

574
00:22:39,798 --> 00:22:41,608
we have lock then we do a bunch of work

575
00:22:41,808 --> 00:22:43,558
and then we unlock and when you run this

576
00:22:43,759 --> 00:22:48,058
code we see no more printouts like this

577
00:22:48,259 --> 00:22:50,188
that we never have this audit thread

578
00:22:50,388 --> 00:22:52,289
observe that the total is not what it

579
00:22:52,490 --> 00:22:55,379
should be all right so that's the right

580
00:22:55,579 --> 00:22:58,769
way to think about locking at kind of a

581
00:22:58,970 --> 00:23:00,479
high level you can think about it as

582
00:23:00,679 --> 00:23:02,098
make sure you grab locks when every

583
00:23:02,298 --> 00:23:03,568
access shared data like that is a rule

584
00:23:03,769 --> 00:23:06,568
but another important rule is locks

585
00:23:06,769 --> 00:23:09,000
protect invariants so grab a lock

586
00:23:09,200 --> 00:23:10,588
manipulate things in a way that might

587
00:23:10,788 --> 00:23:11,848
break the invariants but restore them

588
00:23:12,048 --> 00:23:15,289
afterwards and then release the lock

589
00:23:15,490 --> 00:23:17,129
another way you can think about it is

590
00:23:17,329 --> 00:23:19,078
locks can make regions of code atomic

591
00:23:19,278 --> 00:23:20,938
not just like single statements or

592
00:23:21,138 --> 00:23:25,858
single updates to shared variables any

593
00:23:26,058 --> 00:23:30,659
questions about that great so the next

594
00:23:30,859 --> 00:23:32,639
synchronization primitive we're going to

595
00:23:32,839 --> 00:23:33,899
talk about it something called condition

596
00:23:34,099 --> 00:23:36,869
variables and this is it seems like

597
00:23:37,069 --> 00:23:38,009
there's been a source of confusion from

598
00:23:38,210 --> 00:23:39,178
lab one where we mentioned condition

599
00:23:39,378 --> 00:23:40,500
variables but didn't quite explain them

600
00:23:40,700 --> 00:23:41,399
so we're going to take the time to

601
00:23:41,599 --> 00:23:43,348
explain them to you now and we're going

602
00:23:43,548 --> 00:23:45,269
to do that in the context of an example

603
00:23:45,470 --> 00:23:47,448
that you should all be familiar with

604
00:23:47,648 --> 00:23:50,909
counting votes so remember in lab 2a you

605
00:23:51,109 --> 00:23:52,828
have this pattern where whenever Raph

606
00:23:53,028 --> 00:23:54,688
Pierre becomes a candidate it wants to

607
00:23:54,888 --> 00:23:56,159
send out vote requests all of its

608
00:23:56,359 --> 00:23:58,678
followers and eventually the followers

609
00:23:58,878 --> 00:24:01,289
come back to the candidate and say yes

610
00:24:01,490 --> 00:24:02,669
or no like whether or not the candidate

611
00:24:02,869 --> 00:24:04,409
got the vote right and one way we could

612
00:24:04,609 --> 00:24:06,479
write this code is have the candidate in

613
00:24:06,679 --> 00:24:08,848
serial ask Pierre number one car number

614
00:24:09,048 --> 00:24:10,379
two for number three and so on but

615
00:24:10,579 --> 00:24:12,209
that's bad right because we want the

616
00:24:12,409 --> 00:24:13,889
candidate ask all the peers in parallel

617
00:24:14,089 --> 00:24:15,328
so it can quickly win the election when

618
00:24:15,528 --> 00:24:16,828
possible and then there's some other

619
00:24:17,028 --> 00:24:18,959
complexities there like when we ask all

620
00:24:19,159 --> 00:24:21,209
the peers in parallel we don't want to

621
00:24:21,409 --> 00:24:22,709
wait so we get a response from all of

622
00:24:22,909 --> 00:24:24,088
them before making up our mind right

623
00:24:24,288 --> 00:24:25,709
because if a candidate gets a majority

624
00:24:25,909 --> 00:24:27,568
of votes like it doesn't need to wait

625
00:24:27,769 --> 00:24:29,009
till it hears back from everybody else

626
00:24:29,210 --> 00:24:31,289
so this code is kind of complicated in

627
00:24:31,490 --> 00:24:34,729
some ways and so here here's a kind of

628
00:24:34,929 --> 00:24:36,838
stubbed out version of what that vote

629
00:24:37,038 --> 00:24:38,909
counting code might look like

630
00:24:39,109 --> 00:24:40,049
with a little bit of infrastructure to

631
00:24:40,250 --> 00:24:41,578
make it actually run and so here have

632
00:24:41,778 --> 00:24:43,198
this mean goroutine that sets count

633
00:24:43,398 --> 00:24:44,729
which is like the number of yes votes I

634
00:24:44,929 --> 00:24:47,369
got to zero and finish to zero finished

635
00:24:47,569 --> 00:24:48,659
as the number of responses I've gotten

636
00:24:48,859 --> 00:24:50,578
in total and the idea is I want to send

637
00:24:50,778 --> 00:24:52,469
out vote requests in parallel and keep

638
00:24:52,669 --> 00:24:54,209
track of how many yeses I've got and how

639
00:24:54,409 --> 00:24:55,649
many responses I've gotten in general

640
00:24:55,849 --> 00:24:58,049
and then once I know whether I've won

641
00:24:58,250 --> 00:24:59,519
the election or whether I know that I've

642
00:24:59,720 --> 00:25:01,740
lost the election then I can determine

643
00:25:01,940 --> 00:25:03,690
that and move on and like the real raft

644
00:25:03,890 --> 00:25:04,979
code you actually do whatever you need

645
00:25:05,179 --> 00:25:07,649
to do don't step up to a leader or to

646
00:25:07,849 --> 00:25:09,838
step down to a follower after you have

647
00:25:10,038 --> 00:25:12,568
the result from this and so looking at

648
00:25:12,769 --> 00:25:14,848
this code here I'm going to in parallel

649
00:25:15,048 --> 00:25:17,279
spun say I have ten peers in parallel

650
00:25:17,480 --> 00:25:18,539
spawn ten goroutines

651
00:25:18,740 --> 00:25:20,698
here I pass in this closure here and I'm

652
00:25:20,898 --> 00:25:23,068
gonna do is request a vote and then if I

653
00:25:23,269 --> 00:25:24,659
get the vote I'm going to increment the

654
00:25:24,859 --> 00:25:26,430
count by one and then I'm also going to

655
00:25:26,630 --> 00:25:28,229
increment this finished by one so like

656
00:25:28,429 --> 00:25:30,029
this is a number of yeses this is total

657
00:25:30,230 --> 00:25:32,009
number of responses I've gotten and then

658
00:25:32,210 --> 00:25:34,108
outside here in the main go routine what

659
00:25:34,308 --> 00:25:35,250
I'm doing is keeping track of this

660
00:25:35,450 --> 00:25:36,659
condition I'm waiting for this condition

661
00:25:36,859 --> 00:25:38,549
to become true that either I have enough

662
00:25:38,750 --> 00:25:40,289
yes votes that I've won the election or

663
00:25:40,490 --> 00:25:42,240
I've heard back from enough peers and I

664
00:25:42,440 --> 00:25:44,009
know that I've lost and so I'm just

665
00:25:44,210 --> 00:25:46,828
going to in a in a loop check to see and

666
00:25:47,028 --> 00:25:49,229
wait until count is greater than or

667
00:25:49,429 --> 00:25:51,358
equal to five or wait until finished is

668
00:25:51,558 --> 00:25:53,129
equal to ten and then after that's the

669
00:25:53,329 --> 00:25:54,750
case I can either determine that I've

670
00:25:54,950 --> 00:25:56,639
lost drive one so does anybody see any

671
00:25:56,839 --> 00:25:58,469
problems with this code given what we

672
00:25:58,669 --> 00:26:03,130
just talked about about mutexes yes

673
00:26:04,769 --> 00:26:06,230
yeah exactly

674
00:26:06,430 --> 00:26:07,789
countin finished aren't protected by

675
00:26:07,990 --> 00:26:09,919
mutexes so one thing we certainly need

676
00:26:10,119 --> 00:26:13,220
to fix here is that whenever we have

677
00:26:13,420 --> 00:26:14,809
shared variables we need to protect

678
00:26:15,009 --> 00:26:17,299
access with new taxes and so that's not

679
00:26:17,500 --> 00:26:20,839
too bad to fix here I declare mutex

680
00:26:21,039 --> 00:26:22,909
that's accessible by everybody and then

681
00:26:23,109 --> 00:26:25,279
in the go routines I'm launching in

682
00:26:25,480 --> 00:26:27,349
parallel to request votes I'm going to

683
00:26:27,549 --> 00:26:29,119
and this this pattern here is pretty

684
00:26:29,319 --> 00:26:30,740
important I'm going to first request a

685
00:26:30,940 --> 00:26:32,930
vote while I'm not holding the lock and

686
00:26:33,130 --> 00:26:34,220
then after wear that I'm going to grab

687
00:26:34,420 --> 00:26:35,569
the lock and then update these shared

688
00:26:35,769 --> 00:26:40,129
variables and then outside I have the

689
00:26:40,329 --> 00:26:41,629
same patterns as before except I make

690
00:26:41,829 --> 00:26:43,579
sure to lock and unlock between reading

691
00:26:43,779 --> 00:26:45,529
these shared variables so in an infinite

692
00:26:45,730 --> 00:26:48,079
loop I grab the lock and check to see if

693
00:26:48,279 --> 00:26:49,609
the results of the election have been

694
00:26:49,809 --> 00:26:51,559
determined by this point and if not I'm

695
00:26:51,759 --> 00:26:52,639
going to keep running in this infinite

696
00:26:52,839 --> 00:26:57,619
loop otherwise I'll unlock and then do

697
00:26:57,819 --> 00:27:00,799
what I need to do outside of here and so

698
00:27:01,000 --> 00:27:09,230
if I run this example whoops it seems to

699
00:27:09,430 --> 00:27:12,649
work and this is actually like a correct

700
00:27:12,849 --> 00:27:14,569
implementation it does the right thing

701
00:27:14,769 --> 00:27:16,759
but there's some problems with it so can

702
00:27:16,960 --> 00:27:18,169
anybody recognize any problems with this

703
00:27:18,369 --> 00:27:22,789
implementation I'll give you a hint this

704
00:27:22,990 --> 00:27:26,430
code is not as nice as it could be

705
00:27:32,410 --> 00:27:34,859
so not quite it's going to wait for

706
00:27:35,059 --> 00:27:36,869
exactly the right amount of time the

707
00:27:37,069 --> 00:27:38,970
issue here is that it's busy waiting

708
00:27:39,170 --> 00:27:41,669
what it's doing is in a very tight loop

709
00:27:41,869 --> 00:27:43,319
it's grabbing the lock checking this

710
00:27:43,519 --> 00:27:45,509
condition unlocking grabbing this lock

711
00:27:45,710 --> 00:27:46,889
checking this condition unlocking and

712
00:27:47,089 --> 00:27:49,230
it's going to burn up 100% CPU on one

713
00:27:49,430 --> 00:27:51,419
core while it's doing this so this code

714
00:27:51,619 --> 00:27:53,819
is correct but it's like at a high level

715
00:27:54,019 --> 00:27:55,769
we don't care about efficiency like CPU

716
00:27:55,970 --> 00:27:57,419
efficiency for the purpose of the labs

717
00:27:57,619 --> 00:27:59,639
but if you're using a hundred percent of

718
00:27:59,839 --> 00:28:01,049
one core you might actually slow down

719
00:28:01,250 --> 00:28:02,460
the rest of your program enough that it

720
00:28:02,660 --> 00:28:04,919
won't make progress and so that's why

721
00:28:05,119 --> 00:28:06,509
this pattern is bad that we're burning

722
00:28:06,710 --> 00:28:08,369
up a hundred percent CPU waiting for

723
00:28:08,569 --> 00:28:10,559
some condition to become true right so

724
00:28:10,759 --> 00:28:11,909
does anybody have any ideas for how we

725
00:28:12,109 --> 00:28:17,879
could fix this so here's one simple

726
00:28:18,079 --> 00:28:18,569
solution

727
00:28:18,769 --> 00:28:22,950
I will change a single line of code all

728
00:28:23,150 --> 00:28:25,079
I've added here is wait for 50

729
00:28:25,279 --> 00:28:28,470
milliseconds and so this is a correct

730
00:28:28,670 --> 00:28:30,359
transformation of that program and it

731
00:28:30,559 --> 00:28:31,829
kind of seems to solve the problem right

732
00:28:32,029 --> 00:28:33,419
like before I was burning up a hundred

733
00:28:33,619 --> 00:28:36,180
percent CPU now only once every 50

734
00:28:36,380 --> 00:28:37,379
milliseconds I'm going to briefly wake

735
00:28:37,579 --> 00:28:39,569
up check this condition and go back to

736
00:28:39,769 --> 00:28:40,019
sleep

737
00:28:40,220 --> 00:28:42,869
if it doesn't hold and so this is like

738
00:28:43,069 --> 00:28:46,109
basically a working solution any

739
00:28:46,309 --> 00:28:51,480
questions so this kind of sorta works

740
00:28:51,680 --> 00:28:53,009
but one thing you should always be aware

741
00:28:53,210 --> 00:28:55,680
of whenever you write code is magic

742
00:28:55,880 --> 00:28:58,169
constants why is this 50 milliseconds

743
00:28:58,369 --> 00:28:59,940
why not a different number like whenever

744
00:29:00,140 --> 00:29:01,079
you have an arbitrary number in your

745
00:29:01,279 --> 00:29:02,609
code it's a sign that you're doing

746
00:29:02,809 --> 00:29:04,440
something that's not quite right or not

747
00:29:04,640 --> 00:29:06,809
quite as clean as it could be and so it

748
00:29:07,009 --> 00:29:08,039
turns out that there's a concurrency

749
00:29:08,240 --> 00:29:10,109
primitive designed to solve exactly this

750
00:29:10,309 --> 00:29:12,599
problem of I have some threads running

751
00:29:12,799 --> 00:29:15,119
concurrently that are making updates to

752
00:29:15,319 --> 00:29:16,859
some shared data and then I have another

753
00:29:17,059 --> 00:29:19,049
thread that's waiting for some property

754
00:29:19,250 --> 00:29:20,879
some condition on that shared data to

755
00:29:21,079 --> 00:29:22,529
become true and until that condition

756
00:29:22,730 --> 00:29:23,970
becomes true the thread is just going to

757
00:29:24,170 --> 00:29:26,460
wait there's a tool designed exactly to

758
00:29:26,660 --> 00:29:28,049
solve this problem and that's a tool

759
00:29:28,250 --> 00:29:33,659
called a condition variable and the way

760
00:29:33,859 --> 00:29:36,779
you use a condition variable is the

761
00:29:36,980 --> 00:29:38,759
pattern basically looks like this so we

762
00:29:38,960 --> 00:29:40,589
have our lock from earlier condition

763
00:29:40,789 --> 00:29:43,198
variables are associated with locks so

764
00:29:43,398 --> 00:29:46,528
we have some shared data some a lock

765
00:29:46,729 --> 00:29:48,240
that protects that shared data and then

766
00:29:48,440 --> 00:29:49,798
we have this condition variable that is

767
00:29:49,999 --> 00:29:51,209
given a pointer to the lock when it's

768
00:29:51,409 --> 00:29:52,948
initialized and we're going to use this

769
00:29:53,148 --> 00:29:54,448
condition variable for kind of

770
00:29:54,648 --> 00:29:56,459
coordinating when a certain condition

771
00:29:56,659 --> 00:29:58,379
some property on that shared data when

772
00:29:58,579 --> 00:30:01,858
that becomes true and the way we modify

773
00:30:02,058 --> 00:30:05,009
our code is like we have two places one

774
00:30:05,210 --> 00:30:07,138
we're making changes to that data which

775
00:30:07,338 --> 00:30:08,788
might make the condition become true and

776
00:30:08,989 --> 00:30:10,108
then we have another place where we're

777
00:30:10,308 --> 00:30:11,369
waiting for that condition to become

778
00:30:11,569 --> 00:30:14,009
true and the general pattern is whenever

779
00:30:14,210 --> 00:30:17,519
we do something that changes the data we

780
00:30:17,719 --> 00:30:20,519
call a conduct broadcast and we do this

781
00:30:20,719 --> 00:30:22,588
while holding the lock and then on the

782
00:30:22,788 --> 00:30:23,879
other side where we're waiting for some

783
00:30:24,079 --> 00:30:25,229
condition on that share data to become

784
00:30:25,429 --> 00:30:28,469
true we call con dot wait and so what

785
00:30:28,669 --> 00:30:30,509
this does is like let's think about what

786
00:30:30,710 --> 00:30:31,858
happens in the mean thread for a moment

787
00:30:32,058 --> 00:30:33,869
the main thread grabs the lock it checks

788
00:30:34,069 --> 00:30:35,969
this condition suppose it's false it

789
00:30:36,169 --> 00:30:38,698
calls con dot wait what this will do is

790
00:30:38,898 --> 00:30:40,288
it will atomically you can think of it

791
00:30:40,489 --> 00:30:42,209
as it'll release the lock in order to

792
00:30:42,409 --> 00:30:44,158
let other people make progress and it'll

793
00:30:44,358 --> 00:30:46,348
add its thread like it'll add itself to

794
00:30:46,548 --> 00:30:48,598
a like list of people who are waiting on

795
00:30:48,798 --> 00:30:50,759
this condition variable then

796
00:30:50,960 --> 00:30:52,588
concurrently one of these threads might

797
00:30:52,788 --> 00:30:54,448
be able to acquire the lock after it's

798
00:30:54,648 --> 00:30:56,519
gotten a vote and then it manipulates

799
00:30:56,719 --> 00:30:57,808
these variables and then it calls

800
00:30:58,009 --> 00:31:00,568
conduct broadcast what that does is it

801
00:31:00,769 --> 00:31:02,879
wakes up whoever's waiting on the

802
00:31:03,079 --> 00:31:04,918
condition variable and so once this

803
00:31:05,118 --> 00:31:08,759
thread unlocks the mutex this one what

804
00:31:08,960 --> 00:31:10,500
do we want as it's returning from wait

805
00:31:10,700 --> 00:31:13,019
we'll reacquire the mutex and then

806
00:31:13,219 --> 00:31:14,879
return to the top of this for loop which

807
00:31:15,079 --> 00:31:18,028
is checking this condition so this

808
00:31:18,229 --> 00:31:20,338
broadcast wakes up whoever's waiting at

809
00:31:20,538 --> 00:31:25,198
this wait and so this avoids having to

810
00:31:25,398 --> 00:31:27,148
have that time dot sleeve for some

811
00:31:27,348 --> 00:31:28,918
arbitrary amount of time like this

812
00:31:29,118 --> 00:31:30,388
thread that's waiting for some condition

813
00:31:30,588 --> 00:31:32,759
to become true only gets woken up when

814
00:31:32,960 --> 00:31:34,318
something changes that might make that

815
00:31:34,519 --> 00:31:35,908
condition become true right like if you

816
00:31:36,108 --> 00:31:37,379
think about these threads if they're

817
00:31:37,579 --> 00:31:39,928
very slow and they don't call conned out

818
00:31:40,128 --> 00:31:42,000
broadcast for a long time this one will

819
00:31:42,200 --> 00:31:43,288
just be waiting it won't be like

820
00:31:43,489 --> 00:31:44,638
periodically waking up and checking some

821
00:31:44,838 --> 00:31:46,648
condition that can't have changed

822
00:31:46,848 --> 00:31:48,298
because nobody else manipulated their

823
00:31:48,499 --> 00:31:51,990
shared data so any questions about this

824
00:31:52,190 --> 00:31:55,269
pattern yeah

825
00:32:16,160 --> 00:32:17,609
so that's a great question I think

826
00:32:17,809 --> 00:32:18,930
you're referring to something called the

827
00:32:19,130 --> 00:32:21,750
lost wake up problem and this is a topic

828
00:32:21,950 --> 00:32:22,980
in operating systems and we won't talk

829
00:32:23,180 --> 00:32:24,509
about it in detail now there feel free

830
00:32:24,710 --> 00:32:26,399
to ask me after lecture but at a high

831
00:32:26,599 --> 00:32:27,899
level you can avoid funny race

832
00:32:28,099 --> 00:32:29,159
conditions that might happen between

833
00:32:29,359 --> 00:32:31,139
wait and broadcast by following the

834
00:32:31,339 --> 00:32:32,519
particular pattern I'm showing here and

835
00:32:32,720 --> 00:32:33,779
I'll show you an abstracted version of

836
00:32:33,980 --> 00:32:36,450
this pattern in a moment basically the

837
00:32:36,650 --> 00:32:39,149
pattern is for the side that might make

838
00:32:39,349 --> 00:32:40,980
changes that will change the outcome of

839
00:32:41,180 --> 00:32:44,359
the condition test you always lock then

840
00:32:44,559 --> 00:32:47,190
manipulate the data then call broadcast

841
00:32:47,390 --> 00:32:49,259
and call unlock afterwards so the

842
00:32:49,460 --> 00:32:50,940
broadcast must be called while holding

843
00:32:51,140 --> 00:32:53,069
the lock similarly when you're checking

844
00:32:53,269 --> 00:32:55,289
the condition you grab the lock then

845
00:32:55,490 --> 00:32:56,730
you're always checking the condition in

846
00:32:56,930 --> 00:32:59,279
a loop and then inside so when that

847
00:32:59,480 --> 00:33:01,589
condition is false you call Condit wait

848
00:33:01,789 --> 00:33:03,389
this is only called while you're holding

849
00:33:03,589 --> 00:33:05,549
the lock and it atomically releases the

850
00:33:05,750 --> 00:33:07,319
lock and kind of schedule like puts

851
00:33:07,519 --> 00:33:08,909
itself in a list of waiting threads and

852
00:33:09,109 --> 00:33:11,940
then as waits returning so as we like

853
00:33:12,140 --> 00:33:13,440
return from this wait call and then go

854
00:33:13,640 --> 00:33:14,879
back to the top of this for loop it will

855
00:33:15,079 --> 00:33:16,649
reacquire the lock so this check will

856
00:33:16,849 --> 00:33:18,119
only happen while holding the lock and

857
00:33:18,319 --> 00:33:19,619
then so outside of this we still have

858
00:33:19,819 --> 00:33:21,419
the lock here and we unlock after we're

859
00:33:21,619 --> 00:33:23,839
done doing whatever we need to do here

860
00:33:24,039 --> 00:33:25,980
at a high level this pattern looks like

861
00:33:26,180 --> 00:33:28,409
this so we have one thread or some

862
00:33:28,609 --> 00:33:29,579
number of threads doing something that

863
00:33:29,779 --> 00:33:31,109
might affect the condition so they're

864
00:33:31,309 --> 00:33:33,329
going to grab a lock do the thing call

865
00:33:33,529 --> 00:33:35,970
broadcast then call unlock and on the

866
00:33:36,170 --> 00:33:37,139
other side we have some thread that's

867
00:33:37,339 --> 00:33:38,369
waiting for some condition to become

868
00:33:38,569 --> 00:33:40,259
true the pattern there it looks like we

869
00:33:40,460 --> 00:33:42,389
grab the lock then in a while loop while

870
00:33:42,589 --> 00:33:44,700
the condition is false we wait and so

871
00:33:44,900 --> 00:33:46,409
then we know that when we get past this

872
00:33:46,609 --> 00:33:48,089
while loop now the condition is true and

873
00:33:48,289 --> 00:33:49,799
we're holding the lock and we can do

874
00:33:50,000 --> 00:33:51,359
whatever we need to do here and then

875
00:33:51,559 --> 00:33:54,480
finally we call unlock so we can talk

876
00:33:54,680 --> 00:33:55,589
about all the things that might go wrong

877
00:33:55,789 --> 00:33:57,509
if you violate one of these rules like

878
00:33:57,710 --> 00:33:58,950
after lecture if you're interested but

879
00:33:59,150 --> 00:34:00,329
at a high level if you follow this

880
00:34:00,529 --> 00:34:01,799
pattern then you won't need to deal with

881
00:34:02,000 --> 00:34:07,690
those issues so any questions about that

882
00:34:08,889 --> 00:34:11,889
yeah

883
00:34:14,050 --> 00:34:15,750
so that's a great question

884
00:34:15,949 --> 00:34:17,789
when do you use broadcast versus when do

885
00:34:17,989 --> 00:34:19,380
use signals so converse have three

886
00:34:19,579 --> 00:34:21,120
methods on them one is wait for the

887
00:34:21,320 --> 00:34:22,979
waiting side and then on the other side

888
00:34:23,179 --> 00:34:25,260
you can use signal or broadcast and the

889
00:34:25,460 --> 00:34:27,510
semantics of those are signal wait wakes

890
00:34:27,710 --> 00:34:29,910
up exactly one waiter like one thread

891
00:34:30,110 --> 00:34:30,600
that may be waiting

892
00:34:30,800 --> 00:34:32,610
whereas broadcast wakes up everybody

893
00:34:32,809 --> 00:34:33,810
who's waiting and they'll all reach out

894
00:34:34,010 --> 00:34:35,370
like they'll all try to grab the law can

895
00:34:35,570 --> 00:34:37,170
recheck the condition and only one of

896
00:34:37,369 --> 00:34:38,580
them will proceed because only one a

897
00:34:38,780 --> 00:34:39,780
little he'll door lock until it gets

898
00:34:39,980 --> 00:34:41,970
past this point I think for the purpose

899
00:34:42,170 --> 00:34:43,920
of this class always use broadcast never

900
00:34:44,119 --> 00:34:45,390
use signal if you follow this pattern

901
00:34:45,590 --> 00:34:46,680
and just like don't use signal and

902
00:34:46,880 --> 00:34:48,539
always use broadcast your code will work

903
00:34:48,739 --> 00:34:51,570
I think you can stick think of signal as

904
00:34:51,769 --> 00:34:53,850
something used for efficiency and we

905
00:34:54,050 --> 00:34:55,289
don't really care about that level of

906
00:34:55,489 --> 00:34:56,970
CPU efficiency in the labs for this

907
00:34:57,170 --> 00:34:59,349
class

908
00:35:00,280 --> 00:35:06,060
any more questions ok so the final topic

909
00:35:06,260 --> 00:35:07,680
we're going to cover in terms of go

910
00:35:07,880 --> 00:35:10,440
concurrency primitives is channels so

911
00:35:10,639 --> 00:35:12,420
two high level channels are like a queue

912
00:35:12,619 --> 00:35:14,700
like synchronization primitive but they

913
00:35:14,900 --> 00:35:18,050
don't behave quite like cues in the

914
00:35:18,250 --> 00:35:21,930
intuitive sense like I think some people

915
00:35:22,130 --> 00:35:23,580
think of channels is like there's this

916
00:35:23,780 --> 00:35:25,170
data structure we can sticks that stick

917
00:35:25,369 --> 00:35:26,640
things in and eventually someone will

918
00:35:26,840 --> 00:35:28,140
pull those things out but in fact

919
00:35:28,340 --> 00:35:30,990
channels have no queuing capacity they

920
00:35:31,190 --> 00:35:34,380
have no internal storage basically

921
00:35:34,579 --> 00:35:36,330
channels are synchronous if you have to

922
00:35:36,530 --> 00:35:37,500
go routines that are going to send and

923
00:35:37,699 --> 00:35:39,150
receive on a channel if someone tries to

924
00:35:39,349 --> 00:35:40,860
send on the channel while nobody's

925
00:35:41,059 --> 00:35:42,990
receiving that thread will block until

926
00:35:43,190 --> 00:35:45,660
somebody's ready to receive and at that

927
00:35:45,860 --> 00:35:47,460
point synchronously it will exchange

928
00:35:47,659 --> 00:35:50,100
that data over to the receiver and the

929
00:35:50,300 --> 00:35:51,539
same is true the other direction if

930
00:35:51,739 --> 00:35:52,830
someone tries to receive from a channel

931
00:35:53,030 --> 00:35:54,720
while nobody's sending that receive will

932
00:35:54,920 --> 00:35:56,490
block until there's another goroutine

933
00:35:56,690 --> 00:35:58,110
that's about to send on the channel and

934
00:35:58,309 --> 00:36:00,600
that send will happen synchronously so

935
00:36:00,800 --> 00:36:01,769
here's a little demo program that

936
00:36:01,969 --> 00:36:04,470
demonstrates this here I have a I

937
00:36:04,670 --> 00:36:06,240
declare channel and then I spawn a go

938
00:36:06,440 --> 00:36:08,550
routine that waits for a second and then

939
00:36:08,750 --> 00:36:11,400
sent and then receives from a channel

940
00:36:11,599 --> 00:36:14,670
and then in my main girl routine I keep

941
00:36:14,869 --> 00:36:16,440
track of the time then I send on the

942
00:36:16,639 --> 00:36:17,580
channel so I just put some dummy data

943
00:36:17,780 --> 00:36:19,170
into the channel and then I'm going to

944
00:36:19,369 --> 00:36:22,900
print out how long the send took

945
00:36:25,568 --> 00:36:29,129
and if you think of channels as cues

946
00:36:29,329 --> 00:36:31,379
with internal storage capacity you might

947
00:36:31,579 --> 00:36:32,760
think of this thing as completing very

948
00:36:32,960 --> 00:36:35,099
fast but that's not how channels work

949
00:36:35,298 --> 00:36:38,039
this send is going to block until this

950
00:36:38,239 --> 00:36:39,539
receive happens and this one happened

951
00:36:39,739 --> 00:36:40,950
till this one second is the elapsed and

952
00:36:41,150 --> 00:36:42,750
so from here to here

953
00:36:42,949 --> 00:36:44,639
we're actually blocked in the main goo

954
00:36:44,838 --> 00:36:48,119
routine for one whole second alright so

955
00:36:48,318 --> 00:36:49,950
don't think of channels as queues think

956
00:36:50,150 --> 00:36:51,480
of them as this synchronous like the

957
00:36:51,679 --> 00:36:55,179
synchronous communication mechanism

958
00:36:55,420 --> 00:36:57,389
another example that'll make this really

959
00:36:57,588 --> 00:36:59,460
obvious is here we have a goroutine that

960
00:36:59,659 --> 00:37:01,200
creates a channel then sends on the

961
00:37:01,400 --> 00:37:02,490
channel and tries receiving from it

962
00:37:02,690 --> 00:37:04,019
doesn't anybody know what'll happen when

963
00:37:04,219 --> 00:37:04,950
I try running this

964
00:37:05,150 --> 00:37:10,510
I think the file name might give it away

965
00:37:15,880 --> 00:37:18,089
yeah exactly the send is going to block

966
00:37:18,289 --> 00:37:19,440
till somebody's ready to receive but

967
00:37:19,639 --> 00:37:22,530
there is no receiver and go actually

968
00:37:22,730 --> 00:37:24,000
detects this condition if all your

969
00:37:24,199 --> 00:37:25,409
threads are sleeping it to text this is

970
00:37:25,608 --> 00:37:27,419
a deadlock condition and it'll actually

971
00:37:27,619 --> 00:37:29,099
crash but you can have more subtle bugs

972
00:37:29,298 --> 00:37:31,230
where if you have some other thread like

973
00:37:31,429 --> 00:37:36,690
off doing something if I spawn this go

974
00:37:36,889 --> 00:37:38,460
routine that you know for loop does

975
00:37:38,659 --> 00:37:41,639
nothing and I try running this program

976
00:37:41,838 --> 00:37:43,859
again now it goes deadlock detector

977
00:37:44,059 --> 00:37:45,060
won't notice that all threads are not

978
00:37:45,260 --> 00:37:46,409
doing any use will work like there's one

979
00:37:46,608 --> 00:37:48,329
thread running it's just this is never

980
00:37:48,528 --> 00:37:49,800
receiving and we can tell by looking at

981
00:37:50,000 --> 00:37:51,060
this program that it'll never terminate

982
00:37:51,260 --> 00:37:54,720
but here it just looks like it hangs so

983
00:37:54,920 --> 00:37:56,159
if you're not careful with channels you

984
00:37:56,358 --> 00:37:58,470
can get these subtle bugs where you have

985
00:37:58,670 --> 00:38:05,399
double X as a result yeah yeah exactly

986
00:38:05,599 --> 00:38:07,470
there's no data nobody's sending on this

987
00:38:07,670 --> 00:38:08,700
channel so this is gonna block here it's

988
00:38:08,900 --> 00:38:11,769
never gonna get to this line

989
00:38:19,469 --> 00:38:21,820
yeah so channels as you pointed out

990
00:38:22,019 --> 00:38:23,560
can't really be used just within a

991
00:38:23,760 --> 00:38:24,820
single goroutine it doesn't really make

992
00:38:25,019 --> 00:38:27,070
sense because in order to send or in

993
00:38:27,269 --> 00:38:28,690
order to receive there has to be another

994
00:38:28,889 --> 00:38:30,580
go routine doing the opposite action at

995
00:38:30,780 --> 00:38:32,500
the same time so if there isn't you're

996
00:38:32,699 --> 00:38:33,880
just gonna block forever and then that

997
00:38:34,079 --> 00:38:35,680
chant but thread will no longer do any

998
00:38:35,880 --> 00:38:44,200
useful work yeah sans wait for receives

999
00:38:44,400 --> 00:38:45,550
receives wait for signs and it happens

1000
00:38:45,750 --> 00:38:46,870
synchronously once there's both the

1001
00:38:47,070 --> 00:38:52,810
sender and receiver present what I

1002
00:38:53,010 --> 00:38:54,370
talked about so far is unbuffered

1003
00:38:54,570 --> 00:38:56,080
channels I was going to avoid talking

1004
00:38:56,280 --> 00:38:57,430
about buffered channels because there

1005
00:38:57,630 --> 00:38:58,420
are very few problems that they're

1006
00:38:58,619 --> 00:39:00,400
actually useful for solving so buffered

1007
00:39:00,599 --> 00:39:04,480
channels can take in a capacity and then

1008
00:39:04,679 --> 00:39:07,150
you can think of it as it's just switch

1009
00:39:07,349 --> 00:39:09,670
this to so here's a buffered channel

1010
00:39:09,869 --> 00:39:11,650
with a capacity of one this program does

1011
00:39:11,849 --> 00:39:14,430
terminate because buffered channels are

1012
00:39:14,630 --> 00:39:16,539
like they have some internal storage

1013
00:39:16,739 --> 00:39:18,490
space and until that space fills up

1014
00:39:18,690 --> 00:39:20,320
sends are non blocking because they can

1015
00:39:20,519 --> 00:39:21,550
just put that data in the internal

1016
00:39:21,750 --> 00:39:23,500
storage space but once the channel does

1017
00:39:23,699 --> 00:39:25,990
fill up then it does behave like a nun

1018
00:39:26,190 --> 00:39:27,850
buffer channel in the sense that further

1019
00:39:28,050 --> 00:39:29,800
sends will block until there's a receive

1020
00:39:30,000 --> 00:39:34,120
to make space in the channel but I think

1021
00:39:34,320 --> 00:39:35,560
at a high level we should avoid buffered

1022
00:39:35,760 --> 00:39:36,820
channels because they basically don't

1023
00:39:37,019 --> 00:39:39,550
solve any problems and another path and

1024
00:39:39,750 --> 00:39:40,450
other things should be thinking about is

1025
00:39:40,650 --> 00:39:41,380
whenever you to make up arbitrary

1026
00:39:41,579 --> 00:39:43,060
numbers like this one here to make your

1027
00:39:43,260 --> 00:39:44,080
code work you're probably doing

1028
00:39:44,280 --> 00:39:48,019
something wrong yeah

1029
00:40:00,509 --> 00:40:02,359
so I think this is a question about

1030
00:40:02,559 --> 00:40:03,829
terminology like what exactly does

1031
00:40:04,028 --> 00:40:05,119
deadlock mean into this count as a

1032
00:40:05,318 --> 00:40:06,500
deadlock like yes this counts as a

1033
00:40:06,699 --> 00:40:07,909
deadlock like no useful progress will be

1034
00:40:08,108 --> 00:40:10,099
made here like this these threads are

1035
00:40:10,298 --> 00:40:12,220
just stuck forever

1036
00:40:12,420 --> 00:40:16,639
any other questions so what our channel

1037
00:40:16,838 --> 00:40:18,440
is useful for I think channels are

1038
00:40:18,639 --> 00:40:20,000
useful for a small set of things like

1039
00:40:20,199 --> 00:40:22,909
for example I think for producer

1040
00:40:23,108 --> 00:40:25,129
consumer queues sort of situations like

1041
00:40:25,329 --> 00:40:26,690
here I have a program that makes a

1042
00:40:26,889 --> 00:40:28,068
channel and this spawns a bunch of

1043
00:40:28,268 --> 00:40:29,450
goroutines that are going to be doing

1044
00:40:29,650 --> 00:40:30,859
some work like say they're competing

1045
00:40:31,059 --> 00:40:33,109
some result in producing some data and I

1046
00:40:33,309 --> 00:40:34,519
have a bunch of these go routines

1047
00:40:34,719 --> 00:40:36,048
running in parallel and I want to

1048
00:40:36,248 --> 00:40:37,789
collect all that data as it comes in and

1049
00:40:37,989 --> 00:40:38,599
do something with it

1050
00:40:38,798 --> 00:40:40,369
so this do work thing just like waits

1051
00:40:40,568 --> 00:40:41,960
for a bit and produces a random number

1052
00:40:42,159 --> 00:40:43,639
and in the main goroutine I'm going to

1053
00:40:43,838 --> 00:40:45,500
continuously receive on this channel and

1054
00:40:45,699 --> 00:40:47,568
print it out like this is a great use of

1055
00:40:47,768 --> 00:40:50,510
channels another good use of channels is

1056
00:40:50,710 --> 00:40:52,430
to achieve something similar to what

1057
00:40:52,630 --> 00:40:55,879
wait groups do so rather than use a wait

1058
00:40:56,079 --> 00:40:57,318
group suppose I want to spawn a bunch of

1059
00:40:57,518 --> 00:40:58,730
threads and wait till they're all done

1060
00:40:58,929 --> 00:41:00,950
doing something one way to do that is to

1061
00:41:01,150 --> 00:41:03,079
create a channel and then I spawn a

1062
00:41:03,278 --> 00:41:04,190
bunch of threads and know how many

1063
00:41:04,389 --> 00:41:06,349
threads I've spawned so five goroutines

1064
00:41:06,548 --> 00:41:07,609
created here they're going to do

1065
00:41:07,809 --> 00:41:09,169
something and then send on this channel

1066
00:41:09,369 --> 00:41:11,419
when they're done and then in the main

1067
00:41:11,619 --> 00:41:13,609
go routine I can just receive from that

1068
00:41:13,809 --> 00:41:15,200
channel the same number of times and

1069
00:41:15,400 --> 00:41:19,619
this has the same effect as a wait group

1070
00:41:22,840 --> 00:41:31,130
so question so what exactly is the

1071
00:41:31,329 --> 00:41:33,659
question

1072
00:41:33,840 --> 00:41:36,939
[Music]

1073
00:41:37,510 --> 00:41:39,780
so the question is here could you use a

1074
00:41:39,980 --> 00:41:41,430
buffered channel with a capacity of five

1075
00:41:41,630 --> 00:41:42,930
because you're waiting for five receives

1076
00:41:43,130 --> 00:41:45,269
I think in this particular case yes that

1077
00:41:45,469 --> 00:41:47,370
would have the equivalent effect but I

1078
00:41:47,570 --> 00:41:49,080
think there's not really a reason to do

1079
00:41:49,280 --> 00:41:49,820
that

1080
00:41:50,019 --> 00:41:52,019
and I think at a high level in your code

1081
00:41:52,219 --> 00:41:53,460
you should avoid buffer channels and

1082
00:41:53,659 --> 00:41:55,289
also maybe even channels unless you

1083
00:41:55,489 --> 00:41:56,840
think very hard about what you're doing

1084
00:41:57,039 --> 00:42:07,800
yeah so what is a weight group I think

1085
00:42:08,000 --> 00:42:09,300
we covered this in a previous lecture

1086
00:42:09,500 --> 00:42:11,630
and I talked about it very briefly today

1087
00:42:11,829 --> 00:42:14,789
but I do have an example of weight

1088
00:42:14,989 --> 00:42:18,750
groups so a weight group is a yet

1089
00:42:18,949 --> 00:42:19,950
another synchronization primitive

1090
00:42:20,150 --> 00:42:21,480
provided by go in the sync package and

1091
00:42:21,679 --> 00:42:24,150
it kind of does what his name advertises

1092
00:42:24,349 --> 00:42:25,500
like it lets you wait for a certain

1093
00:42:25,699 --> 00:42:27,060
number of threads to be done the way it

1094
00:42:27,260 --> 00:42:28,920
works is you call weight group dot add

1095
00:42:29,119 --> 00:42:31,530
and that basically increments some

1096
00:42:31,730 --> 00:42:33,269
internal counter and then when you call

1097
00:42:33,469 --> 00:42:35,490
weight group dot weight it waits till

1098
00:42:35,690 --> 00:42:38,160
done has been called as many times as ad

1099
00:42:38,360 --> 00:42:42,330
was called so this code is basically the

1100
00:42:42,530 --> 00:42:43,740
same as the code I just showed you that

1101
00:42:43,940 --> 00:42:45,660
was using a channel except this is using

1102
00:42:45,860 --> 00:42:46,920
weight group they have the exact same

1103
00:42:47,119 --> 00:42:52,389
effect you can use either one yeah

1104
00:43:01,940 --> 00:43:04,510
so the question here is about race

1105
00:43:04,710 --> 00:43:06,539
conditions I think like what happens if

1106
00:43:06,739 --> 00:43:09,580
this ad doesn't happen fast enough

1107
00:43:09,780 --> 00:43:11,260
before this weight happens or something

1108
00:43:11,460 --> 00:43:13,600
like that well so here notice that the

1109
00:43:13,800 --> 00:43:15,550
pattern here is we call weight group

1110
00:43:15,750 --> 00:43:18,910
data outside of this go routine and it's

1111
00:43:19,110 --> 00:43:21,039
called before spawning this go routine

1112
00:43:21,239 --> 00:43:23,860
so this happens first this happens next

1113
00:43:24,059 --> 00:43:26,710
and so we'll never have the situation

1114
00:43:26,909 --> 00:43:29,710
we're done happens after this ad happens

1115
00:43:29,909 --> 00:43:51,250
for this particular routine how's this

1116
00:43:51,449 --> 00:43:54,039
implemented by the compiler and I will

1117
00:43:54,239 --> 00:43:55,300
not talk about that now but talk to me

1118
00:43:55,500 --> 00:43:57,640
after class or in office hours but I

1119
00:43:57,840 --> 00:43:59,019
think for the purposes class like you

1120
00:43:59,219 --> 00:44:00,370
need to know the API for these things

1121
00:44:00,570 --> 00:44:04,450
not the implementation all right and so

1122
00:44:04,650 --> 00:44:07,510
I think that's basically all I have on

1123
00:44:07,710 --> 00:44:12,130
go concurrency primitives so one final

1124
00:44:12,329 --> 00:44:13,720
thought is on channels like channels are

1125
00:44:13,920 --> 00:44:15,190
good for a specific set of things like I

1126
00:44:15,389 --> 00:44:16,330
just showed you the producer consumer

1127
00:44:16,530 --> 00:44:17,710
queue or like implementing something

1128
00:44:17,909 --> 00:44:19,150
like weight groups but I think when you

1129
00:44:19,349 --> 00:44:21,220
try to do fancier things with them like

1130
00:44:21,420 --> 00:44:24,130
if you want to say like kick another go

1131
00:44:24,329 --> 00:44:25,420
routine that may or may not be waiting

1132
00:44:25,619 --> 00:44:27,190
for you to be like woken up that's a

1133
00:44:27,389 --> 00:44:28,450
kind of tricky thing to do with channels

1134
00:44:28,650 --> 00:44:29,980
there's also a bunch of other ways to

1135
00:44:30,179 --> 00:44:31,360
shoot yourself in the foot with them I'm

1136
00:44:31,559 --> 00:44:32,890
going to avoid showing you examples of

1137
00:44:33,090 --> 00:44:34,990
bad code with channels just because it's

1138
00:44:35,190 --> 00:44:37,660
not useful to see but I personally avoid

1139
00:44:37,860 --> 00:44:39,130
using channels for the most part and

1140
00:44:39,329 --> 00:44:41,860
just use shared memory and mutexes and

1141
00:44:42,059 --> 00:44:43,180
condition variables and set and I

1142
00:44:43,380 --> 00:44:44,500
personally find those much easier to

1143
00:44:44,699 --> 00:44:47,800
reason about so feel free to use

1144
00:44:48,000 --> 00:44:49,390
channels for when they make sense but if

1145
00:44:49,590 --> 00:44:50,830
anything looks especially awkward to do

1146
00:44:51,030 --> 00:44:52,480
with channels like just use mutexes and

1147
00:44:52,679 --> 00:44:53,500
condition variables and they're probably

1148
00:44:53,699 --> 00:44:56,929
a better tool yeah

1149
00:45:02,599 --> 00:45:04,599
so the question is with the difference

1150
00:45:04,798 --> 00:45:05,889
between this producer-consumer pattern

1151
00:45:06,088 --> 00:45:07,568
here in a thread-safe FIFO I think

1152
00:45:07,768 --> 00:45:09,460
they're kind of equivalent like you

1153
00:45:09,659 --> 00:45:11,139
could do this with the thread-safe FIFO

1154
00:45:11,338 --> 00:45:14,039
and it like that is basically what a

1155
00:45:14,239 --> 00:45:35,349
like buffered channel is roughly if

1156
00:45:35,548 --> 00:45:36,940
you're in queueing things in Indy

1157
00:45:37,139 --> 00:45:38,440
queueing things like if you want this

1158
00:45:38,639 --> 00:45:40,089
line to finish and have this thread go

1159
00:45:40,289 --> 00:45:41,530
do something else while that data sits

1160
00:45:41,730 --> 00:45:43,629
there in a queue rather than this girl

1161
00:45:43,829 --> 00:45:45,430
routine waiting to send it then a

1162
00:45:45,630 --> 00:45:48,760
buffered channel might make sense but I

1163
00:45:48,960 --> 00:45:49,930
think at least in the lives you will not

1164
00:45:50,130 --> 00:45:53,649
have a pattern like that all right so

1165
00:45:53,849 --> 00:45:56,349
next Fabian's going to talk about more

1166
00:45:56,548 --> 00:46:05,630
rapidly related stuff do you need this

1167
00:46:13,630 --> 00:46:16,439
all right can you all hear me is this

1168
00:46:16,639 --> 00:46:24,509
working yeah all right so yeah basically

1169
00:46:24,708 --> 00:46:27,209
I'm going to show you two bugs that we

1170
00:46:27,409 --> 00:46:29,249
commonly see in people's raft

1171
00:46:29,449 --> 00:46:30,629
implementations there's a lot of bugs

1172
00:46:30,829 --> 00:46:32,699
that are pretty common but I'm just

1173
00:46:32,898 --> 00:46:35,789
going to focus on two of them so in this

1174
00:46:35,989 --> 00:46:38,669
first example we sort of have a start of

1175
00:46:38,869 --> 00:46:41,068
a raft implementation for that's sort of

1176
00:46:41,268 --> 00:46:42,869
like what you might see for to a just

1177
00:46:43,068 --> 00:46:43,769
the beginnings of one

1178
00:46:43,969 --> 00:46:47,818
so in our raft state we have primarily

1179
00:46:48,018 --> 00:46:50,039
the current status of the raft pier

1180
00:46:50,239 --> 00:46:52,019
either follower candidate or leader and

1181
00:46:52,219 --> 00:46:53,999
we have these two state variables that

1182
00:46:54,199 --> 00:46:55,318
were keeping track of the current term

1183
00:46:55,518 --> 00:46:57,979
and who we voted for in the current term

1184
00:46:58,179 --> 00:47:00,959
so I'm I want us to focus though on

1185
00:47:01,159 --> 00:47:03,899
these two functions attempt election and

1186
00:47:04,099 --> 00:47:07,499
call request vote so in a temptin we're

1187
00:47:07,699 --> 00:47:10,489
just going to set our state to candidate

1188
00:47:10,688 --> 00:47:13,139
increment our current term vote for

1189
00:47:13,338 --> 00:47:14,909
ourselves and then start sending out

1190
00:47:15,108 --> 00:47:17,249
request votes to all of our raft peers

1191
00:47:17,449 --> 00:47:19,798
and so this is similar to some of the

1192
00:47:19,998 --> 00:47:23,519
patterns that Anish showed where we're

1193
00:47:23,719 --> 00:47:25,019
going to loop through our peers and then

1194
00:47:25,219 --> 00:47:28,139
for each one in a go routines separately

1195
00:47:28,338 --> 00:47:30,239
call this call request vote function in

1196
00:47:30,438 --> 00:47:32,399
order to actually send an RPC to that

1197
00:47:32,599 --> 00:47:33,318
peer

1198
00:47:33,518 --> 00:47:36,629
alright so in call request vote we're

1199
00:47:36,829 --> 00:47:40,079
going to acquire the lock prepare

1200
00:47:40,278 --> 00:47:42,449
arguments for our request Ville RPC call

1201
00:47:42,648 --> 00:47:44,489
based on by setting it to the current

1202
00:47:44,688 --> 00:47:47,489
term and then actually perform the RPC

1203
00:47:47,688 --> 00:47:49,769
call over here and finally based on the

1204
00:47:49,969 --> 00:47:53,879
response we will reply back to this this

1205
00:47:54,079 --> 00:47:55,589
attempt election function and the

1206
00:47:55,789 --> 00:47:56,729
attempt election function eventually

1207
00:47:56,929 --> 00:47:58,499
should tally up the votes to see if it

1208
00:47:58,699 --> 00:47:59,939
got a majority of the votes and can

1209
00:48:00,139 --> 00:48:04,019
become leader so what happens when we

1210
00:48:04,219 --> 00:48:06,239
run this code so in theory what we might

1211
00:48:06,438 --> 00:48:08,639
expect to happen is four so there's

1212
00:48:08,838 --> 00:48:09,899
going to be some code that's going to

1213
00:48:10,099 --> 00:48:11,579
spawn a few graph spears and actually

1214
00:48:11,778 --> 00:48:13,759
try to attempt elections on them and

1215
00:48:13,958 --> 00:48:17,909
what should happen are we just start

1216
00:48:18,108 --> 00:48:19,409
collecting votes from other peers and

1217
00:48:19,608 --> 00:48:20,939
then we're not actually going to tally

1218
00:48:21,139 --> 00:48:21,450
them up

1219
00:48:21,650 --> 00:48:24,059
but hopefully nothing weird goes wrong

1220
00:48:24,259 --> 00:48:25,829
but actually something is going to go

1221
00:48:26,028 --> 00:48:29,099
wrong here and we actually activated

1222
00:48:29,298 --> 00:48:31,379
goes deadlock detector and somehow we

1223
00:48:31,579 --> 00:48:33,659
ran into a deadlock so let's see what

1224
00:48:33,858 --> 00:48:37,200
happened for now let's focus on what's

1225
00:48:37,400 --> 00:48:40,798
going on with the server zero so server

1226
00:48:40,998 --> 00:48:42,568
zero it says it starts attempting an

1227
00:48:42,768 --> 00:48:45,269
election at term one that's just

1228
00:48:45,469 --> 00:48:46,829
starting the attempt election function

1229
00:48:47,028 --> 00:48:48,839
it will acquire the lock set some of the

1230
00:48:49,039 --> 00:48:50,548
set some stuff up for performing the

1231
00:48:50,748 --> 00:48:56,849
election and then unlock then it's going

1232
00:48:57,048 --> 00:48:59,399
to send out a request vote RPC - server

1233
00:48:59,599 --> 00:49:03,568
- it finishes processing that request

1234
00:49:03,768 --> 00:49:04,950
vote RPC over here so we're just

1235
00:49:05,150 --> 00:49:06,809
printing right before and after we

1236
00:49:07,009 --> 00:49:09,599
actually send out the RPC and then it

1237
00:49:09,798 --> 00:49:11,730
sends out a request vote RPC - server

1238
00:49:11,929 --> 00:49:13,889
one but after that it never we never

1239
00:49:14,088 --> 00:49:15,480
actually see it finish sending the

1240
00:49:15,679 --> 00:49:18,649
request vote RPC so it's actually stuck

1241
00:49:18,849 --> 00:49:21,480
in this function call waiting for the

1242
00:49:21,679 --> 00:49:24,119
RPC response from server 1 all right now

1243
00:49:24,318 --> 00:49:25,649
let's look at what's everyone's doing so

1244
00:49:25,849 --> 00:49:27,720
it's it's pretty much the same thing it

1245
00:49:27,920 --> 00:49:29,220
sends a request vote I received a server

1246
00:49:29,420 --> 00:49:32,669
to that that succeeds it finishes

1247
00:49:32,869 --> 00:49:34,230
processing that request vote the

1248
00:49:34,429 --> 00:49:36,149
response from server 2 then it sends

1249
00:49:36,349 --> 00:49:39,480
this RPC to zero and now what's actually

1250
00:49:39,679 --> 00:49:41,789
happening is 0 & 1 are sort of waiting

1251
00:49:41,989 --> 00:49:43,500
for the RPC responses from each other

1252
00:49:43,699 --> 00:49:45,359
they both sent out an RPC call but not

1253
00:49:45,559 --> 00:49:48,568
yet got the response yet and that's

1254
00:49:48,768 --> 00:49:50,068
actually sort of the cause of our

1255
00:49:50,268 --> 00:49:53,430
deadlock so really what's the reason

1256
00:49:53,630 --> 00:49:54,690
that we're dead locking is because we're

1257
00:49:54,889 --> 00:49:57,530
holding this lock through our RPC calls

1258
00:49:57,730 --> 00:49:59,609
over here in the core requests vote

1259
00:49:59,809 --> 00:50:02,190
function we acquire our mutex associated

1260
00:50:02,389 --> 00:50:04,798
with our raft peer and we only unlock at

1261
00:50:04,998 --> 00:50:06,298
the end of this function so throughout

1262
00:50:06,498 --> 00:50:07,619
this entire function we're holding the

1263
00:50:07,818 --> 00:50:10,710
lock including when we try to contact

1264
00:50:10,909 --> 00:50:17,039
our peer to get the vote and later when

1265
00:50:17,239 --> 00:50:22,379
we handle this request vote RPC we

1266
00:50:22,579 --> 00:50:24,298
actually only see it at the beginning of

1267
00:50:24,498 --> 00:50:26,399
this function in the handler we're also

1268
00:50:26,599 --> 00:50:27,960
trying to acquire the lock but we never

1269
00:50:28,159 --> 00:50:29,430
actually succeed in acquiring the lock

1270
00:50:29,630 --> 00:50:31,379
so just to make this a little bit more

1271
00:50:31,579 --> 00:50:34,079
clear the the sort of order of

1272
00:50:34,278 --> 00:50:35,220
operations

1273
00:50:35,420 --> 00:50:39,500
is happening is in call request vote

1274
00:50:39,699 --> 00:50:42,510
server zero is first going to acquire

1275
00:50:42,710 --> 00:50:47,310
the lock and send an RPC call to server

1276
00:50:47,510 --> 00:50:50,840
one and then simultaneously and

1277
00:50:51,039 --> 00:50:52,889
separately server one is going to do the

1278
00:50:53,088 --> 00:50:54,119
same thing it's going to enter its call

1279
00:50:54,318 --> 00:50:55,889
request vote function acquire the lock

1280
00:50:56,088 --> 00:51:01,609
and send this RPC call to server zero

1281
00:51:01,809 --> 00:51:05,010
now in server zeros handler and server

1282
00:51:05,210 --> 00:51:07,019
ones handler they're trying to acquire

1283
00:51:07,219 --> 00:51:10,500
the lock but they can't because they

1284
00:51:10,699 --> 00:51:11,789
already are acquiring the lock and

1285
00:51:11,989 --> 00:51:13,019
trying to send the RPC call to each

1286
00:51:13,219 --> 00:51:15,119
other and that that's actually what's

1287
00:51:15,318 --> 00:51:18,720
leading to the deadlock situation so to

1288
00:51:18,920 --> 00:51:21,240
solve this basically we want you to not

1289
00:51:21,440 --> 00:51:23,280
hold locks through RPC calls and that's

1290
00:51:23,480 --> 00:51:27,510
the solution to this problem in fact we

1291
00:51:27,710 --> 00:51:29,220
don't need the lock here at all instead

1292
00:51:29,420 --> 00:51:32,010
of trying to read the current term when

1293
00:51:32,210 --> 00:51:34,669
we enter this call request vote function

1294
00:51:34,869 --> 00:51:38,119
we can pass this as an argument here

1295
00:51:38,318 --> 00:51:42,570
save the term when we had acquired the

1296
00:51:42,769 --> 00:51:44,519
lock earlier in this attempt election

1297
00:51:44,719 --> 00:51:47,250
and just passed this as a as a variable

1298
00:51:47,449 --> 00:51:48,690
to call request vote so that actually

1299
00:51:48,889 --> 00:51:51,750
removes the need to acquire the lock at

1300
00:51:51,949 --> 00:51:55,530
all in call request vote alternatively

1301
00:51:55,730 --> 00:51:57,810
we could lock while we're preparing the

1302
00:51:58,010 --> 00:51:59,369
arguments and then unlock before

1303
00:51:59,568 --> 00:52:01,649
actually performing the call and then if

1304
00:52:01,849 --> 00:52:04,050
we need to to process the reply we could

1305
00:52:04,250 --> 00:52:05,639
lock again afterwards so it's just make

1306
00:52:05,838 --> 00:52:07,859
sure to unlock before making it

1307
00:52:08,059 --> 00:52:10,320
obviously call and then if you need to

1308
00:52:10,519 --> 00:52:14,550
you can acquire the lock again so now if

1309
00:52:14,750 --> 00:52:20,129
I save this then so it's still

1310
00:52:20,329 --> 00:52:21,359
activating the deadlock detector but

1311
00:52:21,559 --> 00:52:22,919
that's actually just because we're not

1312
00:52:23,119 --> 00:52:25,289
doing anything at the end but now it's

1313
00:52:25,489 --> 00:52:25,950
actually working

1314
00:52:26,150 --> 00:52:28,109
we finished sending the request votes on

1315
00:52:28,309 --> 00:52:29,399
both sides and all the operations that

1316
00:52:29,599 --> 00:52:32,490
we wanted to complete are complete all

1317
00:52:32,690 --> 00:52:37,150
right any questions about this example

1318
00:52:42,179 --> 00:52:45,369
yeah so not it's sort of so you might

1319
00:52:45,568 --> 00:52:47,379
need to use locks when you are preparing

1320
00:52:47,579 --> 00:52:48,940
the arguments or processing the response

1321
00:52:49,139 --> 00:52:50,430
but yeah you shouldn't hold a lock

1322
00:52:50,630 --> 00:52:52,690
through the RPC call while you're

1323
00:52:52,889 --> 00:52:54,220
waiting for the other peer to respond

1324
00:52:54,420 --> 00:52:56,289
and there's actually another reason to

1325
00:52:56,489 --> 00:52:57,970
that in addition to deadlock the other

1326
00:52:58,170 --> 00:53:00,369
problem is that in some tests we're

1327
00:53:00,568 --> 00:53:03,280
going to sort of have this unreliable

1328
00:53:03,480 --> 00:53:04,930
network that could delay some of your

1329
00:53:05,130 --> 00:53:07,899
RPC messages potentially by like 50

1330
00:53:08,099 --> 00:53:10,859
milliseconds and in that case if you

1331
00:53:11,059 --> 00:53:13,750
hold the lock through an RPC call then

1332
00:53:13,949 --> 00:53:15,399
any other operation that you try to do

1333
00:53:15,599 --> 00:53:17,530
during that 50 milliseconds won't be

1334
00:53:17,730 --> 00:53:19,210
able to complete until that RPC response

1335
00:53:19,409 --> 00:53:22,030
is received so that that's another issue

1336
00:53:22,230 --> 00:53:23,470
that you might run into if you hold the

1337
00:53:23,670 --> 00:53:25,570
long so it's both to make things more

1338
00:53:25,769 --> 00:53:27,220
efficient and to avoid these potential

1339
00:53:27,420 --> 00:53:30,380
deadlock situations

1340
00:53:37,400 --> 00:53:41,789
all right so just one more example this

1341
00:53:41,989 --> 00:53:45,090
is again using a similar draft

1342
00:53:45,289 --> 00:53:46,800
implementation so again in our raft

1343
00:53:47,000 --> 00:53:48,120
state we're going to be keeping track of

1344
00:53:48,320 --> 00:53:49,530
whether a fuller candidate leader and

1345
00:53:49,730 --> 00:53:52,620
then also these two state variables in

1346
00:53:52,820 --> 00:53:54,480
this example I want you to focus on this

1347
00:53:54,679 --> 00:53:57,390
attempt election function so now we've

1348
00:53:57,590 --> 00:53:59,160
first implemented the change that I just

1349
00:53:59,360 --> 00:54:01,800
showed you to store the term here and

1350
00:54:02,000 --> 00:54:04,350
pass it as a variable to our function

1351
00:54:04,550 --> 00:54:06,600
that collects the request votes but

1352
00:54:06,800 --> 00:54:07,710
additionally we've implemented some

1353
00:54:07,909 --> 00:54:10,650
functionality to add up the votes so

1354
00:54:10,849 --> 00:54:12,750
what we'll do is we'll create a local

1355
00:54:12,949 --> 00:54:16,050
variable to count the votes and whenever

1356
00:54:16,250 --> 00:54:18,300
we get a vote if the vote was not

1357
00:54:18,500 --> 00:54:18,840
granted

1358
00:54:19,039 --> 00:54:20,640
we'll return immediately from this go

1359
00:54:20,840 --> 00:54:22,620
routine where we're processing the boat

1360
00:54:22,820 --> 00:54:25,740
otherwise we'll acquire the lock before

1361
00:54:25,940 --> 00:54:28,320
editing this shared local variable to

1362
00:54:28,519 --> 00:54:30,900
count up the votes and then if we did

1363
00:54:31,099 --> 00:54:32,280
not get a majority of the votes will

1364
00:54:32,480 --> 00:54:34,590
return immediately otherwise we'll make

1365
00:54:34,789 --> 00:54:38,789
ourselves the leader so as with the

1366
00:54:38,989 --> 00:54:42,240
other example I mean initially if you

1367
00:54:42,440 --> 00:54:43,680
look at this if I look at this like it

1368
00:54:43,880 --> 00:54:45,600
seems reasonable but let's see if

1369
00:54:45,800 --> 00:54:50,340
anything can go wrong all right so this

1370
00:54:50,539 --> 00:54:53,160
is the log output from one run and one

1371
00:54:53,360 --> 00:54:54,660
thing you might notice is that we've

1372
00:54:54,860 --> 00:54:57,090
actually elected two leaders on the same

1373
00:54:57,289 --> 00:54:59,460
term so server zero

1374
00:54:59,659 --> 00:55:03,420
it was elected made itself a leader on

1375
00:55:03,619 --> 00:55:06,660
term two and server one did as well it's

1376
00:55:06,860 --> 00:55:08,280
okay to have a leader elected on

1377
00:55:08,480 --> 00:55:09,539
different terms but here where we have

1378
00:55:09,739 --> 00:55:10,890
one on the same term that that should

1379
00:55:11,090 --> 00:55:13,050
never happen alright so how did this

1380
00:55:13,250 --> 00:55:15,750
actually come up so let's start from the

1381
00:55:15,949 --> 00:55:18,510
top so at the beginning server zero

1382
00:55:18,710 --> 00:55:20,010
actually attempted an election at term

1383
00:55:20,210 --> 00:55:23,400
one not turn two and it got its votes

1384
00:55:23,599 --> 00:55:26,820
from both of the other peers but for

1385
00:55:27,019 --> 00:55:28,200
whatever reason perhaps because those

1386
00:55:28,400 --> 00:55:30,480
reply messages from those peers were

1387
00:55:30,679 --> 00:55:34,460
delayed it didn't actually process its

1388
00:55:34,659 --> 00:55:37,950
process those votes until later and in

1389
00:55:38,150 --> 00:55:40,200
between receiving it like in between

1390
00:55:40,400 --> 00:55:42,630
attempting the election and finishing

1391
00:55:42,829 --> 00:55:45,030
the election server one also decided to

1392
00:55:45,230 --> 00:55:46,820
attempt an election perhaps because

1393
00:55:47,019 --> 00:55:49,680
because of server zero was delayed so

1394
00:55:49,880 --> 00:55:50,610
much server one might

1395
00:55:50,809 --> 00:55:52,530
actually ran into the election timeout

1396
00:55:52,730 --> 00:55:54,330
and then started its own election and it

1397
00:55:54,530 --> 00:55:57,510
started it on term 2 because it couldn't

1398
00:55:57,710 --> 00:55:58,890
have been termed 1 because it already

1399
00:55:59,090 --> 00:56:01,620
voted for server 0 on on term 1 over

1400
00:56:01,820 --> 00:56:03,350
here

1401
00:56:03,550 --> 00:56:07,980
okay so then server 1 sends out its own

1402
00:56:08,179 --> 00:56:11,190
request votes 2 servers 2 and 0 at term

1403
00:56:11,389 --> 00:56:13,920
2 and now we see that server two votes

1404
00:56:14,119 --> 00:56:15,900
for server 1 that's fine but server 0

1405
00:56:16,099 --> 00:56:17,850
also votes for server 1 this is actually

1406
00:56:18,050 --> 00:56:21,420
also fine because server one is asking

1407
00:56:21,619 --> 00:56:25,650
server 0 for a vote on a higher term and

1408
00:56:25,849 --> 00:56:28,350
so what server 0 should do is if you

1409
00:56:28,550 --> 00:56:33,150
remember from the spec it should set its

1410
00:56:33,349 --> 00:56:35,130
current term to that term in the request

1411
00:56:35,329 --> 00:56:37,200
for RPC message to term 2 and also

1412
00:56:37,400 --> 00:56:39,180
revert itself to a follower instead of a

1413
00:56:39,380 --> 00:56:42,900
candidate alright finally so the real

1414
00:56:43,099 --> 00:56:44,340
problem is that on this line where

1415
00:56:44,539 --> 00:56:47,250
server 0 although it really got enough

1416
00:56:47,449 --> 00:56:49,140
votes on term 1 it made itself a leader

1417
00:56:49,340 --> 00:56:53,039
on term - so the reason so one

1418
00:56:53,239 --> 00:56:55,050
explanation for why this is happening is

1419
00:56:55,250 --> 00:56:57,630
because in between where we set up the

1420
00:56:57,829 --> 00:56:59,820
election our attempt for the election

1421
00:57:00,019 --> 00:57:02,750
and where we actually process the votes

1422
00:57:02,949 --> 00:57:05,310
some other things are happening input in

1423
00:57:05,510 --> 00:57:07,019
this case we're actually voting for

1424
00:57:07,219 --> 00:57:10,800
someone else in between and so we're no

1425
00:57:11,000 --> 00:57:12,480
longer on term 1 where we thought we

1426
00:57:12,679 --> 00:57:14,430
started the election we're now on term 2

1427
00:57:14,630 --> 00:57:17,150
and so we just need a double check that

1428
00:57:17,349 --> 00:57:19,410
because we don't have the lock while

1429
00:57:19,610 --> 00:57:21,150
we're performing the RPC calls which is

1430
00:57:21,349 --> 00:57:23,100
important for its own reasons now some

1431
00:57:23,300 --> 00:57:24,539
things might have changed and we need to

1432
00:57:24,739 --> 00:57:26,630
double check that what we assume is true

1433
00:57:26,829 --> 00:57:28,680
when we're setting ourselves to the

1434
00:57:28,880 --> 00:57:32,190
leader is still true so one way to solve

1435
00:57:32,389 --> 00:57:33,810
this that there's a few different ways

1436
00:57:34,010 --> 00:57:35,010
like to solve this like you could

1437
00:57:35,210 --> 00:57:36,630
imagine not voting for others while

1438
00:57:36,829 --> 00:57:37,950
we're in the middle of attempting an

1439
00:57:38,150 --> 00:57:39,750
election but in this case the simplest

1440
00:57:39,949 --> 00:57:42,780
way to solve this at least in this

1441
00:57:42,980 --> 00:57:44,970
implementation is to just double check

1442
00:57:45,170 --> 00:57:46,530
that we're still on the same term and

1443
00:57:46,730 --> 00:57:47,820
we're still a candidate we haven't

1444
00:57:48,019 --> 00:57:50,100
reverted to a follower so actually one

1445
00:57:50,300 --> 00:57:52,050
thing I want to show you is if we do

1446
00:57:52,250 --> 00:57:57,750
print out our state over here then we do

1447
00:57:57,949 --> 00:58:00,330
see that server 0 became a follower but

1448
00:58:00,530 --> 00:58:02,130
it's still setting itself to a leader on

1449
00:58:02,329 --> 00:58:04,050
this line

1450
00:58:04,250 --> 00:58:06,840
so yeah we can just check for that if

1451
00:58:07,039 --> 00:58:10,440
we're not a candidate or the current

1452
00:58:10,639 --> 00:58:12,269
term doesn't match the term which we

1453
00:58:12,469 --> 00:58:14,460
started the election then let's just

1454
00:58:14,659 --> 00:58:18,300
quit and if we do that then

1455
00:58:18,500 --> 00:58:20,400
so everyone becomes a leader and we

1456
00:58:20,599 --> 00:58:21,840
never cease over zero become leader so

1457
00:58:22,039 --> 00:58:27,039
the problem solved any question yeah

1458
00:58:28,630 --> 00:58:30,630
yeah I think I think that would I

1459
00:58:30,829 --> 00:58:35,039
because we would not if the term is

1460
00:58:35,239 --> 00:58:38,789
higher now than actually no it would it

1461
00:58:38,989 --> 00:58:40,110
might not be sufficient because we might

1462
00:58:40,309 --> 00:58:42,600
have attempted another election it

1463
00:58:42,800 --> 00:58:44,580
depends on your implementation but it's

1464
00:58:44,780 --> 00:58:47,250
possible that you could have attempted

1465
00:58:47,449 --> 00:58:49,430
another election on a higher term

1466
00:58:49,630 --> 00:58:51,360
afterwards all we know that's the same

1467
00:58:51,559 --> 00:58:52,710
thing right yeah it would not be

1468
00:58:52,909 --> 00:58:54,480
sufficient to only check the state but I

1469
00:58:54,679 --> 00:58:56,370
think you're right if you only check the

1470
00:58:56,570 --> 00:59:00,960
term then it is sufficient all right any

1471
00:59:01,159 --> 00:59:09,690
other questions all right so yeah that's

1472
00:59:09,889 --> 00:59:11,400
it for this part she's going to show you

1473
00:59:11,599 --> 00:59:14,010
some more examples of actually debugging

1474
00:59:14,210 --> 00:59:18,280
some of these draft implementations

1475
00:59:34,039 --> 00:59:40,220
hi can you all hear me yeah

1476
00:59:52,869 --> 00:59:56,289
is it not

1477
01:00:06,800 --> 01:00:14,740
okay so in my section I'm gonna walk you

1478
01:00:14,940 --> 01:00:17,560
through how I would be but if you have

1479
01:00:17,760 --> 01:00:20,110
like a bug in your rough implementation

1480
01:00:20,309 --> 01:00:23,950
so I prepare a couple of baccara good

1481
01:00:24,150 --> 01:00:29,830
and I just try to walk you through it so

1482
01:00:30,030 --> 01:00:32,850
first I'm gonna go into my face

1483
01:00:33,050 --> 01:00:40,810
Bucky implementation and if I run the

1484
01:00:41,010 --> 01:00:52,150
test here so for this one it doesn't

1485
01:00:52,349 --> 01:00:55,060
print anything it just gets started and

1486
01:00:55,260 --> 01:01:00,190
it's gonna be here forever and let's

1487
01:01:00,389 --> 01:01:02,200
assume that I have no idea why there's

1488
01:01:02,400 --> 01:01:02,920
happening

1489
01:01:03,119 --> 01:01:07,090
the first thing that I want to find out

1490
01:01:07,289 --> 01:01:12,940
is where it gets started and we we do

1491
01:01:13,139 --> 01:01:16,710
have a good tool for that which printf

1492
01:01:16,909 --> 01:01:21,130
but in the stop code if you go to

1493
01:01:21,329 --> 01:01:25,090
youtube go we have a function called the

1494
01:01:25,289 --> 01:01:28,269
printf this is just a nice wrapper

1495
01:01:28,469 --> 01:01:32,760
around the block cleaners with the

1496
01:01:32,960 --> 01:01:36,400
debugger able to enable or disable the

1497
01:01:36,599 --> 01:01:40,090
locking messages so I'm gonna enable

1498
01:01:40,289 --> 01:01:46,780
that and go back to my graph okay so

1499
01:01:46,980 --> 01:01:50,230
first of all when i when when there

1500
01:01:50,429 --> 01:01:54,600
there's something that's but happening I

1501
01:01:54,800 --> 01:02:02,340
always go check if the code actually

1502
01:02:02,539 --> 01:02:08,019
actually initialize graph server so here

1503
01:02:08,219 --> 01:02:11,179
I'll just clean

1504
01:02:20,730 --> 01:02:27,440
okay so here if I run the test again

1505
01:02:27,639 --> 01:02:31,220
then now I know that there are three

1506
01:02:31,420 --> 01:02:36,740
servers that God he initialized so this

1507
01:02:36,940 --> 01:02:42,980
files is okay but like there's nowhere

1508
01:02:43,179 --> 01:02:45,530
where the bow is happening so I'll just

1509
01:02:45,730 --> 01:02:48,379
go deeper into the hood just to find

1510
01:02:48,579 --> 01:02:50,539
where it gets stuck so now if you see

1511
01:02:50,739 --> 01:02:55,490
the code we are calling the leader a

1512
01:02:55,690 --> 01:02:58,639
tech election so I'm gonna go to that

1513
01:02:58,838 --> 01:03:05,899
function and just to make faster I'll

1514
01:03:06,099 --> 01:03:08,119
try to check if it kicks off some

1515
01:03:08,318 --> 01:03:11,099
iteration

1516
01:03:21,769 --> 01:03:25,440
that part still fine so we we try to go

1517
01:03:25,639 --> 01:03:31,140
for now here we are in the election I'll

1518
01:03:31,340 --> 01:03:36,990
see if there's so we actually send the

1519
01:03:37,190 --> 01:03:41,409
request voice to some other servers

1520
01:04:00,320 --> 01:04:02,550
now we kind of have like more idea of

1521
01:04:02,750 --> 01:04:04,470
where guests are because it's not

1522
01:04:04,670 --> 01:04:08,310
printing that some sorry that kicks off

1523
01:04:08,510 --> 01:04:11,160
the election are not sending the request

1524
01:04:11,360 --> 01:04:17,220
words so I would go back for her just to

1525
01:04:17,420 --> 01:04:21,300
see where customers like I always tried

1526
01:04:21,500 --> 01:04:27,170
here prin if if we call some function

1527
01:04:27,369 --> 01:04:29,070
aye-aye

1528
01:04:29,269 --> 01:04:31,769
I was always double shake if it actually

1529
01:04:31,969 --> 01:04:37,460
go into the function so now I'm going to

1530
01:04:37,659 --> 01:04:42,300
say that this service is at the start of

1531
01:04:42,500 --> 01:04:45,639
the election

1532
01:04:50,199 --> 01:04:56,609
and that works so now we have an idea of

1533
01:04:56,809 --> 01:05:02,629
like the box should be between here and

1534
01:05:02,829 --> 01:05:06,470
here so we are trying to minimize the

1535
01:05:06,670 --> 01:05:12,639
scope of the code that's causing the bug

1536
01:05:14,409 --> 01:05:19,058
let's say if I pin something here

1537
01:05:28,300 --> 01:05:33,760
and it does it doesn't get there so I

1538
01:05:33,960 --> 01:05:41,180
move it up let's say here still not

1539
01:05:41,380 --> 01:05:43,619
there

1540
01:05:48,539 --> 01:05:55,269
now it's there so the bug is probably in

1541
01:05:55,469 --> 01:06:01,890
this function and I just go check so

1542
01:06:02,090 --> 01:06:05,200
here the problem is that I'm trying to

1543
01:06:05,400 --> 01:06:08,400
acquire a lock where I actually do have

1544
01:06:08,599 --> 01:06:13,420
the lock so it's gonna be a day long so

1545
01:06:13,619 --> 01:06:16,260
that's how I will find their first bug

1546
01:06:16,460 --> 01:06:22,710
using the D printers and it's it's nice

1547
01:06:22,909 --> 01:06:28,670
to use the printf because you can like

1548
01:06:29,000 --> 01:06:33,490
just turn off the debugging print and

1549
01:06:33,690 --> 01:06:38,769
have a nice test output with our audit

1550
01:06:38,969 --> 01:06:43,539
debugging if you want it so that's how I

1551
01:06:43,739 --> 01:06:47,050
would use it deep enough to try to like

1552
01:06:47,250 --> 01:06:51,550
handle a bug in your code and for this

1553
01:06:51,750 --> 01:06:54,610
example there's actually another trick

1554
01:06:54,809 --> 01:06:59,230
to help you find this kind of deadlock

1555
01:06:59,429 --> 01:07:04,510
so if you press ctrl + backslash you can

1556
01:07:04,710 --> 01:07:08,800
see in the bottle but bottom left that I

1557
01:07:09,000 --> 01:07:12,940
press like control and backslash this

1558
01:07:13,139 --> 01:07:16,539
this command will send a signal quit

1559
01:07:16,739 --> 01:07:17,430
today

1560
01:07:17,630 --> 01:07:21,789
go program and by default it will

1561
01:07:21,989 --> 01:07:26,170
handles the the quiz signal and quit all

1562
01:07:26,369 --> 01:07:28,930
the go routines and print audio strike

1563
01:07:29,130 --> 01:07:41,170
the stack rates so now this like Chico

1564
01:07:41,369 --> 01:07:43,450
up here like this way it gets touched

1565
01:07:43,650 --> 01:07:47,320
and then there are gonna be a couple

1566
01:07:47,519 --> 01:07:52,280
functions printing here

1567
01:07:55,780 --> 01:08:01,450
just trying to go through all the traces

1568
01:08:07,480 --> 01:08:11,000
yes so it's actually showing that the

1569
01:08:11,199 --> 01:08:13,880
function that's causing the problem is

1570
01:08:14,079 --> 01:08:17,570
the cover to candidate so that's another

1571
01:08:17,770 --> 01:08:20,239
weight you've to find out where the day

1572
01:08:20,439 --> 01:08:31,229
locks are I can remove all this

1573
01:08:43,109 --> 01:08:46,840
and now it works so that's the first

1574
01:08:47,039 --> 01:08:51,369
example that I want to go through second

1575
01:08:51,569 --> 01:08:53,889
thing that you want it you want to do

1576
01:08:54,088 --> 01:08:56,800
before you submit your labs is to turn

1577
01:08:57,000 --> 01:08:58,269
the race

1578
01:08:58,469 --> 01:09:03,070
flag on when you do the test the way to

1579
01:09:03,270 --> 01:09:06,880
do that is just to add - race before

1580
01:09:07,079 --> 01:09:17,939
- groin and here because my implement

1581
01:09:18,139 --> 01:09:20,199
implementation doesn't have any research

1582
01:09:20,399 --> 01:09:22,329
so it's not going to tell you anything

1583
01:09:22,529 --> 01:09:25,090
but this just be careful about this

1584
01:09:25,289 --> 01:09:29,409
because it's not a proof that you don't

1585
01:09:29,609 --> 01:09:33,248
have any really it's just that it cannot

1586
01:09:33,448 --> 01:09:42,489
detect races for you I'm going to run

1587
01:09:42,689 --> 01:09:45,369
the same command again with the red flag

1588
01:09:45,569 --> 01:09:47,800
but now this time that's actually risk

1589
01:09:48,000 --> 01:09:56,619
going on in my implementation so it's

1590
01:09:56,819 --> 01:10:00,189
gonna yell at you that there's some

1591
01:10:00,389 --> 01:10:06,289
deliveries going on in your code

1592
01:10:08,000 --> 01:10:13,630
I'm quitting that and let's see like how

1593
01:10:13,829 --> 01:10:19,930
useful is the warning are so I'm gonna

1594
01:10:20,130 --> 01:10:25,819
go to my second implementation with

1595
01:10:27,829 --> 01:10:35,389
Rothko and here

1596
01:10:37,029 --> 01:10:45,210
let's look at this race so it's telling

1597
01:10:45,409 --> 01:10:47,820
us that there's a wheat going on at the

1598
01:10:48,020 --> 01:10:49,610
line

1599
01:10:49,810 --> 01:10:54,480
103 I'm going to that line so this the

1600
01:10:54,680 --> 01:11:07,820
wheat on probably Thursday here and

1601
01:11:08,020 --> 01:11:20,130
there's also a right line for 12 which

1602
01:11:20,329 --> 01:11:27,819
is Thursday so

1603
01:11:38,310 --> 01:11:45,300
I'm going to this line again

1604
01:11:45,500 --> 01:11:48,699
and now we kind of know that this this

1605
01:11:48,899 --> 01:11:53,079
radiation is protected by a lock so the

1606
01:11:53,279 --> 01:11:56,020
risk flies actually wanting us and

1607
01:11:56,220 --> 01:12:00,699
helping us to find out but on on this

1608
01:12:00,899 --> 01:12:04,900
database that we have so the fake it's

1609
01:12:05,100 --> 01:12:15,039
gonna be just you lock this and unlock

1610
01:12:15,239 --> 01:12:23,090
it and that should solve the problem

1611
01:12:28,050 --> 01:12:31,539
so at this place we kind of know how to

1612
01:12:31,739 --> 01:12:35,020
basic like do some basic debugging does

1613
01:12:35,220 --> 01:12:42,449
anyone have any question no okay yeah so

1614
01:12:42,649 --> 01:12:45,850
I'm going to go to the third one which

1615
01:12:46,050 --> 01:12:50,320
is going to be more difficult to find

1616
01:12:50,520 --> 01:13:01,239
about I'm going to test the run the

1617
01:13:01,439 --> 01:13:04,779
centers and now I am I actually have

1618
01:13:04,979 --> 01:13:09,970
some debugging messages in there already

1619
01:13:10,170 --> 01:13:17,409
and just see that I also have a

1620
01:13:17,609 --> 01:13:19,900
debugging message with the test action

1621
01:13:20,100 --> 01:13:22,650
there's something you might want to

1622
01:13:22,850 --> 01:13:33,940
consider doing if you go into the test

1623
01:13:34,140 --> 01:13:38,329
clip here

1624
01:13:42,988 --> 01:13:46,150
you can just see how the test would run

1625
01:13:46,350 --> 01:13:49,720
and then there are some actions that the

1626
01:13:49,920 --> 01:13:51,940
test clip is gonna do to make your code

1627
01:13:52,140 --> 01:13:57,960
fail and it's usually a good idea to

1628
01:13:58,159 --> 01:14:02,220
print out where that action is happening

1629
01:14:02,420 --> 01:14:07,210
in your actual debugging message so you

1630
01:14:07,409 --> 01:14:13,210
can guess what is happening like where

1631
01:14:13,409 --> 01:14:18,010
the bug is happening in which phase of

1632
01:14:18,210 --> 01:14:21,909
the test if that make sense so now it's

1633
01:14:22,109 --> 01:14:27,130
like I was doing fine in the first case

1634
01:14:27,329 --> 01:14:30,519
I passed I passed the fail but I'm

1635
01:14:30,719 --> 01:14:37,060
failing their second tiers and here the

1636
01:14:37,260 --> 01:14:40,600
Test section is to found one as a little

1637
01:14:40,800 --> 01:14:46,750
one so I'm passing this the test until

1638
01:14:46,949 --> 01:14:51,329
this and if you go to I'm actually

1639
01:14:51,529 --> 01:14:56,829
passing until the leader two rejoins so

1640
01:14:57,029 --> 01:14:59,619
this can give you a nice idea of how the

1641
01:14:59,819 --> 01:15:09,659
test is working and just to help you

1642
01:15:09,859 --> 01:15:13,630
have a better case as where the bondage

1643
01:15:13,829 --> 01:15:20,890
is in your code so now let's look at the

1644
01:15:21,090 --> 01:15:24,440
debugging messages

1645
01:15:32,179 --> 01:15:35,279
so it's least it seems like when liturgy

1646
01:15:35,479 --> 01:15:40,288
we joined it becomes a follower and we

1647
01:15:40,488 --> 01:15:41,610
have a new leader

1648
01:15:41,810 --> 01:15:46,680
so that looks fine to me and we probably

1649
01:15:46,880 --> 01:15:50,430
need more debugging messages instead of

1650
01:15:50,630 --> 01:16:00,720
just their state changes so I am going

1651
01:16:00,920 --> 01:16:05,579
to add some more my first case that when

1652
01:16:05,779 --> 01:16:08,340
one becomes a leader it might not be

1653
01:16:08,539 --> 01:16:12,989
doing what a leader should you correctly

1654
01:16:13,189 --> 01:16:17,469
so we got stuck

1655
01:16:23,769 --> 01:16:26,168
so you might could after we cover it as

1656
01:16:26,368 --> 01:16:29,810
eventually there I have a go routine

1657
01:16:30,010 --> 01:16:32,060
call operate leader

1658
01:16:32,260 --> 01:16:34,788
there's just standing habit CD all set

1659
01:16:34,988 --> 01:16:41,239
to the audio servers so I'm gonna print

1660
01:16:41,439 --> 01:16:54,019
some stuff here saying happy - cheers

1661
01:16:54,219 --> 01:16:56,550
away

1662
01:17:20,850 --> 01:17:24,909
so to become solidary it sends the the

1663
01:17:25,109 --> 01:17:32,920
first happy to each server and one still

1664
01:17:33,119 --> 01:17:39,529
tries to send happy to the new leader

1665
01:17:41,000 --> 01:17:46,739
and then one becomes a follower so this

1666
01:17:46,939 --> 01:17:54,520
doesn't look like to be a problem now

1667
01:17:54,720 --> 01:17:56,710
I'm gonna check if the other service

1668
01:17:56,909 --> 01:18:01,010
receive habit correctly

1669
01:19:25,658 --> 01:19:28,880
it's taking away with I'm trying to

1670
01:19:29,079 --> 01:19:37,150
finish this yeah so to becomes a leader

1671
01:19:37,350 --> 01:19:43,670
to sends high bid but no one receive a

1672
01:19:43,869 --> 01:19:54,519
habit form - so if I go to the same

1673
01:19:54,719 --> 01:19:59,560
opinion tree I actually hold the law to

1674
01:19:59,760 --> 01:20:03,610
the RPC Hall which is the problem that

1675
01:20:03,810 --> 01:20:07,748
Fabian went to in the last section so

1676
01:20:07,948 --> 01:20:10,579
that's that's the problem that I need to

1677
01:20:10,779 --> 01:20:22,050
fix so what I should do is to a lot here

1678
01:20:23,969 --> 01:20:28,800
and then

1679
01:20:33,729 --> 01:20:39,539
lock again here and that should work

1680
01:20:47,189 --> 01:20:53,680
we pass and then there are couple things

1681
01:20:53,880 --> 01:20:58,210
that you might want to do when you test

1682
01:20:58,409 --> 01:21:03,159
your rough implementation so that's

1683
01:21:03,359 --> 01:21:09,360
actually script to run the test in

1684
01:21:09,560 --> 01:21:13,810
imperial and I can show you how I how we

1685
01:21:14,010 --> 01:21:18,369
can use how we can use it this creep is

1686
01:21:18,569 --> 01:21:21,159
in the inner peer support some someone

1687
01:21:21,359 --> 01:21:26,980
make a point about it and here's how we

1688
01:21:27,180 --> 01:21:33,570
can use the script so you run the script

1689
01:21:33,770 --> 01:21:36,180
specify the number of the test

1690
01:21:36,380 --> 01:21:40,029
personally I do like a 1000 but that

1691
01:21:40,229 --> 01:21:43,989
depends on your preference this is the

1692
01:21:44,189 --> 01:21:47,050
number of course that you wanna run the

1693
01:21:47,250 --> 01:21:49,090
test at the same time and then here's

1694
01:21:49,289 --> 01:21:56,988
the test and if you run the script then

1695
01:21:59,479 --> 01:22:04,420
if you show you that's like we have run

1696
01:22:04,619 --> 01:22:09,130
four tests so far all are working fine

1697
01:22:09,329 --> 01:22:13,748
and it's gonna keep going like that so

1698
01:22:13,948 --> 01:22:17,038
that's how I would go about debugging

1699
01:22:17,238 --> 01:22:19,538
rough implementation and you are all

1700
01:22:19,738 --> 01:22:22,060
welcome to come to office hours when you

1701
01:22:22,260 --> 01:22:27,260
need help

