WEBVTT

1
00:00:00.540 --> 00:00:04.849
all right everybody let's get started

2
00:00:05.360 --> 00:00:10.619
today the paper four days I'm is aunt

3
00:00:10.619 --> 00:00:12.449
Aurora paper which is all about how to

4
00:00:12.449 --> 00:00:17.519
get a high-performance reliable database

5
00:00:17.519 --> 00:00:19.649
going as a piece of cloud infrastructure

6
00:00:19.649 --> 00:00:22.800
and itself built out of infrastructure

7
00:00:22.800 --> 00:00:29.100
that Amazon itself makes available so

8
00:00:29.100 --> 00:00:30.210
the reason why we're reading this paper

9
00:00:30.210 --> 00:00:32.100
is that first of all it's a very

10
00:00:32.100 --> 00:00:34.289
successful recent cloud service from

11
00:00:34.289 --> 00:00:38.479
Amazon a lot of their customers use it

12
00:00:38.479 --> 00:00:41.460
it shows sort of in its own way an

13
00:00:41.460 --> 00:00:44.820
example of a very big payoff from clever

14
00:00:44.820 --> 00:00:46.530
design table one which sort of

15
00:00:46.530 --> 00:00:48.380
summarizes the performance shows that

16
00:00:48.380 --> 00:00:51.210
relative to some other system which is

17
00:00:51.210 --> 00:00:53.429
not very well explained the paper claims

18
00:00:53.429 --> 00:00:55.770
to get a thirty five times speed up in

19
00:00:55.770 --> 00:00:57.479
transaction throughput which is

20
00:00:57.479 --> 00:01:00.329
extremely impressive this paper also

21
00:01:00.329 --> 00:01:03.149
kind of explores the limits of how well

22
00:01:03.149 --> 00:01:04.680
you can do for performance and fault

23
00:01:04.680 --> 00:01:06.750
tolerance using general-purpose storage

24
00:01:06.750 --> 00:01:08.310
because one of the themes of the papers

25
00:01:08.310 --> 00:01:10.469
they basically abandoned general-purpose

26
00:01:10.469 --> 00:01:12.510
storage they switch from a design in

27
00:01:12.510 --> 00:01:14.250
which they were using their Amazon's own

28
00:01:17.969 --> 00:01:19.409
basically built totally

29
00:01:19.409 --> 00:01:22.319
application-specific storage

30
00:01:22.319 --> 00:01:23.939
furthermore the paper has a lot of

31
00:01:23.939 --> 00:01:25.590
little tidbits about what turned out to

32
00:01:36.510 --> 00:01:38.730
history or what my impression is about

33
00:01:38.730 --> 00:01:41.269
the story that led up to the design of

34
00:01:41.269 --> 00:01:43.829
aurora because it's you know the sort of

35
00:01:43.829 --> 00:01:47.310
m f-- way that amazon has in mind that

36
00:01:47.310 --> 00:01:49.950
you ought to build that their cloud

37
00:01:49.950 --> 00:01:51.810
customers ought to build databases on

38
00:01:51.810 --> 00:01:55.140
amazon's infrastructure so in the

39
00:01:55.140 --> 00:02:02.849
beginning amazon had basically their

40
00:02:02.849 --> 00:02:05.370
very first offering cloud offering to

41
00:02:05.370 --> 00:02:06.659
support people who wanted to build

42
00:02:06.659 --> 00:02:09.419
websites but using Amazon's hardware and

43
00:02:09.419 --> 00:02:11.460
in Amazon's machine room their first

44
00:02:11.460 --> 00:02:14.900
offering was something called ec2

45
00:02:21.750 --> 00:02:23.520
rooms full of servers and they ran

46
00:02:26.729 --> 00:02:30.419
machines to their customers and their

47
00:02:30.419 --> 00:02:32.189
customers would then you know rent a

48
00:02:39.330 --> 00:02:42.500
ec2 instances so the picture of one

49
00:02:42.500 --> 00:02:47.990
physical server looked like this Amazon

50
00:02:47.990 --> 00:02:50.520
we control the virtual machine monitor

51
00:02:54.810 --> 00:02:57.719
instances each one rented out to a

52
00:02:57.719 --> 00:02:59.729
different cloud customer each of these

53
00:03:22.289 --> 00:03:23.939
that's extremely important for us is

54
00:03:23.939 --> 00:03:28.500
that initially the way you get storage

55
00:03:28.500 --> 00:03:30.180
the way you've got storage if you rented

56
00:03:30.180 --> 00:03:33.270
an ec2 instance was that every one of

57
00:03:33.270 --> 00:03:35.479
their servers had a disk attached a

58
00:03:35.479 --> 00:03:38.430
physical disk attached and each one of

59
00:03:38.430 --> 00:03:41.400
these instances that they rented to

60
00:03:41.400 --> 00:03:43.469
their customers will get us you know a

61
00:03:43.469 --> 00:03:46.889
slice of the disk so they said locally

62
00:03:46.889 --> 00:03:48.960
attached storage and you got a bit of

63
00:03:48.960 --> 00:03:50.430
locally attached storage which itself

64
00:03:50.430 --> 00:03:52.110
just look like a hard drive an emulated

65
00:03:52.110 --> 00:03:56.810
hard drive to the virtual machine guests

66
00:03:56.870 --> 00:04:00.479
ec2 is like perfect for web servers for

67
00:04:00.479 --> 00:04:02.219
stateless web servers you know your

68
00:04:02.219 --> 00:04:04.199
customers with their web browsers would

69
00:04:04.199 --> 00:04:07.229
connect to a bunch of rented ec2

70
00:04:07.229 --> 00:04:10.919
instances that ran a web server and if

71
00:04:10.919 --> 00:04:12.300
you added all of a sudden more customers

72
00:04:12.300 --> 00:04:14.189
you could just instantly rent more ec2

73
00:04:14.189 --> 00:04:15.539
instances from

74
00:04:15.539 --> 00:04:17.939
Amazon and fire up web servers on them

75
00:04:27.660 --> 00:04:30.509
in ec2 instance this was databases

76
00:04:30.509 --> 00:04:32.279
because usually a website is constructed

77
00:04:32.279 --> 00:04:34.800
of a set of stateless web servers that

78
00:04:34.800 --> 00:04:37.500
anytime they need to get out permanent

79
00:04:37.500 --> 00:04:40.589
data go talk to a back-end database so

80
00:04:40.589 --> 00:04:43.589
what you would get is is maybe a bunch

81
00:04:50.910 --> 00:04:56.670
and then a number of ec2 web server

82
00:04:56.670 --> 00:04:58.470
instances as many as you need it to run

83
00:04:58.470 --> 00:05:00.629
the sort of logic of the website this

84
00:05:00.629 --> 00:05:05.310
this is now inside Amazon and then also

85
00:05:05.310 --> 00:05:10.879
some also typically one ec2 instance

86
00:05:10.879 --> 00:05:13.829
running a database your web servers

87
00:05:13.829 --> 00:05:15.509
would talk to your database instance and

88
00:05:15.509 --> 00:05:16.920
ask it to read and write records in the

89
00:05:16.920 --> 00:05:19.889
database unfortunately ec2 wasn't

90
00:05:19.889 --> 00:05:22.560
perfect was it nearly as well-suited to

91
00:05:22.560 --> 00:05:24.269
running a database as it was to running

92
00:05:24.269 --> 00:05:25.889
web servers and the most immediate

93
00:05:25.889 --> 00:05:29.819
reason is that the storage or the sort

94
00:05:29.819 --> 00:05:32.550
of main easy way to get storage for your

95
00:05:32.550 --> 00:05:35.100
ec2 database instance was on the locally

96
00:05:35.100 --> 00:05:39.600
attached disk attached to whatever a

97
00:05:39.600 --> 00:05:41.670
piece of hardware your database instance

98
00:05:46.740 --> 00:05:48.300
access to whatever what is on its hard

99
00:05:48.300 --> 00:05:51.750
drive so if it's a hardware that it was

100
00:05:51.750 --> 00:05:54.209
actually implementing a web server

101
00:05:54.209 --> 00:05:55.589
crashed no problem at all because

102
00:05:55.589 --> 00:05:57.660
there's really keeps no state itself you

103
00:05:57.660 --> 00:05:59.279
just fire up a new web server on a new

104
00:06:04.740 --> 00:06:06.209
unavailable you have a serious problem

105
00:06:06.209 --> 00:06:08.939
if the data is stored on the locally

106
00:06:22.620 --> 00:06:24.420
chunks of data called s3 and you could

107
00:06:24.420 --> 00:06:25.949
take snapshots you could take Prius

108
00:06:25.949 --> 00:06:27.720
periodic snapshots if you need a basis

109
00:06:27.720 --> 00:06:30.870
state and stored in s3 and use that for

110
00:06:30.870 --> 00:06:34.860
sort of backup disaster recovery but you

111
00:06:34.860 --> 00:06:36.870
know that style of periodic snapshots

112
00:06:36.870 --> 00:06:38.459
means you're gonna lose updates that

113
00:06:38.459 --> 00:06:39.269
happen

114
00:06:45.389 --> 00:06:47.639
that's relevant to the sort of Aurora

115
00:06:47.639 --> 00:06:51.120
database story is that in order to

116
00:06:51.120 --> 00:06:55.170
provide their customers with disks for

117
00:06:55.170 --> 00:06:57.300
their ec2 instances that didn't go away

118
00:06:57.300 --> 00:06:59.370
if there was a failure that is more sort

119
00:06:59.370 --> 00:07:01.920
of fault tolerant long-term storage was

120
00:07:01.920 --> 00:07:04.470
guaranteed to be there Amazon introduced

121
00:07:04.470 --> 00:07:08.279
the service called EBS and this stands

122
00:07:08.279 --> 00:07:09.839
for elastic block store

123
00:07:09.839 --> 00:07:12.540
so with EBS is is a service that looks

124
00:07:12.540 --> 00:07:16.529
to an ec2 instances it looks to one of

125
00:07:16.529 --> 00:07:17.939
these instances one of these guest

126
00:07:17.939 --> 00:07:19.709
virtual machines just as if it were a

127
00:07:19.709 --> 00:07:21.990
hard drive an ordinary way you could

128
00:07:21.990 --> 00:07:24.149
format it as a hard drive but a file

129
00:07:24.149 --> 00:07:27.120
system like ext3 or whatever Linux file

130
00:07:27.120 --> 00:07:28.889
system you like on this on this thing

131
00:07:28.889 --> 00:07:30.629
that looks to be guest just like a hard

132
00:07:30.629 --> 00:07:31.920
drive but the way it's actually

133
00:07:31.920 --> 00:07:35.279
implemented is as a replicated pair of

134
00:07:35.279 --> 00:07:40.889
storage servers so this is the local

135
00:07:40.889 --> 00:07:43.519
this is one of local storage with Mike

136
00:07:43.519 --> 00:07:47.550
if when EBS came out then you could you

137
00:07:47.550 --> 00:07:49.589
could rent an e BS volume which this

138
00:07:49.589 --> 00:07:50.670
thing that looks just like an ordinary

139
00:07:50.670 --> 00:07:53.129
hard drive but it's actually implemented

140
00:08:03.839 --> 00:08:09.360
attached hard drive so if your software

141
00:08:09.360 --> 00:08:10.920
here maybe you're running a database now

142
00:08:15.120 --> 00:08:16.350
database server doesn't write what that

143
00:08:16.350 --> 00:08:18.120
actually means is that the right to send

144
00:08:18.120 --> 00:08:19.829
out over the network and using chain

145
00:08:19.829 --> 00:08:21.300
replication which we talked about last

146
00:08:27.449 --> 00:08:28.970
first CBS server that's backing your

147
00:08:28.970 --> 00:08:30.959
volume and then the second one and

148
00:08:30.959 --> 00:08:33.330
finally you get the reply and similarly

149
00:08:33.330 --> 00:08:35.759
when you do a read I guess some chain

150
00:08:35.759 --> 00:08:37.379
replication you'll be the last of the

151
00:08:37.379 --> 00:08:41.789
chain so now database is running on ec2

152
00:08:41.789 --> 00:08:44.250
instances had available a storage system

153
00:08:53.429 --> 00:08:55.169
another ec2 instance fire up your

154
00:08:55.169 --> 00:08:58.110
database and have it attached to the

155
00:08:58.110 --> 00:09:01.110
same old EBS volume that the sort of

156
00:09:01.110 --> 00:09:03.539
previous version of your database was

157
00:09:03.539 --> 00:09:04.799
attached to and it would see all the old

158
00:09:04.799 --> 00:09:07.110
data just as it had been left off by the

159
00:09:07.110 --> 00:09:10.500
previous database just like you moved a

160
00:09:10.500 --> 00:09:11.759
hard drive from one machine to another

161
00:09:11.759 --> 00:09:14.909
so EBS was like really a good deal for

162
00:09:14.909 --> 00:09:16.230
people who need it to keep permanent

163
00:09:16.230 --> 00:09:26.850
state like people running databases one

164
00:09:26.850 --> 00:09:29.519
thing to that is sort of important for

165
00:09:29.519 --> 00:09:33.179
us about EBS is that it's really it's

166
00:09:33.179 --> 00:09:36.259
not a system for sharing at any one time

167
00:09:36.259 --> 00:09:41.340
only one ec2 instance only one virtual

168
00:09:41.340 --> 00:09:43.769
machine can mount a given EBS volume so

169
00:09:43.769 --> 00:09:45.299
the EBS volumes are implemented on a

170
00:09:45.299 --> 00:09:47.730
huge fleet of you know hundreds or

171
00:09:47.730 --> 00:09:49.620
whatever storage servers with disks at

172
00:09:49.620 --> 00:09:52.409
Amazon and they're all you know

173
00:09:52.409 --> 00:09:55.169
everybody's EBS volumes are stored on

174
00:09:55.169 --> 00:09:58.740
this big pool of servers but each one of

175
00:10:08.509 --> 00:10:13.289
right still EBS was a big step up but it

176
00:10:13.289 --> 00:10:18.179
had still has some problems so there's

177
00:10:18.179 --> 00:10:19.230
still some things that are not quite as

178
00:10:19.230 --> 00:10:22.830
perfect as it could be one is that if

179
00:10:22.830 --> 00:10:24.750
you run a database on EBS it ends up

180
00:10:24.750 --> 00:10:27.750
sending large volumes of data across the

181
00:10:27.750 --> 00:10:31.740
network and this is uh we're now

182
00:10:31.740 --> 00:10:33.450
starting to sort of sneak up on figure

183
00:10:33.450 --> 00:10:36.750
two in the the paper where they start

184
00:10:36.750 --> 00:10:38.669
complaining about how many just how many

185
00:10:38.669 --> 00:10:40.950
writes it takes if you run a database on

186
00:10:40.950 --> 00:10:45.659
top of a network storage system so

187
00:10:50.460 --> 00:10:53.220
one of the kind of things in the paper

188
00:10:53.220 --> 00:10:55.889
that the paper implies is that they're

189
00:10:55.889 --> 00:10:59.909
as much network limited as they are CPU

190
00:10:59.909 --> 00:11:01.769
or storage limited that is they pay a

191
00:11:01.769 --> 00:11:03.809
huge amount of attention to reducing the

192
00:11:03.809 --> 00:11:05.429
Aurora paper sends a huge amount of

193
00:11:05.429 --> 00:11:07.259
attention for reducing the network

194
00:11:07.259 --> 00:11:09.720
that the database generates and seems to

195
00:11:15.860 --> 00:11:18.149
sort of a hint at what they think is

196
00:11:18.149 --> 00:11:20.639
important the other problem with EBS is

197
00:11:20.639 --> 00:11:22.710
not very fault tolerant it turns out

198
00:11:22.710 --> 00:11:25.320
that for performance reasons they I'm

199
00:11:25.320 --> 00:11:26.970
done would always put both of the EBS

200
00:11:26.970 --> 00:11:29.490
both of the replicas of your EBS volume

201
00:11:29.490 --> 00:11:32.730
in the same data center and so we have a

202
00:11:32.730 --> 00:11:34.649
single server crashed if you know one of

203
00:11:37.440 --> 00:11:39.179
the other one but there was just no

204
00:11:39.179 --> 00:11:40.649
story at all for what happens if an

205
00:11:40.649 --> 00:11:50.240
entire data center went down and and

206
00:11:50.240 --> 00:11:53.580
apparently a lot of customers really

207
00:11:53.580 --> 00:11:55.259
wanted a story that would allow their

208
00:11:55.259 --> 00:11:57.840
data to survive an outage of an entire

209
00:11:57.840 --> 00:12:00.210
data center maybe it lost his network

210
00:12:00.210 --> 00:12:01.919
connection it was a fire in the building

211
00:12:01.919 --> 00:12:04.529
or a power failure to the whole building

212
00:12:04.529 --> 00:12:05.730
or something people really wanted to

213
00:12:05.730 --> 00:12:07.110
have at least the option if they're

214
00:12:07.110 --> 00:12:09.330
willing to pay more of having their data

215
00:12:09.330 --> 00:12:10.590
stored in a way they hid they could

216
00:12:10.590 --> 00:12:13.860
still get at it I'm even if one data

217
00:12:13.860 --> 00:12:20.389
center goes down and the way that Amazon

218
00:12:20.389 --> 00:12:25.470
described this there is that both an

219
00:12:25.470 --> 00:12:29.940
instance and its EBS to EBS replicas are

220
00:12:29.940 --> 00:12:32.360
in the same ability veil ability zone

221
00:12:32.360 --> 00:12:34.740
and an Amazon jargon an availability

222
00:12:34.740 --> 00:12:36.899
zone is a particular data center and the

223
00:12:36.899 --> 00:12:38.789
way they structure their data centers is

224
00:12:38.789 --> 00:12:42.169
that there's usually multiple

225
00:12:42.169 --> 00:12:44.759
independent data centers in more or less

226
00:12:44.759 --> 00:12:46.679
the same city or relatively close to

227
00:12:52.559 --> 00:12:54.179
that are near by each other are all

228
00:12:54.179 --> 00:12:56.340
connected by redundant high speed

229
00:12:56.340 --> 00:12:58.289
networks so there's always payers or

230
00:12:58.289 --> 00:13:00.360
triples of nearby availability

231
00:13:00.360 --> 00:13:01.740
availability centers and we'll see the

232
00:13:01.740 --> 00:13:03.360
buy that's important in a little bit but

233
00:13:03.360 --> 00:13:05.759
at least for EBS in order to keep the

234
00:13:12.210 --> 00:13:15.740
be in the same availability zone

235
00:13:16.730 --> 00:13:21.899
all right um before I dive into more

236
00:13:21.899 --> 00:13:27.629
into how Aurora actually works it turns

237
00:13:27.629 --> 00:13:31.169
out that the details of the design in

238
00:13:31.169 --> 00:13:32.580
order to understand them we first have

239
00:13:32.580 --> 00:13:34.649
to know a fair amount about the sort of

240
00:13:34.649 --> 00:13:36.450
design of typical databases because what

241
00:13:36.450 --> 00:13:40.230
they taken is sort of the main machinery

242
00:13:40.230 --> 00:13:42.360
of a database my sequel as it happens

243
00:13:42.360 --> 00:13:44.940
and split it up in an interesting way so

244
00:13:44.940 --> 00:13:46.649
we need to know sort of what it but it

245
00:13:46.649 --> 00:13:48.389
is a database does so we can understand

246
00:13:48.389 --> 00:13:50.879
how they split it up so this is really a

247
00:13:50.879 --> 00:13:58.139
kind of database tutorial really

248
00:13:58.139 --> 00:14:01.759
focusing on what it takes to implement

249
00:14:01.759 --> 00:14:04.110
transactions crashed recoverable

250
00:14:04.110 --> 00:14:06.210
transactions so what I really care about

251
00:14:06.210 --> 00:14:14.429
is transactions and crash recovery and

252
00:14:18.960 --> 00:14:22.320
for this paper so first what's a

253
00:14:22.320 --> 00:14:24.269
transaction you know transaction is just

254
00:14:28.710 --> 00:14:31.379
declare in that that that's entire

255
00:14:31.379 --> 00:14:33.419
sequence of operations should appear a

256
00:14:33.419 --> 00:14:35.970
Tomic to anyone else who's reading or

257
00:14:35.970 --> 00:14:38.750
writing the data so you might see

258
00:14:38.750 --> 00:14:40.799
transposing we're running a bank and we

259
00:14:40.799 --> 00:14:43.110
want to do transfers between different

260
00:14:43.110 --> 00:14:46.409
accounts maybe you would say well we

261
00:14:46.409 --> 00:14:48.600
would see code or you know see a

262
00:14:48.600 --> 00:14:50.220
transaction looks like this is you have

263
00:14:50.220 --> 00:14:51.960
to clear the beginning of the sequence

264
00:14:51.960 --> 00:14:53.879
of instructions that you want to be

265
00:14:53.879 --> 00:14:55.889
atomic in the in transaction maybe we're

266
00:14:55.889 --> 00:14:59.250
going to transfer money from account Y

267
00:14:59.250 --> 00:15:02.580
to account X so we might see where I'll

268
00:15:02.580 --> 00:15:05.190
just pretend X is a bank balance Jordan

269
00:15:05.190 --> 00:15:06.419
the database you might see the

270
00:15:06.419 --> 00:15:08.610
transaction looks like oh can I add $10

271
00:15:08.610 --> 00:15:11.590
to X's account and

272
00:15:16.429 --> 00:15:17.210
transaction

273
00:15:17.210 --> 00:15:19.940
I want the database to just do them both

274
00:15:19.940 --> 00:15:21.950
without allowing anybody else to sneak

275
00:15:27.230 --> 00:15:29.570
crashes if there's a crash at this point

276
00:15:32.720 --> 00:15:34.850
that either the entire transactions

277
00:15:34.850 --> 00:15:36.470
worth the modifications are visible or

278
00:15:36.470 --> 00:15:40.100
none of them are so that's the effect we

279
00:15:40.100 --> 00:15:41.389
want from transactions there's

280
00:15:41.389 --> 00:15:44.360
additionally people expect database

281
00:15:44.360 --> 00:15:46.639
users expect that the database will tell

282
00:15:46.639 --> 00:15:48.830
them tell the client that submitted the

283
00:15:48.830 --> 00:15:51.200
transaction whether the transaction

284
00:15:51.200 --> 00:15:52.879
really finished and committed or not and

285
00:15:52.879 --> 00:15:55.330
if a transaction is committed we expect

286
00:16:05.720 --> 00:16:08.120
is that the usual way these are

287
00:16:12.799 --> 00:16:15.980
it so you can view the they're being

288
00:16:15.980 --> 00:16:20.840
locks x and y for the duration of the

289
00:16:20.840 --> 00:16:22.490
transaction and these are only released

290
00:16:22.490 --> 00:16:24.559
after the transaction finally commits

291
00:16:24.559 --> 00:16:29.210
that is known to be permanent this is

292
00:16:29.210 --> 00:16:31.850
important if you for some of the things

293
00:16:31.850 --> 00:16:33.259
that you have to if you some of the

294
00:16:36.440 --> 00:16:38.720
is actually locking out other access to

295
00:16:38.720 --> 00:16:40.220
the data during the life of a

296
00:16:40.220 --> 00:16:43.340
transaction so how this actually

297
00:16:43.340 --> 00:16:47.620
implemented it turns out the database

298
00:16:55.250 --> 00:16:56.750
typically written to run on a single

299
00:16:56.750 --> 00:16:58.190
server with you know some storage

300
00:16:58.190 --> 00:17:00.259
directly attached and a game that the

301
00:17:00.259 --> 00:17:01.549
Aurora paper is playing is sort of

302
00:17:01.549 --> 00:17:05.329
moving that software only modestly

303
00:17:05.329 --> 00:17:07.339
revised in order to run on a much more

304
00:17:07.339 --> 00:17:09.559
complex network system but the starting

305
00:17:09.559 --> 00:17:11.390
point is we just assume we have a

306
00:17:11.390 --> 00:17:16.519
database with a attached to a disk the

307
00:17:16.519 --> 00:17:18.819
on disk structure that stores these

308
00:17:18.819 --> 00:17:21.559
records is some kind of indexing

309
00:17:21.559 --> 00:17:24.190
structure like a b-tree maybe so

310
00:17:24.190 --> 00:17:25.960
there's a sort of pages with the paper

311
00:17:25.960 --> 00:17:27.819
calls data pages that holds us you know

312
00:17:27.819 --> 00:17:32.259
real data of the of the database you

313
00:17:32.259 --> 00:17:34.630
know maybe this is excess balances and

314
00:17:34.630 --> 00:17:36.579
this is wise balance these data pages

315
00:17:36.579 --> 00:17:40.259
typically hold lots and lots of records

316
00:17:40.259 --> 00:17:42.339
whereas X and y are typically just a

317
00:17:42.339 --> 00:17:44.319
couple bites on some page in the

318
00:17:44.319 --> 00:17:46.740
database so on the disk there's the

319
00:17:46.740 --> 00:17:49.990
actual data plus on the disk there's

320
00:17:49.990 --> 00:17:55.660
also a right ahead log or wal and the

321
00:17:55.660 --> 00:17:57.400
right ahead logs are a critical part of

322
00:18:05.529 --> 00:18:08.230
database typically has a cache of pages

323
00:18:13.210 --> 00:18:15.250
transaction what that actually executes

324
00:18:15.250 --> 00:18:16.990
these statements what that really means

325
00:18:16.990 --> 00:18:19.329
is you know what x equals x plus 10

326
00:18:19.329 --> 00:18:21.880
turns into the runtime is that the

327
00:18:21.880 --> 00:18:23.799
database reads the current page holding

328
00:18:23.799 --> 00:18:27.519
X from the disk and adds 10 to it but so

329
00:18:27.519 --> 00:18:29.920
far until the transaction commits it

330
00:18:29.920 --> 00:18:31.480
only makes the modifications in the

331
00:18:42.990 --> 00:18:46.180
while then when the database but before

332
00:18:46.180 --> 00:18:47.980
because the database wants to sort of

333
00:18:47.980 --> 00:18:50.589
pre to clear the complete transaction so

334
00:18:50.589 --> 00:18:53.140
it's available to the software after a

335
00:18:53.140 --> 00:18:56.289
crash and during recovery before the

336
00:18:56.289 --> 00:18:57.910
database is allowed to modify the real

337
00:18:57.910 --> 00:18:59.950
data pages on disk its first required to

338
00:18:59.950 --> 00:19:03.960
add log entries that describe the

339
00:19:03.960 --> 00:19:06.400
transaction so it has to in order before

340
00:19:06.400 --> 00:19:07.869
it can commit the transaction it needs

341
00:19:07.869 --> 00:19:09.309
to put a complete set of log ahead

342
00:19:09.309 --> 00:19:11.710
entries in the right ahead log on disk

343
00:19:11.710 --> 00:19:13.720
I'm describing all the data bases

344
00:19:13.720 --> 00:19:15.940
modification so let's suppose here that

345
00:19:15.940 --> 00:19:20.740
x and y start out as say 500 and y

346
00:19:26.829 --> 00:19:29.170
before writing the pages the database is

347
00:19:29.170 --> 00:19:31.750
going to add at least typically 3 log

348
00:19:31.750 --> 00:19:34.480
records 1 this that says well as part of

349
00:19:34.480 --> 00:19:37.380
this transaction I'm modifying X

350
00:19:37.380 --> 00:19:43.529
and it's old value is 500 make more room

351
00:19:43.529 --> 00:19:50.250
here this is the on dis log so each log

352
00:19:50.250 --> 00:19:52.349
entry might say here's the value I'm

353
00:19:52.349 --> 00:19:56.730
modifying here's the old value and we're

354
00:19:56.730 --> 00:19:58.680
adding and here's the new value say five

355
00:20:04.799 --> 00:20:07.410
subtracting 10 so the new value is 740

356
00:20:07.410 --> 00:20:11.309
and then when the database if it

357
00:20:11.309 --> 00:20:12.809
actually manages to get to the end of

358
00:20:12.809 --> 00:20:14.400
the transaction before crashing its

359
00:20:14.400 --> 00:20:18.450
gonna write a commit record saying and

360
00:20:18.450 --> 00:20:20.309
typically these are all tagged with some

361
00:20:20.309 --> 00:20:23.220
sort with a transaction ID so that the

362
00:20:23.220 --> 00:20:24.930
recovery software eventually will know

363
00:20:24.930 --> 00:20:27.660
how this commit record refers to these

364
00:20:27.660 --> 00:20:32.420
log records yes

365
00:20:36.589 --> 00:20:38.970
in a simple database will be enough to

366
00:20:38.970 --> 00:20:41.609
just store the new values and say well

367
00:20:41.609 --> 00:20:43.980
it is a crash we're gonna just reapply

368
00:20:43.980 --> 00:20:47.240
all the new values the reason most

369
00:20:47.240 --> 00:20:50.849
serious databases store the old as well

370
00:20:50.849 --> 00:20:52.380
as a new value is to give them freedom

371
00:20:52.380 --> 00:20:56.430
to even for a long-running traction for

372
00:20:56.430 --> 00:20:57.839
a long-running transaction even before

373
00:20:57.839 --> 00:20:59.609
the transaction is finished it gives the

374
00:20:59.609 --> 00:21:00.900
database the freedom to write the

375
00:21:00.900 --> 00:21:04.490
updated page to disk with the new value

376
00:21:04.490 --> 00:21:07.349
740 let's say from the from an

377
00:21:07.349 --> 00:21:10.589
uncompleted transaction as long as it's

378
00:21:10.589 --> 00:21:11.970
written the log record to disk and then

379
00:21:11.970 --> 00:21:13.920
if there's a crash before the commit the

380
00:21:13.920 --> 00:21:15.420
recovery software always say aha well

381
00:21:15.420 --> 00:21:17.190
this transaction never finished

382
00:21:21.299 --> 00:21:22.680
values are the values you need in order

383
00:21:22.680 --> 00:21:24.329
to undo a transaction that's been

384
00:21:24.329 --> 00:21:26.609
partially written to the data pages so

385
00:21:26.609 --> 00:21:32.730
the aurora indeed uses undo redo logging

386
00:21:32.730 --> 00:21:35.869
to be able to undo partially applied

387
00:21:35.869 --> 00:21:40.200
transactions okay so if the database

388
00:21:40.200 --> 00:21:42.240
manages to get as far as getting the

389
00:21:42.240 --> 00:21:44.190
transactions log records on the disk and

390
00:21:44.190 --> 00:21:46.430
the commit record marking is finished

391
00:21:46.430 --> 00:21:48.990
then it is entitled to apply to the

392
00:21:48.990 --> 00:21:50.160
client we said the transactions

393
00:21:50.160 --> 00:21:51.900
committed the database can reply to the

394
00:21:51.900 --> 00:21:53.849
client and the client can be assured

395
00:21:53.849 --> 00:21:56.400
that its transaction will be sort of

396
00:21:56.400 --> 00:21:59.970
visible forever and now one of two

397
00:21:59.970 --> 00:22:01.319
things happens the database server

398
00:22:01.319 --> 00:22:04.500
doesn't crash then eventually so it's

399
00:22:04.500 --> 00:22:08.880
modified in its cache these these X&Y

400
00:22:15.930 --> 00:22:18.180
blocks to their real places on the disk

401
00:22:18.180 --> 00:22:20.640
over writing you know these be tree

402
00:22:20.640 --> 00:22:22.380
nodes or something and then the database

403
00:22:22.380 --> 00:22:26.549
can reuse this part of the log so

404
00:22:26.549 --> 00:22:27.990
databases tend to be lazy about that

405
00:22:27.990 --> 00:22:30.240
because they like to accumulate you know

406
00:22:30.240 --> 00:22:32.430
maybe there'll be many updates to these

407
00:22:32.430 --> 00:22:34.819
pages in the cache it's nice to

408
00:22:39.900 --> 00:22:41.519
server crashes before writing the day

409
00:22:41.519 --> 00:22:43.769
writing these pages to the disk so they

410
00:22:43.769 --> 00:22:47.160
still have their old values then it's

411
00:22:49.880 --> 00:22:53.599
debase scan the log see these records

412
00:22:53.599 --> 00:22:54.950
for the transaction see that that

413
00:22:54.950 --> 00:22:58.549
transaction was committed and apply the

414
00:22:58.549 --> 00:23:03.970
new values to the to the stored data and

415
00:23:11.869 --> 00:23:15.259
that's how transactional databases work

416
00:23:15.259 --> 00:23:18.440
in a nutshell and so this is a sort of

417
00:23:18.440 --> 00:23:22.150
very extremely abbreviated version of

418
00:23:22.150 --> 00:23:25.339
how for example the my sequel database

419
00:23:25.339 --> 00:23:28.819
works that an Aurora is based on this

420
00:23:28.819 --> 00:23:30.170
open source software thing called

421
00:23:30.170 --> 00:23:32.539
database called my sequel which does

422
00:23:32.539 --> 00:23:34.609
crash recovery transaction and crash

423
00:23:34.609 --> 00:23:40.369
recovery in much this way ok so the next

424
00:23:40.369 --> 00:23:44.690
step in Amazon's development a better

425
00:23:44.690 --> 00:23:46.730
and better database infrastructure for

426
00:23:46.730 --> 00:23:50.259
its cloud customers is something called

427
00:23:50.259 --> 00:23:53.869
RDS and I'm only talking about RDS

428
00:23:53.869 --> 00:23:55.640
because it turns out that even though

429
00:23:55.640 --> 00:23:56.720
the paper doesn't quite mention it

430
00:23:56.720 --> 00:23:58.880
figure 2 in the paper is basically a

431
00:23:58.880 --> 00:24:01.549
description of RDS so what's going on

432
00:24:01.549 --> 00:24:04.279
and RDS is that it was a first attempt

433
00:24:04.279 --> 00:24:07.160
to get a database that was replicated in

434
00:24:07.160 --> 00:24:09.440
multiple availability zones so that if

435
00:24:09.440 --> 00:24:12.740
an entire data center went down you

436
00:24:12.740 --> 00:24:14.359
could get back your database contents

437
00:24:14.359 --> 00:24:16.849
without missing any rights so that deal

438
00:24:16.849 --> 00:24:20.329
with RDS is that there's one you have

439
00:24:20.329 --> 00:24:22.910
one ec2 instance that's the database

440
00:24:22.910 --> 00:24:23.569
server

441
00:24:23.569 --> 00:24:24.920
you just have one you just want to

442
00:24:24.920 --> 00:24:28.490
running one database it stores its data

443
00:24:28.490 --> 00:24:31.690
pages and log just basically with this

444
00:24:31.690 --> 00:24:34.460
instead of on the local disk its stores

445
00:24:34.460 --> 00:24:36.349
them in EBS so whenever the database

446
00:24:40.970 --> 00:24:47.960
these two EBS volumes EBS replicas in

447
00:24:47.960 --> 00:24:50.180
addition so and so this is in one

448
00:24:50.180 --> 00:24:54.230
availability zone in addition for every

449
00:24:54.230 --> 00:24:55.910
write that the database software does

450
00:24:59.900 --> 00:25:03.890
was happened also send those rights to

451
00:25:07.759 --> 00:25:13.190
room - just going from figure 2 to

452
00:25:13.190 --> 00:25:14.960
apparently a separate computer or ec2

453
00:25:14.960 --> 00:25:16.730
instance or something whose job was just

454
00:25:16.730 --> 00:25:20.240
a mirror writes that the main database

455
00:25:20.240 --> 00:25:22.609
did so this other sort of mirroring

456
00:25:30.980 --> 00:25:33.170
with this set up with this RDS set up

457
00:25:44.750 --> 00:25:47.210
be sent on the network connection across

458
00:25:47.210 --> 00:25:49.490
the other availability zone on the other

459
00:25:49.490 --> 00:25:51.380
side of town sent to this mirroring

460
00:25:56.960 --> 00:25:59.210
finally this reply would come back and

461
00:25:59.210 --> 00:26:00.589
then only then with the right be

462
00:26:00.589 --> 00:26:03.589
finished with a DAT bc AHA my writes

463
00:26:08.269 --> 00:26:09.259
the log or whatever

464
00:26:09.259 --> 00:26:13.549
so this RDS arrangement gets you betcha

465
00:26:13.549 --> 00:26:14.960
better fault tolerance because now you

466
00:26:18.769 --> 00:26:21.140
latest writes in a separate availability

467
00:26:21.140 --> 00:26:23.660
zone even if you know fire burns down

468
00:26:23.660 --> 00:26:26.150
this entire data center boom you can

469
00:26:26.150 --> 00:26:28.670
weaken you can run the database in a new

470
00:26:28.670 --> 00:26:30.859
instance and the second availability

471
00:26:30.859 --> 00:26:36.640
zone and lose no data at all yes

472
00:26:45.349 --> 00:26:48.869
um I don't know how to answer that I

473
00:26:54.599 --> 00:26:56.279
most EVs customers it would be too

474
00:26:56.279 --> 00:26:58.500
painfully slow to forward every right

475
00:26:58.500 --> 00:27:02.400
across two separate data center I'm not

476
00:27:02.400 --> 00:27:04.289
really sure what's going on but I think

477
00:27:04.289 --> 00:27:06.539
the main answers they don't do that and

478
00:27:06.539 --> 00:27:09.869
this is sort of a a little bit of a

479
00:27:09.869 --> 00:27:11.880
workaround for the way EBS works too

480
00:27:11.880 --> 00:27:14.640
kind of tricky BS and actually producing

481
00:27:20.910 --> 00:27:24.269
chose this turns out to be extremely

482
00:27:24.269 --> 00:27:28.859
expensive or anyway it's expensive as

483
00:27:28.859 --> 00:27:29.430
you might think

484
00:27:29.430 --> 00:27:30.930
you know we're writing fairly large

485
00:27:30.930 --> 00:27:33.559
volumes of data because you know even

486
00:27:33.559 --> 00:27:36.599
this transaction which seems like it

487
00:27:36.599 --> 00:27:38.789
just modifies two integers like maybe

488
00:27:46.890 --> 00:27:49.710
writing the disk is I actually these log

489
00:27:49.710 --> 00:27:51.720
records are that also quite small so

490
00:27:51.720 --> 00:27:53.160
this these two log records might

491
00:27:57.359 --> 00:27:58.950
the actual data pages are likely to be

492
00:28:03.359 --> 00:28:05.519
is going to be you know eight kilobytes

493
00:28:05.519 --> 00:28:08.130
or 16 kilobytes or some relatively large

494
00:28:14.880 --> 00:28:17.400
write these two numbers when it comes

495
00:28:17.400 --> 00:28:19.559
time to update the data pages there's a

496
00:28:19.559 --> 00:28:21.119
lot of data being pushed around on to

497
00:28:21.119 --> 00:28:23.339
the disk a locally attached disk now

498
00:28:23.339 --> 00:28:26.460
it's reasonably fast but I guess what

499
00:28:26.460 --> 00:28:27.960
they found is when they start sending

500
00:28:27.960 --> 00:28:30.869
those big 8 kilobyte writes across the

501
00:28:30.869 --> 00:28:34.410
network that that used up too much

502
00:28:51.210 --> 00:28:56.309
so in this in this figure to set up the

503
00:28:56.309 --> 00:28:58.930
you know unknown to the database server

504
00:28:58.930 --> 00:29:02.470
every time it called write erode its EBS

505
00:29:02.470 --> 00:29:05.380
disk a copy of every write went over

506
00:29:05.380 --> 00:29:08.349
across availabilities zones and had to

507
00:29:08.349 --> 00:29:10.359
be written to the was written to the

508
00:29:10.359 --> 00:29:12.579
both of these EBS servers and then

509
00:29:12.579 --> 00:29:15.269
acknowledged and only then did the write

510
00:29:19.839 --> 00:29:22.269
copies to be updated and for the data to

511
00:29:22.269 --> 00:29:24.240
be sent on the link across to the other

512
00:29:24.240 --> 00:29:30.789
availability zone and you know as far as

513
00:29:30.789 --> 00:29:33.150
table one it's concerned that first

514
00:29:33.150 --> 00:29:37.980
performance table the reason why the

515
00:29:42.819 --> 00:29:45.579
sequel line is much much slower than the

516
00:29:45.579 --> 00:29:47.890
Aurora line is basically that it sends

517
00:29:47.890 --> 00:29:50.500
huge amounts of data over these

518
00:29:50.500 --> 00:29:52.599
relatively slow Network links and that

519
00:29:55.930 --> 00:29:57.759
this is good for fault tolerance because

520
00:30:05.579 --> 00:30:07.859
and the next step after this is Aurora

521
00:30:07.859 --> 00:30:14.319
and to set up there the high level view

522
00:30:14.319 --> 00:30:15.809
is we still have a database server

523
00:30:15.809 --> 00:30:18.549
although now it's running custom

524
00:30:18.549 --> 00:30:21.579
software that Amazon supplies so I can

525
00:30:21.579 --> 00:30:23.980
rent an Aurora server from Amazon but

526
00:30:23.980 --> 00:30:26.319
it's not I'm not running my software on

527
00:30:26.319 --> 00:30:28.779
it I'm renting a server running Amazon's

528
00:30:28.779 --> 00:30:32.259
Aurora database software on it rent an

529
00:30:32.259 --> 00:30:35.559
Aurora database server from them and

530
00:30:35.559 --> 00:30:38.500
it's it's just one instance it sits in

531
00:30:38.500 --> 00:30:44.680
some availability zone and there's two

532
00:30:44.680 --> 00:30:46.779
interesting things about the way it's

533
00:30:46.779 --> 00:30:52.269
set up first of all is that the data you

534
00:30:52.269 --> 00:30:54.690
know it's replacement basically for EBS

535
00:30:54.690 --> 00:30:59.640
involves six replicas now

536
00:30:59.640 --> 00:31:05.390
- in each of three availability zones

537
00:31:09.680 --> 00:31:12.180
for super fault tolerance and so every

538
00:31:12.180 --> 00:31:14.460
time the database complicated we'll talk

539
00:31:14.460 --> 00:31:15.930
but basically when the database writes

540
00:31:15.930 --> 00:31:19.579
or reads when the database writes it's

541
00:31:19.579 --> 00:31:22.710
we're not sure exactly how its managed

542
00:31:22.710 --> 00:31:24.900
but it more or less needs to send a

543
00:31:24.900 --> 00:31:27.299
write one way or another writes have to

544
00:31:27.299 --> 00:31:31.279
get sent to all six of these replicas

545
00:31:31.279 --> 00:31:33.839
the key to making and so this looks like

546
00:31:33.839 --> 00:31:35.369
more replicas gosh you know why isn't it

547
00:31:35.369 --> 00:31:37.589
slower why isn't it slower than this

548
00:31:37.589 --> 00:31:38.970
previous scheme which only had four

549
00:31:38.970 --> 00:31:41.190
replicas and the answer to that is that

550
00:31:41.190 --> 00:31:43.109
what's being the only thing being

551
00:31:43.109 --> 00:31:44.849
written over the network is the log

552
00:31:44.849 --> 00:31:47.190
records so that's really the key to

553
00:31:51.480 --> 00:31:58.130
it's just the log records log entries

554
00:31:58.130 --> 00:32:02.460
and as you can see you know a log entry

555
00:32:02.460 --> 00:32:04.200
here you know at least and this is a

556
00:32:08.220 --> 00:32:10.349
than a couple of dozen bytes needed to

557
00:32:10.349 --> 00:32:11.910
store the old value and the new value

558
00:32:11.910 --> 00:32:14.519
for the piece of data we're writing so

559
00:32:14.519 --> 00:32:16.250
the log entries tend to be quite small

560
00:32:16.250 --> 00:32:20.250
whereas when the database you know we

561
00:32:20.250 --> 00:32:21.390
had a database that thought it was

562
00:32:24.900 --> 00:32:26.940
enormous like doesn't really say in the

563
00:32:26.940 --> 00:32:28.170
paper I don't think that eight kilobytes

564
00:32:28.170 --> 00:32:31.500
or more so this set up here was sending

565
00:32:31.500 --> 00:32:33.539
for each transaction was sending

566
00:32:33.539 --> 00:32:36.569
multiple 8 kilobyte pages across to the

567
00:32:36.569 --> 00:32:38.759
replicas whereas this set up is just

568
00:32:43.769 --> 00:32:46.380
much smaller than 8k pages that it's a

569
00:32:46.380 --> 00:32:51.200
net performance win okay so that's one

570
00:32:51.200 --> 00:32:56.519
this is like one of their big insights

571
00:32:56.519 --> 00:32:58.740
is just in the log entries of course a

572
00:32:58.740 --> 00:33:00.480
fallout from this is that their storage

573
00:33:00.480 --> 00:33:01.950
system is now not very general purpose

574
00:33:01.950 --> 00:33:03.210
this is a storage system that

575
00:33:03.210 --> 00:33:06.569
understands what to do with my sequel

576
00:33:06.569 --> 00:33:09.299
log entries right it's not just you know

577
00:33:09.299 --> 00:33:11.640
EBS was a very general purpose just

578
00:33:11.640 --> 00:33:13.319
emulated to disk you read them right

579
00:33:13.319 --> 00:33:15.480
block's doesn't understand anything

580
00:33:15.480 --> 00:33:17.160
about anything except for blocks this is

581
00:33:17.160 --> 00:33:19.440
a storage system that really understands

582
00:33:19.440 --> 00:33:20.309
that it's sitting underneath the

583
00:33:20.309 --> 00:33:23.190
database so that's one thing they've

584
00:33:28.319 --> 00:33:31.519
specific storage system

585
00:33:31.529 --> 00:33:34.289
the other big thing I'll also go into in

586
00:33:34.289 --> 00:33:36.529
more detail is that they don't require

587
00:33:36.529 --> 00:33:40.710
that the rights be acknowledged by all

588
00:33:47.579 --> 00:33:49.650
server can continue as long as a quorum

589
00:33:49.650 --> 00:33:51.660
and which turns out to be for as long as

590
00:33:51.660 --> 00:33:54.569
any four of these servers responds so if

591
00:33:54.569 --> 00:33:57.349
one of these availability zones is

592
00:33:57.349 --> 00:33:59.970
offline or maybe the network connection

593
00:33:59.970 --> 00:34:02.160
to it is slow or maybe even just these

594
00:34:02.160 --> 00:34:04.349
servers just happen to be slow doing

595
00:34:04.349 --> 00:34:05.490
something else at the moment we're

596
00:34:05.490 --> 00:34:08.789
trying to write the database server can

597
00:34:08.789 --> 00:34:12.269
basically ignore the two slowest or the

598
00:34:12.269 --> 00:34:14.699
two most dead of the server's when it's

599
00:34:17.849 --> 00:34:19.829
and then it can continue and so this

600
00:34:19.829 --> 00:34:25.380
quorum scheme is the other big trick

601
00:34:25.380 --> 00:34:30.809
they use to help them have more replicas

602
00:34:30.809 --> 00:34:33.360
in more availability zones and yet not

603
00:34:33.360 --> 00:34:35.550
pay a huge performance penalty because

604
00:34:35.550 --> 00:34:36.840
they never have to wait for all of them

605
00:34:36.840 --> 00:34:39.690
just the four fastest of the six

606
00:34:39.690 --> 00:34:45.750
replicas so the rest of the lecture is

607
00:34:45.750 --> 00:34:47.699
gonna be explaining first quorums and

608
00:34:47.699 --> 00:34:49.679
then log entries and then this idea of

609
00:34:54.570 --> 00:34:56.849
table one by switching from this

610
00:34:56.849 --> 00:34:58.800
architecture in which they send the big

611
00:34:58.800 --> 00:35:02.969
data pages to four places to this Aurora

612
00:35:02.969 --> 00:35:04.800
schema sending just the log entries to

613
00:35:04.800 --> 00:35:08.579
six replicas they get a amazing 35 times

614
00:35:08.579 --> 00:35:11.670
performance increase over some other

615
00:35:11.670 --> 00:35:15.199
system you know this system over here

616
00:35:15.199 --> 00:35:17.489
but by playing these two tricks and

617
00:35:17.489 --> 00:35:19.159
paper is not very good about explaining

618
00:35:19.159 --> 00:35:21.300
how much of the performance is due to

619
00:35:21.300 --> 00:35:23.190
quorums and how much is due to just

620
00:35:23.190 --> 00:35:25.170
sending log entries but anyway you slice

621
00:35:25.170 --> 00:35:27.250
it 35

622
00:35:27.250 --> 00:35:31.329
times improvement performance is very

623
00:35:34.659 --> 00:35:37.659
and it's like transformative I am sure

624
00:35:46.690 --> 00:35:50.590
about in in detail is their quorum

625
00:35:55.179 --> 00:35:57.309
all about the arrangement of

626
00:35:57.309 --> 00:35:59.289
fault-tolerant of this fault-tolerant

627
00:35:59.289 --> 00:36:03.610
storage so it's worth thinking a little

628
00:36:03.610 --> 00:36:05.289
bit about what their fault tolerance

629
00:36:05.289 --> 00:36:09.760
goals were so this is like fault

630
00:36:09.760 --> 00:36:15.820
tolerance goals they wanted to be able

631
00:36:15.820 --> 00:36:18.969
to do rights even if one reads and

632
00:36:18.969 --> 00:36:21.760
writes even if one availability zone was

633
00:36:37.989 --> 00:36:40.780
able to read even if there was one dead

634
00:36:40.780 --> 00:36:43.599
availability zone plus one other dead

635
00:36:43.599 --> 00:36:46.929
server and the reason for this is that

636
00:36:46.929 --> 00:36:48.880
an availability zone might be offline

637
00:36:48.880 --> 00:36:50.860
for quite a while because maybe it's you

638
00:36:50.860 --> 00:36:52.780
know was suffered from a flood or

639
00:36:52.780 --> 00:36:54.969
something and while it's down for a

640
00:36:54.969 --> 00:36:56.559
couple of days or a week or something

641
00:36:56.559 --> 00:36:58.420
well people prepare the damage from the

642
00:36:58.420 --> 00:37:00.699
flood we're now reliant on just you know

643
00:37:00.699 --> 00:37:01.659
the servers and the other two

644
00:37:01.659 --> 00:37:03.550
availability zones if one of them should

645
00:37:03.550 --> 00:37:05.829
go down we still we don't want it to be

646
00:37:05.829 --> 00:37:09.250
a disaster so they're going to be able

647
00:37:16.750 --> 00:37:19.539
availability zone plus one other dead

648
00:37:19.539 --> 00:37:20.980
server so they wanted to be able to

649
00:37:20.980 --> 00:37:23.559
still read you know and get the correct

650
00:37:23.559 --> 00:37:26.500
data even if there was one dead

651
00:37:26.500 --> 00:37:28.510
availability zone plus one other server

652
00:37:28.510 --> 00:37:30.429
and the live availability zones were

653
00:37:30.429 --> 00:37:34.510
dead so you know they we have to sort of

654
00:37:34.510 --> 00:37:36.460
take take it for granted that they know

655
00:37:36.460 --> 00:37:38.679
what their they know their own business

656
00:37:38.679 --> 00:37:40.480
and that this is really

657
00:37:40.480 --> 00:37:43.130
you know kind of a sweet spot for how

658
00:37:43.130 --> 00:37:46.579
fault-tolerant you want to be um and in

659
00:37:46.579 --> 00:37:47.869
addition I already mentioned they want

660
00:37:47.869 --> 00:37:49.639
to be able to taller to sur ride out

661
00:37:49.639 --> 00:37:55.550
temporarily slow replicas I think from a

662
00:37:55.550 --> 00:37:58.940
lot of sources it's clear that the if

663
00:38:03.289 --> 00:38:04.610
all the time sometimes there's little

664
00:38:04.610 --> 00:38:06.320
glitches because maybe some part of the

665
00:38:06.320 --> 00:38:08.239
network is overloaded or something is

666
00:38:08.239 --> 00:38:10.789
doing a software upgrade or whatever and

667
00:38:10.789 --> 00:38:13.519
it's temporarily slow so they want to be

668
00:38:13.519 --> 00:38:15.349
able to just keep going despite

669
00:38:15.349 --> 00:38:21.349
transient transiently slow or maybe

670
00:38:21.349 --> 00:38:27.769
briefly unavailable storage servers and

671
00:38:27.769 --> 00:38:30.230
a final requirement is that if something

672
00:38:30.230 --> 00:38:33.800
if a storage server should fail it's a

673
00:38:33.800 --> 00:38:36.230
bit of a race against time before the

674
00:38:42.920 --> 00:38:44.449
not as favorable as you might hope

675
00:38:44.449 --> 00:38:47.269
because typically you buy basically

676
00:38:47.269 --> 00:38:50.659
because server failure is often not

677
00:38:56.719 --> 00:38:58.340
a much increased probability that

678
00:38:58.340 --> 00:39:00.409
another one of your servers will soon go

679
00:39:00.409 --> 00:39:03.320
down because it's identical Hardware may

680
00:39:03.320 --> 00:39:05.539
be bought from the same company came off

681
00:39:05.539 --> 00:39:07.519
the same production line one after

682
00:39:07.519 --> 00:39:09.650
another and so a flaw and one of them is

683
00:39:09.650 --> 00:39:11.719
extremely likely to be reflected in a

684
00:39:11.719 --> 00:39:14.570
flaw and another one so people always

685
00:39:17.329 --> 00:39:21.500
soon and in a system like this well it

686
00:39:21.500 --> 00:39:24.469
turns out in these quorum systems you

687
00:39:28.159 --> 00:39:31.460
not too many of the replicas fail so

688
00:39:31.460 --> 00:39:35.269
they really needed to have fast we

689
00:39:35.269 --> 00:39:37.130
replicate them that is of one server

690
00:39:37.130 --> 00:39:38.869
seems permanently dead we'd like to be

691
00:39:38.869 --> 00:39:41.179
able to generate a new replica as fast

692
00:39:41.179 --> 00:39:43.159
as possible from the remaining replicas

693
00:39:43.159 --> 00:39:46.989
I mean a fast food replication

694
00:39:57.860 --> 00:40:00.139
servers and you know what their failure

695
00:40:00.139 --> 00:40:01.429
character is too excited you know the

696
00:40:01.429 --> 00:40:03.590
failures how to recover and it's a

697
00:40:03.590 --> 00:40:05.389
completely separate topic what to do if

698
00:40:20.989 --> 00:40:22.400
database server on the new instance

699
00:40:22.400 --> 00:40:24.380
which is intense it's not what I'm

700
00:40:24.380 --> 00:40:25.429
talking about right now we'll talk about

701
00:40:25.429 --> 00:40:27.260
it a little bit later on right now it's

702
00:40:27.260 --> 00:40:29.480
just gonna build a storage system that's

703
00:40:36.590 --> 00:40:43.940
idea called quorums and for a little

704
00:40:43.940 --> 00:40:45.889
while now I'm going to describe the sort

705
00:40:52.940 --> 00:40:57.530
replicate quorum replication I'm gonna

706
00:41:05.300 --> 00:41:07.340
quorum quorum systems is to be able to

707
00:41:07.340 --> 00:41:10.820
build storage systems that provide fault

708
00:41:15.230 --> 00:41:18.110
replicas fail your that reads will still

709
00:41:18.110 --> 00:41:22.429
see the most recent writes and typically

710
00:41:22.429 --> 00:41:25.429
quorum systems are sort of simple

711
00:41:25.429 --> 00:41:28.219
readwrite systems put get systems and

712
00:41:33.139 --> 00:41:34.849
read you could have objects you can read

713
00:41:34.849 --> 00:41:36.349
an object or you can overwrite an entire

714
00:41:36.349 --> 00:41:38.360
object and so the idea is you have n

715
00:41:38.360 --> 00:41:48.260
replicas if you want to write or you

716
00:41:48.260 --> 00:41:49.699
have to get you have to in order to

717
00:41:49.699 --> 00:41:51.139
write you have to make sure your write

718
00:41:51.139 --> 00:41:53.929
is acknowledged by W where W is less

719
00:41:53.929 --> 00:41:58.699
than n of the replicas so W

720
00:41:58.699 --> 00:42:02.360
right you have to send each right to

721
00:42:02.360 --> 00:42:04.519
these W are the replicas and if you want

722
00:42:04.519 --> 00:42:07.550
to do a read you have to get input read

723
00:42:07.550 --> 00:42:13.570
information from at least our replicas

724
00:42:14.949 --> 00:42:20.239
and so a typical setup that's so well

725
00:42:20.239 --> 00:42:23.960
first of all the key thing here is that

726
00:42:23.960 --> 00:42:27.619
W and our have to be set relative to end

727
00:42:33.380 --> 00:42:36.260
necessarily overlap with any quorum of

728
00:42:36.260 --> 00:42:38.900
our servers that any future reader might

729
00:42:38.900 --> 00:42:42.130
read from and so what that means is that

730
00:42:52.969 --> 00:42:58.929
least one server with any our servers

731
00:42:58.929 --> 00:43:01.369
and so you might have three we can

732
00:43:01.369 --> 00:43:05.889
imagine there's three servers s1 s2 s3

733
00:43:10.130 --> 00:43:11.599
out a write maybe we want to set the

734
00:43:11.599 --> 00:43:15.829
value of our object to 23 well in order

735
00:43:15.829 --> 00:43:17.360
to do a write we need to get our new

736
00:43:17.360 --> 00:43:22.519
value on to at least W of the of the

737
00:43:22.519 --> 00:43:24.800
replicas let's say for this system that

738
00:43:24.800 --> 00:43:29.300
R and W are both equals 2 and n is equal

739
00:43:29.300 --> 00:43:32.420
to 3 that's the setup to do a write we

740
00:43:32.420 --> 00:43:35.179
need to get our new value onto a quorum

741
00:43:40.760 --> 00:43:43.280
both now know that the value of the of

742
00:43:43.280 --> 00:43:47.750
our data object is 23 if somebody comes

743
00:43:47.750 --> 00:43:51.139
along and reads or read it also requires

744
00:43:51.139 --> 00:43:53.150
that the reader check with at least a

745
00:43:53.150 --> 00:43:55.699
read quorum of the servers so that's

746
00:43:55.699 --> 00:43:58.820
also 2 in this set up so you know that

747
00:43:58.820 --> 00:44:00.650
quorum could include a server that

748
00:44:00.650 --> 00:44:02.510
didn't see the right but it has to

749
00:44:02.510 --> 00:44:03.829
include at least one other in order to

750
00:44:03.829 --> 00:44:07.489
get to so that means the any future read

751
00:44:07.489 --> 00:44:09.500
must for example consult both this

752
00:44:09.500 --> 00:44:11.269
server that didn't see the write plus at

753
00:44:11.269 --> 00:44:12.380
least one that did

754
00:44:12.380 --> 00:44:14.599
that is a requirement of right form must

755
00:44:14.599 --> 00:44:17.360
overlap in at least one server so any

756
00:44:17.360 --> 00:44:20.510
read must consult a server that saw any

757
00:44:20.510 --> 00:44:31.519
previous right now what's cool about

758
00:44:31.519 --> 00:44:34.429
this well actually there's still one

759
00:44:34.429 --> 00:44:38.150
critical missing piece here the reader

760
00:44:44.360 --> 00:44:46.670
question is how does a reader know which

761
00:44:46.670 --> 00:44:48.679
of the our results it got back from the

762
00:44:59.719 --> 00:45:01.670
different values it gets back it turns

763
00:45:01.670 --> 00:45:03.619
out not to work because we're only

764
00:45:03.619 --> 00:45:05.630
guaranteed that our reader overlaps of

765
00:45:05.630 --> 00:45:07.400
the writer in at most one server so that

766
00:45:07.400 --> 00:45:09.619
could mean that the correct value is

767
00:45:09.619 --> 00:45:11.420
only represented by one of the servers

768
00:45:11.420 --> 00:45:15.590
that the reader consulted and you know

769
00:45:15.590 --> 00:45:17.510
in a system with say six replicas you

770
00:45:17.510 --> 00:45:19.820
know you might have Reaper might be four

771
00:45:19.820 --> 00:45:23.389
you might get back for answers and only

772
00:45:23.389 --> 00:45:26.780
one of them is the answer that is the

773
00:45:35.750 --> 00:45:38.510
every right every time you do a right

774
00:45:38.510 --> 00:45:40.489
you need to accompany your new value

775
00:45:40.489 --> 00:45:42.860
with you know an increasing version

776
00:45:42.860 --> 00:45:45.679
number and then the reader it gets back

777
00:45:48.619 --> 00:45:51.320
only the highest version number I'm said

778
00:45:51.320 --> 00:45:53.389
that means that this 21 here

779
00:45:53.389 --> 00:45:57.789
you know maybe s2 had a old value of 20

780
00:45:57.789 --> 00:45:59.869
each of these needs to be tagged with a

781
00:45:59.869 --> 00:46:01.489
version number so maybe this is version

782
00:46:01.489 --> 00:46:03.380
number three this was also version

783
00:46:03.380 --> 00:46:04.610
number three because it came from the

784
00:46:04.610 --> 00:46:06.710
same original right and we're imagining

785
00:46:06.710 --> 00:46:08.480
that this server that didn't see the

786
00:46:08.480 --> 00:46:09.980
right is gonna have version number two

787
00:46:09.980 --> 00:46:11.449
then the reader gets back these two

788
00:46:11.449 --> 00:46:13.519
values these two version numbers fix the

789
00:46:23.480 --> 00:46:26.530
mind about Aurora for a moment

790
00:46:28.570 --> 00:46:33.349
okay furthermore if you can't talk to if

791
00:46:33.349 --> 00:46:35.719
you can't actually contact a quorum or a

792
00:46:35.719 --> 00:46:37.489
read or write you really just have to

793
00:46:45.199 --> 00:46:49.369
back up or connected again so the reason

794
00:46:49.369 --> 00:46:51.260
why this is preferable to something like

795
00:46:51.260 --> 00:46:54.530
chain replication is that it can easily

796
00:46:54.530 --> 00:46:59.869
ride out temporary dead or disconnected

797
00:46:59.869 --> 00:47:01.670
or slow servers so in fact the way it

798
00:47:01.670 --> 00:47:02.900
would work is that if you want to read

799
00:47:02.900 --> 00:47:04.789
or write if you want to write you would

800
00:47:08.780 --> 00:47:11.239
its version number to all of the servers

801
00:47:11.239 --> 00:47:13.429
to all n of the servers but only wait

802
00:47:21.320 --> 00:47:23.710
quorum for R of the servers to respond

803
00:47:23.710 --> 00:47:26.150
and that and because you only have to

804
00:47:26.150 --> 00:47:29.719
wait for are out of n of them that means

805
00:47:29.719 --> 00:47:31.639
that you can continue after the fastest

806
00:47:31.639 --> 00:47:35.480
are have responded or the fastest W and

807
00:47:43.239 --> 00:47:45.800
slow or dead servers is completely

808
00:47:45.800 --> 00:47:47.780
implicit there's nothing here or about

809
00:47:47.780 --> 00:47:49.610
oh we have to sort of make decisions

810
00:47:49.610 --> 00:47:51.860
about which servers are up or down or

811
00:47:51.860 --> 00:47:54.309
like the leaders or anything it just

812
00:47:54.309 --> 00:47:57.590
kind of automatically proceeds as long

813
00:47:57.590 --> 00:48:02.480
as the quorum is available so we get

814
00:48:02.480 --> 00:48:04.130
very smooth handling of dead or slow

815
00:48:04.130 --> 00:48:07.280
servers in addition there's not much

816
00:48:11.300 --> 00:48:14.269
the R and W to make either reads to

817
00:48:14.269 --> 00:48:17.570
favor either reads or writes so here we

818
00:48:17.570 --> 00:48:19.280
could actually say that well the right

819
00:48:19.280 --> 00:48:21.559
forum is three every write has to go to

820
00:48:21.559 --> 00:48:23.239
all three servers and in that case the

821
00:48:23.239 --> 00:48:26.690
read quorum can be want so you could if

822
00:48:26.690 --> 00:48:28.610
you wanted to favored reads with this

823
00:48:28.610 --> 00:48:31.610
setup you could have read equals one

824
00:48:31.610 --> 00:48:33.860
write equals three memories are much

825
00:48:33.860 --> 00:48:35.480
faster they only have to wait for one

826
00:48:38.840 --> 00:48:40.670
you could say that Oh any reader has to

827
00:48:40.670 --> 00:48:42.289
be from all of them but a writer only

828
00:48:42.289 --> 00:48:45.380
has to write one so I mean the only one

829
00:48:45.380 --> 00:48:48.400
server might have the latest value but

830
00:48:48.400 --> 00:48:53.989
readers have to consult all three but

831
00:48:53.989 --> 00:48:55.190
they're guaranteed that their three will

832
00:48:55.190 --> 00:48:57.380
overlap with this of course these

833
00:48:57.380 --> 00:49:00.380
particular values makes writes not fault

834
00:49:00.380 --> 00:49:02.659
tolerant and here reads not fault

835
00:49:02.659 --> 00:49:04.760
tolerant because all the server's have

836
00:49:04.760 --> 00:49:06.409
to be up so you probably wouldn't want

837
00:49:06.409 --> 00:49:08.150
to do this in real life you might have

838
00:49:08.150 --> 00:49:10.460
you would have as Knowle Rohrer does a

839
00:49:10.460 --> 00:49:13.309
larger number of servers and sort of

840
00:49:13.309 --> 00:49:15.590
intermediate numbers of vinum right

841
00:49:26.989 --> 00:49:30.679
one debt availability zone and read with

842
00:49:30.679 --> 00:49:32.510
one dead availability zone plus one

843
00:49:45.199 --> 00:49:48.139
3 so the W equals 4 means that it can do

844
00:49:48.139 --> 00:49:51.260
a write with one dead availability zone

845
00:49:54.769 --> 00:49:58.699
are enough to complete right the reform

846
00:49:58.699 --> 00:50:01.550
of 3 so 4 plus week so 7 so they

847
00:50:01.550 --> 00:50:04.190
definitely guaranteed overlap a read

848
00:50:04.190 --> 00:50:05.510
quorum of 3 means that even if one

849
00:50:05.510 --> 00:50:07.639
availability is zone is dead plus one

850
00:50:07.639 --> 00:50:09.559
more server the three remaining servers

851
00:50:15.199 --> 00:50:17.599
the system can do reads and as you know

852
00:50:17.599 --> 00:50:20.449
can reconstruct the confine the current

853
00:50:20.449 --> 00:50:21.980
state of the database but it can't do

854
00:50:21.980 --> 00:50:24.889
writes without further work so if they

855
00:50:24.889 --> 00:50:28.780
were in a situation where there was

856
00:50:28.840 --> 00:50:31.880
three dead servers there they have

857
00:50:31.880 --> 00:50:33.559
enough of a quorum to be able to read

858
00:50:33.559 --> 00:50:35.960
the data and reconstruct more cop more

859
00:50:35.960 --> 00:50:38.869
replicas but until they've created more

860
00:50:38.869 --> 00:50:41.719
replicas to basically replace these dead

861
00:50:41.719 --> 00:50:45.670
ones they can't serve as rights

862
00:50:47.789 --> 00:50:50.670
and also the quorum system as I

863
00:50:50.670 --> 00:50:52.980
explained before allows them to ride out

864
00:50:52.980 --> 00:51:02.690
these transient slow replicas all right

865
00:51:02.690 --> 00:51:07.199
as it happens as explained before what

866
00:51:07.199 --> 00:51:09.840
the rights in Aurora aren't really over

867
00:51:09.840 --> 00:51:12.889
writing objects as in a sort of classic

868
00:51:12.889 --> 00:51:16.949
quorum system what Aurora in fact its

869
00:51:22.679 --> 00:51:23.579
current law

870
00:51:23.579 --> 00:51:25.920
so the way it's using quorums is

871
00:51:25.920 --> 00:51:27.690
basically to say well when the database

872
00:51:27.690 --> 00:51:29.400
sends out our new log record because

873
00:51:29.400 --> 00:51:31.769
it's executing some transaction it needs

874
00:51:31.769 --> 00:51:33.780
to make sure that that log record is

875
00:51:33.780 --> 00:51:38.280
present on at least four of the store of

876
00:51:38.280 --> 00:51:40.829
its storage servers before it's allowed

877
00:51:40.829 --> 00:51:42.150
to proceed with the transaction are

878
00:51:42.150 --> 00:51:43.800
committed so that's really the meaning

879
00:51:43.800 --> 00:51:46.170
of its other Wars right porins is that

880
00:51:50.610 --> 00:51:52.590
replicas before the write can be

881
00:51:52.590 --> 00:52:01.500
considered to to have completed and when

882
00:52:01.500 --> 00:52:03.900
a when Aurora gets to the end of a

883
00:52:03.900 --> 00:52:05.820
transaction before it can reply to the

884
00:52:05.820 --> 00:52:07.530
client until the client tell the client

885
00:52:07.530 --> 00:52:08.789
a hi you know your transaction is

886
00:52:08.789 --> 00:52:10.849
committed and finished and durable

887
00:52:10.849 --> 00:52:14.130
Aurora has to wait for acknowledgments

888
00:52:14.130 --> 00:52:16.320
from a write quorum for each of the log

889
00:52:16.320 --> 00:52:18.510
records that made up that transaction

890
00:52:18.510 --> 00:52:24.599
and in fact because because if there

891
00:52:24.599 --> 00:52:25.980
were a crash in a recovery you're not

892
00:52:25.980 --> 00:52:30.260
allowed to recover one transaction if

893
00:52:30.260 --> 00:52:33.809
preceding transactions don't aren't also

894
00:52:33.809 --> 00:52:36.690
recovered in practice Aurora has before

895
00:52:36.690 --> 00:52:38.250
Aurora can acknowledge a transaction it

896
00:52:38.250 --> 00:52:42.690
has to wait for a write quorum of

897
00:52:42.690 --> 00:52:44.369
storage servers to respond for all

898
00:52:44.369 --> 00:52:46.590
previously committed transaction and the

899
00:52:46.590 --> 00:52:48.750
transaction of interest and then can

900
00:52:48.750 --> 00:52:51.800
respond to the client

901
00:52:54.739 --> 00:52:57.440
okay so these these storage servers are

902
00:52:57.440 --> 00:52:59.989
getting incoming log records

903
00:52:59.989 --> 00:53:02.869
that's what rights look like to them and

904
00:53:02.869 --> 00:53:04.219
so what do they actually do you know

905
00:53:04.219 --> 00:53:06.409
they're not getting new data pages from

906
00:53:06.409 --> 00:53:07.610
the database server they're just getting

907
00:53:07.610 --> 00:53:10.699
log records that just describe changes

908
00:53:22.369 --> 00:53:25.190
has internally it has copies of all that

909
00:53:25.190 --> 00:53:30.679
data of all the data pages at some point

910
00:53:30.679 --> 00:53:34.190
in the database data pages evolution so

911
00:53:34.190 --> 00:53:39.380
it has maybe in its cache on its disk a

912
00:53:39.380 --> 00:53:41.360
whole bunch of these pages you know page

913
00:53:41.360 --> 00:53:47.449
1 page 2 so forth when a new write comes

914
00:53:47.449 --> 00:53:52.820
in the storage server would win a new

915
00:53:52.820 --> 00:53:54.289
log rec over in a new write arrives

916
00:53:54.289 --> 00:53:56.599
carrying with it just a log record what

917
00:53:56.599 --> 00:53:58.400
has to happen some day but not right

918
00:53:58.400 --> 00:54:00.559
away is that the changes in that log

919
00:54:00.559 --> 00:54:02.780
record the new value here has to be

920
00:54:02.780 --> 00:54:05.480
applied to the relevant page but we

921
00:54:05.480 --> 00:54:06.650
don't at the source of it doesn't have

922
00:54:06.650 --> 00:54:09.110
to do that until someone asks just until

923
00:54:09.110 --> 00:54:11.239
the database server or the recovery

924
00:54:11.239 --> 00:54:13.519
software asks to see that page so

925
00:54:13.519 --> 00:54:15.440
immediately what happens to a new log

926
00:54:15.440 --> 00:54:17.510
record is that the log records are just

927
00:54:17.510 --> 00:54:20.210
appended to lists of log records that

928
00:54:20.210 --> 00:54:23.179
effect each page so for every page that

929
00:54:23.179 --> 00:54:26.510
the storage server stores if it's been

930
00:54:26.510 --> 00:54:29.269
recently modified by a log record by a

931
00:54:29.269 --> 00:54:31.309
transaction what the storage server will

932
00:54:37.460 --> 00:54:40.610
log records that have come in from trend

933
00:54:40.610 --> 00:54:42.739
from the database server since that page

934
00:54:42.739 --> 00:54:45.500
was last brought up to date so if

935
00:54:49.880 --> 00:54:53.570
of log records if the database server

936
00:54:53.570 --> 00:54:56.119
later you know fix the page from its

937
00:54:56.119 --> 00:54:58.309
cache and then needs to read the page

938
00:54:58.309 --> 00:55:00.440
again for a future transaction it'll

939
00:55:00.440 --> 00:55:03.139
send a read request out to one of the

940
00:55:03.139 --> 00:55:04.429
storage servers and say look you know I

941
00:55:04.429 --> 00:55:06.139
need a copy I need an updated copy a

942
00:55:06.139 --> 00:55:06.789
page one

943
00:55:12.820 --> 00:55:15.849
you know do do these writes of new data

944
00:55:19.389 --> 00:55:22.239
updated page back to the database server

945
00:55:29.829 --> 00:55:35.550
page although it's not quite that simple

946
00:55:35.760 --> 00:55:37.949
all right so the storage servers just

947
00:55:37.949 --> 00:55:41.289
store these strings of log records plus

948
00:55:41.289 --> 00:55:53.380
old log page versions now the database

949
00:55:53.380 --> 00:55:54.820
server as I mentioned sometimes needs to

950
00:55:54.820 --> 00:55:57.309
read pages so by the way one thing to

951
00:55:57.309 --> 00:55:58.659
observe is that the database server is

952
00:55:58.659 --> 00:56:00.969
writing log records but it's reading

953
00:56:00.969 --> 00:56:03.489
data pages so there's also different my

954
00:56:03.489 --> 00:56:05.619
corns poram system in the sense that the

955
00:56:05.619 --> 00:56:07.119
sort of things that are being read and

956
00:56:11.889 --> 00:56:16.840
the database server knows doesn't have

957
00:56:16.840 --> 00:56:20.469
to send quorum reads because the

958
00:56:20.469 --> 00:56:23.739
database server tracks for each one of

959
00:56:23.739 --> 00:56:27.309
the storage servers how far how much of

960
00:56:27.309 --> 00:56:29.829
the prefix of the log that storage

961
00:56:29.829 --> 00:56:32.170
server is actually received so the

962
00:56:32.170 --> 00:56:34.329
database server is keeping track of

963
00:56:37.929 --> 00:56:40.420
four five the database server sends that

964
00:56:40.420 --> 00:56:42.670
new log entries to all the storage

965
00:56:42.670 --> 00:56:44.230
servers the storage servers that receive

966
00:56:44.230 --> 00:56:45.909
them respond saying oh yeah I got log

967
00:56:45.909 --> 00:56:48.579
entries 79 and furthermore you know I

968
00:56:48.579 --> 00:56:51.280
have every log entry before 79 also the

969
00:56:51.280 --> 00:56:52.780
database server keeps track of these

970
00:56:52.780 --> 00:56:56.429
numbers how far each server has gotten

971
00:56:56.429 --> 00:56:59.429
or what the highest sort of contiguous

972
00:56:59.429 --> 00:57:02.349
log entry number is that each of the

973
00:57:02.349 --> 00:57:04.719
servers has gotten so that way when the

974
00:57:04.719 --> 00:57:06.400
database server needs to do a read it

975
00:57:06.400 --> 00:57:09.880
just picks a storage server that's up to

976
00:57:09.880 --> 00:57:12.880
date and sends the read request for the

977
00:57:12.880 --> 00:57:14.559
page it wants just to that storage

978
00:57:14.559 --> 00:57:18.550
server so the the database server does

979
00:57:18.550 --> 00:57:19.809
have to do quorum writes but it

980
00:57:19.809 --> 00:57:20.590
basically

981
00:57:20.590 --> 00:57:22.119
doesn't ordinarily have to do quorum

982
00:57:22.119 --> 00:57:23.980
reads and knows which of these storage

983
00:57:23.980 --> 00:57:25.119
servers are up to date and just reads

984
00:57:25.119 --> 00:57:27.250
from one of them so the reason I keep ur

985
00:57:27.250 --> 00:57:30.429
than they would be in a that just reads

986
00:57:30.429 --> 00:57:32.320
one copy of the page and doesn't have to

987
00:57:32.320 --> 00:57:36.360
go through the expense of a quorum read

988
00:57:36.449 --> 00:57:39.579
now it does sometimes use quorum reads

989
00:57:39.579 --> 00:57:41.860
it turns out that during crash recovery

990
00:57:41.860 --> 00:57:44.170
you know if the crash during crash

991
00:57:44.170 --> 00:57:46.809
recovery of the database server and so

992
00:57:46.809 --> 00:57:49.360
this is different from a crash recovery

993
00:57:49.360 --> 00:57:50.800
of the storage service if the database

994
00:57:50.800 --> 00:57:53.380
server itself sir crash in me because

995
00:57:53.380 --> 00:57:55.840
the it's running in an ec2 instance on

996
00:57:55.840 --> 00:57:57.489
some piece of hardware some real piece

997
00:57:57.489 --> 00:57:58.570
of hardware may be that piece of

998
00:57:58.570 --> 00:58:01.210
hardware suffers a failure the database

999
00:58:01.210 --> 00:58:02.949
server crashes there's some monitoring

1000
00:58:02.949 --> 00:58:04.510
infrastructure at Amazon that says oh

1001
00:58:04.510 --> 00:58:06.369
wait a minute you know the database the

1002
00:58:06.369 --> 00:58:08.170
Aurora database server over running for

1003
00:58:08.170 --> 00:58:12.900
a customer or whatever just crashed and

1004
00:58:12.900 --> 00:58:15.579
Amazon will automatically fire up a new

1005
00:58:20.769 --> 00:58:23.289
of tell it look your data is sitting on

1006
00:58:23.289 --> 00:58:26.409
this particular volume this set of

1007
00:58:26.409 --> 00:58:29.340
storage systems please clean up any

1008
00:58:34.840 --> 00:58:38.949
storage servers and continue so we have

1009
00:58:38.949 --> 00:58:44.460
to and that's the point at which Aurora

1010
00:58:44.460 --> 00:58:48.550
uses quorum logic for weeds because this

1011
00:58:48.550 --> 00:58:52.329
database server when the old when the

1012
00:58:52.329 --> 00:58:54.159
previous database server crashed it was

1013
00:58:54.159 --> 00:58:56.380
almost certainly partway through

1014
00:58:56.380 --> 00:58:59.230
executing some set of transactions so

1015
00:58:59.230 --> 00:59:00.519
the state of play at the time of the

1016
00:59:00.519 --> 00:59:01.989
crash was well it's completed some

1017
00:59:01.989 --> 00:59:03.550
transactions and committed them and

1018
00:59:03.550 --> 00:59:06.369
their log entries are on a quorum plus

1019
00:59:06.369 --> 00:59:09.579
it's in the middle of executing some

1020
00:59:09.579 --> 00:59:12.159
other set of transactions which also may

1021
00:59:12.159 --> 00:59:14.829
have log entries on on a quorum but

1022
00:59:14.829 --> 00:59:16.719
because a database server crashed midway

1023
00:59:16.719 --> 00:59:18.340
through those transactions they can

1024
00:59:18.340 --> 00:59:23.199
never be completed and for those

1025
00:59:23.199 --> 00:59:24.940
transactions that haven't completed in

1026
00:59:24.940 --> 00:59:27.639
addition there may be you know we may

1027
00:59:27.639 --> 00:59:30.880
have a situation in which you know maybe

1028
00:59:30.880 --> 00:59:33.309
log entry this server has log on three

1029
00:59:33.309 --> 00:59:33.789
hundred

1030
00:59:33.789 --> 00:59:36.940
and the Surrey has logon 302 and there's

1031
00:59:36.940 --> 00:59:41.320
a hundred and four somewhere but no you

1032
00:59:41.320 --> 00:59:42.730
know for I as yet uncommitted

1033
00:59:42.730 --> 00:59:44.469
transaction before the crash made me

1034
00:59:44.469 --> 00:59:48.670
know server got a copy of log entry 103

1035
00:59:48.670 --> 00:59:52.269
so after a crash and remember the new

1036
00:59:52.269 --> 00:59:54.610
database service recovering it does

1037
00:59:54.610 --> 00:59:56.590
quorum reads to basically find the point

1038
00:59:56.590 --> 00:59:59.469
in the log the highest log number for

1039
00:59:59.469 --> 01:00:02.530
which every preceding log entry exists

1040
01:00:02.530 --> 01:00:04.659
somewhere in the storage service so

1041
01:00:04.659 --> 01:00:07.389
basically it finds the first missing the

1042
01:00:07.389 --> 01:00:08.980
number of the first missing log entry

1043
01:00:08.980 --> 01:00:12.429
which is 103 and says well and so we're

1044
01:00:12.429 --> 01:00:14.469
missing a log entry we can't do anything

1045
01:00:14.469 --> 01:00:16.539
with a log after this point because

1046
01:00:16.539 --> 01:00:20.440
we're like missing an update so the

1047
01:00:20.440 --> 01:00:21.849
database server does these quorum reads

1048
01:00:21.849 --> 01:00:23.110
it finds a hundred and three is the

1049
01:00:23.110 --> 01:00:27.489
first entry that's MIT that's I can't

1050
01:00:27.489 --> 01:00:28.809
you know I look at my quorum the

1051
01:00:28.809 --> 01:00:31.119
server's I can reach and 103 is not

1052
01:00:31.119 --> 01:00:32.889
there and the database server will send

1053
01:00:32.889 --> 01:00:34.300
out a message to all the server saying

1054
01:00:34.300 --> 01:00:37.329
look please just discard every log entry

1055
01:00:37.329 --> 01:00:39.639
from 103 onwards and those mussels

1056
01:00:45.159 --> 01:00:46.869
transaction can't commit until all of

1057
01:00:46.869 --> 01:00:49.389
its entries are on a right corner so we

1058
01:00:49.389 --> 01:00:50.949
would be guaranteed to see them so we're

1059
01:00:50.949 --> 01:00:53.110
only discarding log entries from

1060
01:00:53.110 --> 01:00:58.210
uncommitted transactions of course so

1061
01:00:58.210 --> 01:00:59.440
we're sort of cutting off the log here

1062
01:00:59.440 --> 01:01:03.190
at login 302 these log entries that

1063
01:01:03.190 --> 01:01:04.929
we're preserving now may actually

1064
01:01:04.929 --> 01:01:07.300
include log entries from uncommitted

1065
01:01:07.300 --> 01:01:08.860
transactions from transactions that were

1066
01:01:08.860 --> 01:01:10.719
interrupted by the crash and the

1067
01:01:14.110 --> 01:01:16.480
know a certain transaction there's it

1068
01:01:16.480 --> 01:01:18.639
has update entries in the log but no

1069
01:01:18.639 --> 01:01:20.500
commit record the database server will

1070
01:01:20.500 --> 01:01:22.809
find the full set of those uncompleted

1071
01:01:22.809 --> 01:01:25.480
transactions and basically issue undo

1072
01:01:25.480 --> 01:01:28.329
operations I sort of knew log entries

1073
01:01:28.329 --> 01:01:32.730
that undo all of the changes that that

1074
01:01:32.730 --> 01:01:35.679
that those uncommitted transactions made

1075
01:01:35.679 --> 01:01:38.280
and you know that's the point at which

1076
01:01:38.280 --> 01:01:41.710
Aurora needs this these old values in

1077
01:01:41.710 --> 01:01:44.690
the log entries so that a

1078
01:01:44.690 --> 01:01:46.849
server that's doing recovery after a

1079
01:01:46.849 --> 01:01:49.760
crash can sort of back out of partially

1080
01:01:49.760 --> 01:02:00.400
completed transactions all right one

1081
01:02:23.900 --> 01:02:25.969
a computer with a disk or two or

1082
01:02:25.969 --> 01:02:28.610
something attached to it if this were

1083
01:02:32.329 --> 01:02:34.400
than the amount of storage that you

1084
01:02:34.400 --> 01:02:36.230
could put on a single machine there's

1085
01:02:39.320 --> 01:02:41.420
storage because each one I'm storing a

1086
01:02:41.420 --> 01:02:43.219
replica of the same old data again and

1087
01:02:43.219 --> 01:02:46.699
again and you know so I want to use

1088
01:02:46.699 --> 01:02:48.320
solid-state drives or something we can

1089
01:02:48.320 --> 01:02:50.929
put you know terabytes of storage on a

1090
01:02:50.929 --> 01:02:53.960
single machine but we can't put you know

1091
01:02:53.960 --> 01:02:55.460
hundreds of terabytes on a single

1092
01:02:55.460 --> 01:02:59.510
machine so in order to support customers

1093
01:03:12.969 --> 01:03:19.179
replicas so and the kind of unit of

1094
01:03:19.179 --> 01:03:21.289
sharding the unit of splitting up the

1095
01:03:21.289 --> 01:03:23.960
data I think is 10 gigabytes so a

1096
01:03:23.960 --> 01:03:25.909
database that needs 20 gigabytes of data

1097
01:03:25.909 --> 01:03:28.400
will use two protection groups these

1098
01:03:35.570 --> 01:03:41.239
servers of protection Group one and then

1099
01:03:41.239 --> 01:03:44.809
they'll be another six servers you know

1100
01:03:44.809 --> 01:03:46.639
possibly a different set of six storage

1101
01:03:46.639 --> 01:03:48.469
servers because Amazon's running and

1102
01:03:48.469 --> 01:03:49.820
like a huge fleet of these storage

1103
01:03:49.820 --> 01:03:51.769
servers that are jointly used by all of

1104
01:03:51.769 --> 01:03:54.739
its Aurora customers the second ten

1105
01:03:54.739 --> 01:03:57.679
gigabytes of the databases 20 gigabytes

1106
01:03:57.679 --> 01:03:58.250
of data

1107
01:03:58.250 --> 01:04:02.739
we'll be replicated on another set of

1108
01:04:02.739 --> 01:04:05.179
you know typically different I'll you

1109
01:04:05.179 --> 01:04:06.469
know there could be overlap between

1110
01:04:06.469 --> 01:04:08.719
these but typically just a different set

1111
01:04:08.719 --> 01:04:11.210
of six server so now we get 20 gigabytes

1112
01:04:11.210 --> 01:04:15.739
a day done and we have more of these as

1113
01:04:15.739 --> 01:04:18.889
a database goes bigger one interesting

1114
01:04:25.670 --> 01:04:28.909
pages and split them up over multiple

1115
01:04:28.909 --> 01:04:30.829
independent protection groups maybe you

1116
01:04:30.829 --> 01:04:32.449
know odd numbered data pages from your

1117
01:04:32.449 --> 01:04:35.389
b-tree go on PG one and even number

1118
01:04:40.639 --> 01:04:41.960
immediately obvious what to do with a

1119
01:04:41.960 --> 01:04:44.809
log all right how do you split up the

1120
01:04:44.809 --> 01:04:46.909
log if you have two of these two

1121
01:04:46.909 --> 01:04:48.619
protection groups or more in a mantra

1122
01:04:48.619 --> 01:04:52.159
tection group and the answer that amazon

1123
01:04:52.159 --> 01:04:54.139
does is that that that Aurora uses is

1124
01:04:54.139 --> 01:04:55.250
that the database server when it's

1125
01:04:55.250 --> 01:04:57.199
sending out a log record it looks at the

1126
01:04:57.199 --> 01:04:59.929
data that the log record modifies and

1127
01:04:59.929 --> 01:05:03.619
figures out which protection groups

1128
01:05:03.619 --> 01:05:06.260
store that data and it sends each log

1129
01:05:06.260 --> 01:05:08.239
record just to the protection groups

1130
01:05:08.239 --> 01:05:11.360
that store data that's mentioned that's

1131
01:05:11.360 --> 01:05:14.539
modified in the log entry and so that

1132
01:05:14.539 --> 01:05:16.730
means that each of these protection

1133
01:05:16.730 --> 01:05:19.429
groups store some fraction of the data

1134
01:05:19.429 --> 01:05:22.340
pages plus all the log records that

1135
01:05:22.340 --> 01:05:25.280
apply to those data pages see these

1136
01:05:25.280 --> 01:05:27.139
protection groups stores a subset of a

1137
01:05:27.139 --> 01:05:36.289
log that's relevant to its pages so a

1138
01:05:36.289 --> 01:05:41.449
final maybe I erase the photons

1139
01:05:41.449 --> 01:05:43.820
requirements but a final requirement is

1140
01:05:43.820 --> 01:05:48.260
that if a if ass one of these storage

1141
01:05:48.260 --> 01:05:50.599
servers crashes we want to be able to

1142
01:05:55.400 --> 01:05:57.500
then we risk maybe three of them are

1143
01:05:57.500 --> 01:05:58.849
four of them crashing and a four of them

1144
01:05:58.849 --> 01:06:01.550
crash then we actually can't recover

1145
01:06:01.550 --> 01:06:02.750
because then we don't have a reform

1146
01:06:02.750 --> 01:06:05.989
anymore so we need to regain replication

1147
01:06:11.480 --> 01:06:13.699
which server is storing 10 gigabytes for

1148
01:06:13.699 --> 01:06:15.619
you know my databases protection group

1149
01:06:15.619 --> 01:06:17.809
but in fact the physical thing you know

1150
01:06:17.809 --> 01:06:19.429
the physical setup of any one of these

1151
01:06:19.429 --> 01:06:21.530
servers is that it has a you know maybe

1152
01:06:21.530 --> 01:06:23.329
a one or two or something

1153
01:06:23.329 --> 01:06:26.900
terabyte disk on it that's storing 10

1154
01:06:26.900 --> 01:06:31.369
gigabyte segments of a hundred or more

1155
01:06:31.369 --> 01:06:34.670
different Aurora instances so what's

1156
01:06:34.670 --> 01:06:37.460
what's on this physical machine is you

1157
01:06:37.460 --> 01:06:39.409
know 10 terabyte era byte or 10

1158
01:06:39.409 --> 01:06:42.110
terabytes or whatever of data in total

1159
01:06:42.110 --> 01:06:44.539
so when there's a when one of these

1160
01:06:44.539 --> 01:06:47.599
storage servers crashes it's taking with

1161
01:06:47.599 --> 01:06:50.630
it not just the 10 gigabytes from my

1162
01:06:50.630 --> 01:06:53.360
database but also 10 gigabytes from a

1163
01:06:53.360 --> 01:06:55.309
hundred other people's databases as well

1164
01:07:18.440 --> 01:07:19.730
second network interface from one

1165
01:07:19.730 --> 01:07:22.420
machine to another it's gonna take I

1166
01:07:22.420 --> 01:07:25.219
don't know a thousand seconds ten

1167
01:07:25.219 --> 01:07:26.929
thousand seconds maybe ten thousand

1168
01:07:32.239 --> 01:07:34.579
you know it we don't want to have a

1169
01:07:41.630 --> 01:07:43.610
everything on it and had that machine

1170
01:07:43.610 --> 01:07:46.940
send 10 terabytes to a replacement

1171
01:07:46.940 --> 01:07:48.409
machine we're gonna be able to

1172
01:07:52.849 --> 01:07:56.449
that if I have a particular storage

1173
01:07:56.449 --> 01:07:57.610
server

1174
01:07:57.610 --> 01:08:01.849
it stores many many segments you know

1175
01:08:01.849 --> 01:08:04.429
replicas of many 10 gigabyte protection

1176
01:08:04.429 --> 01:08:07.480
groups so maybe this protection group

1177
01:08:07.480 --> 01:08:09.829
maybe this segment that it's storing

1178
01:08:09.829 --> 01:08:12.829
data for the other envy for this one the

1179
01:08:12.829 --> 01:08:17.479
other replicas are you know these five

1180
01:08:17.479 --> 01:08:19.819
other machines all right so these are

1181
01:08:19.819 --> 01:08:22.600
all storing

1182
01:08:26.319 --> 01:08:27.699
ones that we're also storing so I mean

1183
01:08:27.699 --> 01:08:29.289
we may be this particular machine also

1184
01:08:29.289 --> 01:08:33.579
stores a replica for protecting group B

1185
01:08:33.579 --> 01:08:36.130
but the other copies of the data for B

1186
01:08:36.130 --> 01:08:38.979
are going to be put on a disjoint set of

1187
01:08:38.979 --> 01:08:41.439
servers right so now there's five

1188
01:08:41.439 --> 01:08:43.270
servers that have the other copies of B

1189
01:08:43.270 --> 01:08:48.789
and so on for all of the segments that

1190
01:08:48.789 --> 01:08:50.439
this server that are sitting on this

1191
01:08:50.439 --> 01:08:52.420
storage servers hard drive for you know

1192
01:08:52.420 --> 01:08:55.569
many many different Aurora instances so

1193
01:08:55.569 --> 01:08:57.180
that means that this machine goes down

1194
01:08:57.180 --> 01:09:00.340
the replacement strategy is that we pick

1195
01:09:00.340 --> 01:09:01.899
if we're say we're storing a hundred of

1196
01:09:09.460 --> 01:09:13.449
is gonna pick up one new segment that is

1197
01:09:13.449 --> 01:09:14.949
each of which is going to now be

1198
01:09:14.949 --> 01:09:17.170
participating in one more protection

1199
01:09:22.810 --> 01:09:24.640
gigabytes segments and now we have you

1200
01:09:24.640 --> 01:09:28.239
know maybe 100 sort of different segment

1201
01:09:28.239 --> 01:09:29.439
servers and you know I probably storing

1202
01:09:29.439 --> 01:09:30.789
other stuff but they have a little bit

1203
01:09:30.789 --> 01:09:32.560
of free disk space and then for each of

1204
01:09:32.560 --> 01:09:35.859
these we pick one machine one of the

1205
01:09:35.859 --> 01:09:38.140
replicas that we're going to copy the

1206
01:09:38.140 --> 01:09:39.909
data from one of the remaining replicas

1207
01:09:39.909 --> 01:09:41.409
so maybe for a we're going to copy from

1208
01:09:41.409 --> 01:09:43.750
there for B from here you know if we

1209
01:09:43.750 --> 01:09:47.739
have five other copies with C we pick a

1210
01:09:47.739 --> 01:09:50.890
different server for C and so we have we

1211
01:09:50.890 --> 01:09:53.409
copy a from this server to that server

1212
01:09:53.409 --> 01:09:57.850
and B like this and C like this and so

1213
01:09:57.850 --> 01:10:01.750
now we have a hundred different 10

1214
01:10:01.750 --> 01:10:03.960
gigabyte copies going on in parallel

1215
01:10:03.960 --> 01:10:07.359
across the network and assuming you know

1216
01:10:07.359 --> 01:10:09.369
we have enough servers that these can

1217
01:10:14.890 --> 01:10:17.850
connects them now we can copy our

1218
01:10:17.850 --> 01:10:20.140
terabyte or 10 terabytes or whatever of

1219
01:10:20.140 --> 01:10:23.109
data and total in parallel with a

1220
01:10:23.109 --> 01:10:25.569
hundredfold parallelism and the whole

1221
01:10:25.569 --> 01:10:27.489
thing will take you know 10 seconds or

1222
01:10:27.489 --> 01:10:29.289
something instead of taking a thousand

1223
01:10:29.289 --> 01:10:30.729
seconds if there were just two machines

1224
01:10:30.729 --> 01:10:34.449
involved anyway so this is

1225
01:10:34.449 --> 01:10:35.739
this is the strategies they use and it

1226
01:10:39.699 --> 01:10:41.680
parallel from one machine's death

1227
01:10:41.680 --> 01:10:45.340
extremely quickly if lots of machines

1228
01:10:50.380 --> 01:10:52.180
replicate from single machine crashes

1229
01:10:52.180 --> 01:10:58.119
extremely quickly alright so a final

1230
01:10:58.119 --> 01:10:59.829
thing that the paper mentions if you

1231
01:10:59.829 --> 01:11:02.949
look at figure three you'll see that not

1232
01:11:02.949 --> 01:11:06.279
only do they have this main database but

1233
01:11:06.279 --> 01:11:09.880
they also have replica databases so for

1234
01:11:09.880 --> 01:11:12.130
many of their customers many of their

1235
01:11:12.130 --> 01:11:14.829
customers see far more read-only queries

1236
01:11:14.829 --> 01:11:17.619
than they see readwrite queries that is

1237
01:11:17.619 --> 01:11:19.210
if you think about a web server if you

1238
01:11:19.210 --> 01:11:21.220
just view a web page on some website

1239
01:11:25.720 --> 01:11:28.149
and stuff in order to generate all the

1240
01:11:28.149 --> 01:11:30.189
things that are shown on the page to you

1241
01:11:33.970 --> 01:11:35.500
of some database but the number of

1242
01:11:35.500 --> 01:11:37.630
writes for a typical web page view is

1243
01:11:37.630 --> 01:11:39.340
usually much much smaller maybe some

1244
01:11:39.340 --> 01:11:41.260
statistics have to be updated or a

1245
01:11:41.260 --> 01:11:42.640
little bit of history for you or

1246
01:11:42.640 --> 01:11:44.439
something so you might have a hundred to

1247
01:11:44.439 --> 01:11:48.399
one ratio of reads to writes that is you

1248
01:11:48.399 --> 01:11:50.739
may typically have a large large large

1249
01:11:50.739 --> 01:11:54.520
number of straight read only database

1250
01:11:54.520 --> 01:11:57.729
queries now with this set up the writes

1251
01:11:57.729 --> 01:11:59.890
can only go through the one database

1252
01:11:59.890 --> 01:12:01.149
server because we really can only

1253
01:12:01.149 --> 01:12:03.130
support one writer for this storage

1254
01:12:07.479 --> 01:12:09.489
there is that the log entries have to be

1255
01:12:09.489 --> 01:12:11.770
numbered sequentially and that's easy to

1256
01:12:11.770 --> 01:12:13.479
do if all the writes go through a single

1257
01:12:13.479 --> 01:12:15.460
server and extremely difficult if we

1258
01:12:15.460 --> 01:12:17.439
have lots of different servers all sort

1259
01:12:21.880 --> 01:12:24.329
have to be go through one database but

1260
01:12:24.329 --> 01:12:27.430
we could set up and indeed Amazon does

1261
01:12:27.430 --> 01:12:29.470
set up a situation where we have read

1262
01:12:29.470 --> 01:12:32.710
only database replicas that can read

1263
01:12:32.710 --> 01:12:35.470
from these storage servers and so the

1264
01:12:35.470 --> 01:12:38.529
full glory of figure three is that in

1265
01:12:38.529 --> 01:12:40.720
addition to the main database server

1266
01:12:40.720 --> 01:12:42.880
that handles the write requests there's

1267
01:12:42.880 --> 01:12:48.279
also a set of read-only

1268
01:12:48.279 --> 01:12:50.960
databases and they say they can support

1269
01:12:56.510 --> 01:12:58.850
workload a lot of it can be you know

1270
01:12:58.850 --> 01:13:01.189
most of it can be sort of hived off to a

1271
01:13:01.189 --> 01:13:02.960
whole bunch of these read-only databases

1272
01:13:02.960 --> 01:13:05.449
and when a client sends a read request

1273
01:13:05.449 --> 01:13:07.159
to read only database what happens is

1274
01:13:07.159 --> 01:13:09.470
the read only database figures out you

1275
01:13:09.470 --> 01:13:11.779
know what data pages it needs to serve

1276
01:13:11.779 --> 01:13:14.119
that request and sends reads into the

1277
01:13:14.119 --> 01:13:15.920
directly into the storage system without

1278
01:13:15.920 --> 01:13:21.500
bothering the main readwrite database so

1279
01:13:21.500 --> 01:13:23.180
the the read-only replica database

1280
01:13:23.180 --> 01:13:25.640
ascend page requests read requests

1281
01:13:25.640 --> 01:13:27.560
directly the storage servers and then

1282
01:13:27.560 --> 01:13:31.489
they'll be no cache those pages so that

1283
01:13:31.489 --> 01:13:33.680
they can you know respond to future read

1284
01:13:33.680 --> 01:13:35.810
requests right out of their cache of

1285
01:13:35.810 --> 01:13:36.829
course they need to be able to update

1286
01:13:36.829 --> 01:13:40.369
those caches and for that reason Aurora

1287
01:13:40.369 --> 01:13:43.279
also the main database sends a copy of

1288
01:13:43.279 --> 01:13:46.789
its log to each of the read-only

1289
01:13:46.789 --> 01:13:49.130
databases and that's the horizontal

1290
01:13:49.130 --> 01:13:51.260
lines you see between the blue boxes and

1291
01:13:51.260 --> 01:13:52.970
figure three that the main database

1292
01:13:52.970 --> 01:13:55.489
sends all the log entries do these mean

1293
01:13:55.489 --> 01:13:57.550
only databases which they use to update

1294
01:13:57.550 --> 01:14:03.739
their cached copies to reflect recent

1295
01:14:03.739 --> 01:14:05.420
transactions in the database and it

1296
01:14:05.420 --> 01:14:07.939
means it does mean that the read only

1297
01:14:07.939 --> 01:14:09.529
database is lag a little bit behind the

1298
01:14:09.529 --> 01:14:12.260
main database but it turns out for a lot

1299
01:14:12.260 --> 01:14:13.819
of read-only workloads that's okay if

1300
01:14:13.819 --> 01:14:15.649
you look at a web page and it's you know

1301
01:14:15.649 --> 01:14:17.329
20 milliseconds out of date that's

1302
01:14:17.329 --> 01:14:24.229
usually not a big problem there are some

1303
01:14:24.229 --> 01:14:26.750
complexities from this like one problem

1304
01:14:26.750 --> 01:14:28.340
is that we don't want these relay

1305
01:14:34.310 --> 01:14:36.979
of log entries the database may need to

1306
01:14:36.979 --> 01:14:39.470
be sort of denotes which transactions

1307
01:14:43.510 --> 01:14:44.800
uncommon

1308
01:14:44.800 --> 01:14:47.869
uncommitted transactions to their caches

1309
01:14:47.869 --> 01:14:49.670
they wait till the transactions commit

1310
01:14:49.670 --> 01:14:54.770
the other complexity that these

1311
01:14:54.770 --> 01:14:59.409
read-only replicas impose is that

1312
01:14:59.409 --> 01:15:03.430
the the the these structures he of these

1313
01:15:03.430 --> 01:15:05.380
andhe structures are quite complex this

1314
01:15:05.380 --> 01:15:06.670
might be a b-tree it might need to be

1315
01:15:06.670 --> 01:15:09.520
rebalanced periodically for example I'm

1316
01:15:09.520 --> 01:15:10.720
the rebalancing is quite a complex

1317
01:15:10.720 --> 01:15:12.430
operation in which a lot of the tree has

1318
01:15:12.430 --> 01:15:15.579
to be modified in atomically and so the

1319
01:15:15.579 --> 01:15:17.350
tree is incorrect while it's being be

1320
01:15:21.520 --> 01:15:23.949
these read-only replicas directly read

1321
01:15:23.949 --> 01:15:25.390
the pages out of the database there's a

1322
01:15:25.390 --> 01:15:28.119
risk they might see the be tree that the

1323
01:15:28.119 --> 01:15:30.189
database that's being stored here in

1324
01:15:30.189 --> 01:15:31.810
these data pages they may see the bee

1325
01:15:43.359 --> 01:15:45.640
paper talks about mini transactions and

1326
01:15:45.640 --> 01:15:49.720
the vdl verses vcl distinction what it's

1327
01:15:49.720 --> 01:15:51.760
talking about is the machinery by which

1328
01:15:51.760 --> 01:15:54.699
the database server can tell the storage

1329
01:15:54.699 --> 01:15:57.550
servers look this complex sequence of

1330
01:15:57.550 --> 01:16:02.560
log entries must only be revealed all or

1331
01:16:02.560 --> 01:16:04.689
nothing' atomically to any read-only

1332
01:16:04.689 --> 01:16:07.420
transactions that's what the mini

1333
01:16:07.420 --> 01:16:09.250
transactions and VDL are about and

1334
01:16:09.250 --> 01:16:10.779
basically the read when a read only

1335
01:16:10.779 --> 01:16:13.600
database asks to see data a data page

1336
01:16:13.600 --> 01:16:15.579
from a storage server the storage server

1337
01:16:15.579 --> 01:16:17.800
is careful to either show it data from

1338
01:16:17.800 --> 01:16:20.649
just before one of these sequence many

1339
01:16:20.649 --> 01:16:23.739
transaction sequences of log entries or

1340
01:16:23.739 --> 01:16:28.630
just after but not in the middle all

1341
01:16:28.630 --> 01:16:33.369
right so that's the all the technical

1342
01:16:33.369 --> 01:16:34.840
stuff I have to talk about just to kind

1343
01:16:34.840 --> 01:16:36.430
of summarize what's interesting about

1344
01:16:36.430 --> 01:16:37.720
the paper and what can be learned from

1345
01:16:37.720 --> 01:16:41.470
the paper one thing to learn which is

1346
01:16:41.470 --> 01:16:43.539
just good in general not specific to

1347
01:16:43.539 --> 01:16:45.399
this paper but everybody in systems

1348
01:16:45.399 --> 01:16:48.359
should know is the basics of how

1349
01:16:48.359 --> 01:16:50.619
transaction processing databases work

1350
01:16:50.619 --> 01:16:53.520
and the sort of impact that the

1351
01:16:53.520 --> 01:16:55.920
interaction between transaction

1352
01:16:55.920 --> 01:16:58.449
processing databases and the storage

1353
01:16:58.449 --> 01:17:00.340
systems because this comes up a lot it's

1354
01:17:00.340 --> 01:17:01.899
like a pervasive you know the

1355
01:17:01.899 --> 01:17:05.159
performance and crash recoverability

1356
01:17:05.159 --> 01:17:07.239
complexity of running a real database

1357
01:17:13.210 --> 01:17:15.819
this paper is this idea of quorums and

1358
01:17:15.819 --> 01:17:18.699
overlap the technique of overlapping

1359
01:17:18.699 --> 01:17:20.949
read/write quorums in order to always be

1360
01:17:20.949 --> 01:17:22.539
able to see the latest data but also get

1361
01:17:22.539 --> 01:17:24.250
fault tolerance and of course this comes

1362
01:17:24.250 --> 01:17:27.250
up in raft also raft has a strong kind

1363
01:17:31.569 --> 01:17:33.760
paper is that the database and the

1364
01:17:33.760 --> 01:17:35.829
storage system are basically Co designed

1365
01:17:35.829 --> 01:17:37.869
as kind of an integrated there's

1366
01:17:37.869 --> 01:17:39.460
integration across the database layer

1367
01:17:39.460 --> 01:17:41.170
and the storage layer or nearly

1368
01:17:41.170 --> 01:17:43.479
redesigned to try to design systems so

1369
01:17:43.479 --> 01:17:45.369
they have you know good separation

1370
01:17:45.369 --> 01:17:49.180
between consumers of services and the

1371
01:17:49.180 --> 01:17:50.770
sort of infrastructure services like

1372
01:17:50.770 --> 01:17:52.840
typically storage is very

1373
01:17:52.840 --> 01:17:54.880
general-purpose not aimed at a

1374
01:17:54.880 --> 01:17:57.779
particular application just you know

1375
01:18:01.930 --> 01:18:03.460
can be made of the same infrastructure

1376
01:18:03.460 --> 01:18:06.100
but here the performance issues were so

1377
01:18:06.100 --> 01:18:07.359
extreme you know they would have to get

1378
01:18:07.359 --> 01:18:09.819
a 35 times performance improvement by

1379
01:18:09.819 --> 01:18:13.539
sort of blurring this boundary this was

1380
01:18:13.539 --> 01:18:14.829
a situation in which general-purpose

1381
01:18:14.829 --> 01:18:16.899
storage was actually really not

1382
01:18:16.899 --> 01:18:19.260
advantageous and they got a big win by

1383
01:18:19.260 --> 01:18:22.930
abandoning that idea and a final set of

1384
01:18:22.930 --> 01:18:24.539
things to get out of the papers all the

1385
01:18:24.539 --> 01:18:26.770
interesting sometimes kind of implicit

1386
01:18:32.560 --> 01:18:35.319
really know what they're doing about

1387
01:18:35.319 --> 01:18:37.300
what concerns they had about cloud

1388
01:18:42.970 --> 01:18:45.609
entire availability zone might fail it's

1389
01:18:45.609 --> 01:18:48.250
an important tidbit the fact that

1390
01:18:48.250 --> 01:18:51.550
transient slowness of individual storage

1391
01:18:51.550 --> 01:18:53.979
servers was important is another thing

1392
01:18:53.979 --> 01:18:57.720
that actually also comes up a lot and

1393
01:18:57.720 --> 01:19:00.489
finally the implication that the network

1394
01:19:00.489 --> 01:19:02.529
is the main bottleneck because after all

1395
01:19:02.529 --> 01:19:04.659
they were it went to extreme lengths to

1396
01:19:04.659 --> 01:19:06.609
send less data over the network

1397
01:19:10.810 --> 01:19:12.609
willing to you know 6 copies the data

1398
01:19:12.609 --> 01:19:16.800
and have 6 CPUs all replicating the

1399
01:19:16.800 --> 01:19:19.479
execution of applying these redo log

1400
01:19:19.479 --> 01:19:21.399
entries apparently CPU is relatively

1401
01:19:21.399 --> 01:19:24.460
cheap for them whereas the network

1402
01:19:24.460 --> 01:19:26.560
capacity was extremely important

1403
01:19:26.560 --> 01:19:31.630
all right that's all I have to say and

