WEBVTT

1
00:00:00.670 --> 00:00:06.969
all right well let's get started

2
00:00:06.969 --> 00:00:10.490
today and indeed today and tomorrow I'm

3
00:00:10.490 --> 00:00:14.330
gonna talk about raft both because I

4
00:00:14.330 --> 00:00:16.239
hope it'll be helpful you for you in

5
00:00:16.239 --> 00:00:19.339
implanting though the labs and also

6
00:00:19.339 --> 00:00:21.649
because you know it's just a case study

7
00:00:21.649 --> 00:00:23.210
in the details of how to get state

8
00:00:23.210 --> 00:00:28.550
machine replication correct so we have

9
00:00:33.950 --> 00:00:35.799
systems that we've looked at so far

10
00:00:35.799 --> 00:00:40.640
one is that MapReduce replicates

11
00:00:40.640 --> 00:00:43.640
computation but the replication is

12
00:00:43.640 --> 00:00:45.950
controlled the whole computation is

13
00:00:45.950 --> 00:00:50.119
controlled by a single master another

14
00:00:50.119 --> 00:00:52.130
example I'd like to draw your attention

15
00:00:52.130 --> 00:00:55.340
to is that GFS replicates data right as

16
00:00:55.340 --> 00:00:56.780
this primary backup scheme for

17
00:00:56.780 --> 00:00:58.549
replicating the actual contents of files

18
00:00:58.549 --> 00:01:01.490
but it relies on a single master to

19
00:01:01.490 --> 00:01:03.710
choose who the primary is for every

20
00:01:03.710 --> 00:01:07.909
piece of data another example vmware ft

21
00:01:07.909 --> 00:01:09.709
replicates computational write on a

22
00:01:09.709 --> 00:01:11.840
primary virtual machine and a backup

23
00:01:11.840 --> 00:01:14.629
virtual machine but in order to figure

24
00:01:14.629 --> 00:01:16.250
out what to do next if one of them seems

25
00:01:16.250 --> 00:01:19.189
to a fail it relies on a single test and

26
00:01:23.719 --> 00:01:26.180
of the backup takes over if there's some

27
00:01:26.180 --> 00:01:29.390
kind of failure so in all three of these

28
00:01:29.390 --> 00:01:31.819
cases sure there was a replication

29
00:01:31.819 --> 00:01:34.219
system but sort of tucked away in a

30
00:01:37.879 --> 00:01:40.189
was required to make a critical decision

31
00:01:40.189 --> 00:01:43.549
about who the primary was in the cases

32
00:01:43.549 --> 00:01:47.209
we care about so a very nice thing about

33
00:01:47.209 --> 00:01:50.120
having a single entity decide who's

34
00:01:50.120 --> 00:01:53.120
gonna be the primary is that it can't

35
00:01:53.120 --> 00:01:55.459
disagree with itself right there's only

36
00:01:55.459 --> 00:01:57.620
one of it makes some decision that's the

37
00:01:57.620 --> 00:02:00.920
decision it made but the bad thing about

38
00:02:04.849 --> 00:02:06.590
single point of failure and so you can

39
00:02:06.590 --> 00:02:08.120
view these systems that we've looked at

40
00:02:08.120 --> 00:02:11.949
it sort of pushing the real heart of the

41
00:02:11.949 --> 00:02:13.789
fault tolerance

42
00:02:13.789 --> 00:02:16.610
Machinery into a little corner that is

43
00:02:16.610 --> 00:02:18.620
the single entity that decides who's

44
00:02:18.620 --> 00:02:20.719
going to be the primary if there's a

45
00:02:20.719 --> 00:02:23.810
failure now this whole thing is about

46
00:02:23.810 --> 00:02:25.430
how to avoid split brain the reason why

47
00:02:25.430 --> 00:02:27.560
we have to have have to be extremely

48
00:02:27.560 --> 00:02:29.990
careful about making the decision about

49
00:02:29.990 --> 00:02:31.520
who should be the primary if there's a

50
00:02:31.520 --> 00:02:33.949
failure is that otherwise we risks split

51
00:02:45.110 --> 00:02:47.240
problem is and why it's a serious

52
00:02:47.240 --> 00:02:49.990
problem so supposing for example where

53
00:02:49.990 --> 00:02:52.939
we want to build ourselves a replicated

54
00:02:52.939 --> 00:02:54.409
test and set server that is we're

55
00:02:54.409 --> 00:02:56.389
worried about the fact that vmware ft

56
00:02:56.389 --> 00:02:58.610
relies on this test and set server to

57
00:02:58.610 --> 00:03:00.560
choose who the primary is so let's build

58
00:03:00.560 --> 00:03:02.750
a replicated testing set server i'm

59
00:03:02.750 --> 00:03:04.520
gonna do this it's gonna be broken it's

60
00:03:04.520 --> 00:03:08.960
just an illustration for why why it's

61
00:03:08.960 --> 00:03:10.610
difficult to get this but brain problem

62
00:03:16.310 --> 00:03:18.379
servers which are supposed to be

63
00:03:23.180 --> 00:03:24.949
they need to know who's the primary

64
00:03:24.949 --> 00:03:26.539
right now or actually maybe these

65
00:03:26.539 --> 00:03:28.939
clients in this case are the primary in

66
00:03:28.939 --> 00:03:34.669
the back up in vmware ft so if it's a

67
00:03:34.669 --> 00:03:36.169
test and set service then you know both

68
00:03:36.169 --> 00:03:38.120
these databases mostly servers start out

69
00:03:38.120 --> 00:03:40.280
with their state that is the state of

70
00:03:40.280 --> 00:03:42.620
this test flight back in zero and the

71
00:03:42.620 --> 00:03:44.719
one operation their clients can send is

72
00:03:44.719 --> 00:03:46.250
the test and set operation which is

73
00:03:46.250 --> 00:03:50.750
supposed to set the flag of the

74
00:03:50.750 --> 00:03:52.879
replicated service to one so i should

75
00:03:52.879 --> 00:03:55.189
set both copies and then return the old

76
00:03:55.189 --> 00:03:57.500
value so it's essentially acts as a kind

77
00:03:57.500 --> 00:04:02.509
of simplified lock server okay so the

78
00:04:02.509 --> 00:04:05.599
problem situation the lowly worried

79
00:04:05.599 --> 00:04:08.930
about split-brain arises when a client

80
00:04:08.930 --> 00:04:11.240
can talk to one of the servers but can't

81
00:04:11.240 --> 00:04:12.770
talk to the other so we're imagining

82
00:04:12.770 --> 00:04:14.990
either that when clients send a request

83
00:04:14.990 --> 00:04:17.810
they send it to both I'm just gonna

84
00:04:17.810 --> 00:04:19.160
assume that now and almost doesn't

85
00:04:19.160 --> 00:04:20.930
matter so let's assume that the protocol

86
00:04:20.930 --> 00:04:22.189
is that the clients supposed to send

87
00:04:22.189 --> 00:04:24.379
ordinarily any request to both servers

88
00:04:24.379 --> 00:04:27.259
and somehow we you know we need

89
00:04:27.259 --> 00:04:29.329
think through what the clients should do

90
00:04:29.329 --> 00:04:31.269
if one of the server's doesn't respond

91
00:04:31.269 --> 00:04:33.410
right or what the system should do if

92
00:04:33.410 --> 00:04:34.579
one of the server seems to gotten

93
00:04:34.579 --> 00:04:38.300
responsive so let's imagine now the

94
00:04:38.300 --> 00:04:40.339
client one can contact server one but

95
00:04:40.339 --> 00:04:42.199
not server two how should the system

96
00:04:42.199 --> 00:04:46.519
react one possibility is for is that we

97
00:04:46.519 --> 00:04:48.379
think well you know gosh we certainly

98
00:04:48.379 --> 00:04:49.610
don't want to just talk to client to

99
00:04:49.610 --> 00:04:50.930
server one because that would leave the

100
00:04:50.930 --> 00:04:53.449
second replica inconsistent if we set

101
00:04:53.449 --> 00:04:54.980
this value to one but didn't also set

102
00:04:54.980 --> 00:04:55.819
this value to one

103
00:04:55.819 --> 00:04:57.649
so maybe the rule should be that the

104
00:04:57.649 --> 00:04:59.389
client is always required to talk to

105
00:04:59.389 --> 00:05:01.850
both replicas to both servers for any

106
00:05:01.850 --> 00:05:03.259
operation and shouldn't be allowed to

107
00:05:03.259 --> 00:05:05.839
just talk to one of them so why is that

108
00:05:05.839 --> 00:05:10.819
the wrong answer so the rule is o in our

109
00:05:10.819 --> 00:05:12.470
replicated system the clients always

110
00:05:12.470 --> 00:05:15.290
require to talk to both replicas in

111
00:05:15.290 --> 00:05:22.730
order to make progress at all in fact

112
00:05:22.730 --> 00:05:25.490
it's worse it's worse than talking to a

113
00:05:25.490 --> 00:05:27.230
single server because now the system has

114
00:05:27.230 --> 00:05:30.649
a problem if either of these servers is

115
00:05:30.649 --> 00:05:33.470
crashed or or you can't talk to it at

116
00:05:33.470 --> 00:05:34.879
least with a non replicated service

117
00:05:34.879 --> 00:05:36.139
you're only depending on one server but

118
00:05:36.139 --> 00:05:37.579
here we am both servers have to be a lot

119
00:05:41.839 --> 00:05:43.699
so we can't possibly require the client

120
00:05:43.699 --> 00:05:46.850
to actually you know wait for both

121
00:05:50.360 --> 00:05:52.550
proceed so another obvious answer is

122
00:05:56.360 --> 00:05:59.889
talk to and figures the other ones dead

123
00:05:59.889 --> 00:06:02.629
so what's up why is that also not the

124
00:06:02.629 --> 00:06:04.899
right answer

125
00:06:08.509 --> 00:06:10.250
the troubling scenario is if the other

126
00:06:10.250 --> 00:06:12.110
server is actually alive so suppose the

127
00:06:12.110 --> 00:06:13.939
actual problem or encountering is not

128
00:06:13.939 --> 00:06:16.759
that this server crashed which would be

129
00:06:16.759 --> 00:06:20.149
good for us but the much worse issue

130
00:06:20.149 --> 00:06:21.500
that something went wrong with the

131
00:06:21.500 --> 00:06:23.899
network cable and that this client can

132
00:06:23.899 --> 00:06:26.209
talk to climb one can talk to server one

133
00:06:26.209 --> 00:06:27.889
but not server two and there's maybe

134
00:06:27.889 --> 00:06:29.600
some other client out there that conduct

135
00:06:35.600 --> 00:06:38.300
to both servers that it's okay in order

136
00:06:38.300 --> 00:06:39.680
to be fault tolerant that I just talked

137
00:06:39.680 --> 00:06:43.519
to one then what's just inevitably gonna

138
00:06:43.519 --> 00:06:46.129
happen said this cable is gonna break

139
00:06:46.129 --> 00:06:48.170
thus cutting the network in half client

140
00:06:48.170 --> 00:06:51.319
one is gonna send a test and set request

141
00:06:51.319 --> 00:06:53.750
to server one server one will you know

142
00:06:53.750 --> 00:06:56.269
set it state to one and return the

143
00:06:56.269 --> 00:06:58.430
previous value of zero to client one and

144
00:06:58.430 --> 00:06:59.660
so that mean client mom will think it

145
00:06:59.660 --> 00:07:02.180
has the lock and if it's a VMware ft

146
00:07:02.180 --> 00:07:04.310
server will think it can be takeovers

147
00:07:04.310 --> 00:07:06.740
primarily but this replica still of zero

148
00:07:06.740 --> 00:07:08.569
in it all right so now if client to

149
00:07:08.569 --> 00:07:10.310
who've also sends a test and set request

150
00:07:10.310 --> 00:07:12.920
to you know what price to send them to

151
00:07:12.920 --> 00:07:14.389
both sees that server one appears to be

152
00:07:14.389 --> 00:07:16.819
down follows the rule that says well you

153
00:07:16.819 --> 00:07:17.959
just send to the one server but you can

154
00:07:17.959 --> 00:07:22.459
talk to then it will also think that it

155
00:07:22.459 --> 00:07:23.870
would either quiet because client you

156
00:07:23.870 --> 00:07:25.519
also think that it acquired the lock and

157
00:07:25.519 --> 00:07:27.230
so now you know if we were imagining

158
00:07:27.230 --> 00:07:28.819
this test and that server was going to

159
00:07:28.819 --> 00:07:29.990
be used with the and where ft we have

160
00:07:37.970 --> 00:07:41.180
by themselves without consulting the

161
00:07:41.180 --> 00:07:42.649
other server so that's a complete

162
00:07:42.649 --> 00:07:45.350
failure so with this set up and two

163
00:07:45.350 --> 00:07:47.839
servers it seemed like we had this we

164
00:07:47.839 --> 00:07:49.699
just had to choose either you wait for

165
00:07:49.699 --> 00:07:52.120
both and you're not fault-tolerant or

166
00:07:52.120 --> 00:07:54.439
you wait for just one and you're not

167
00:07:54.439 --> 00:07:57.350
correct and then our correct version

168
00:07:57.350 --> 00:07:59.560
it's often called split brain so

169
00:07:59.560 --> 00:08:06.939
everybody see this well

170
00:08:09.129 --> 00:08:12.639
so this was basically where things stood

171
00:08:12.639 --> 00:08:16.519
until the late 80s and when people but

172
00:08:20.509 --> 00:08:22.699
control telephone switches or the

173
00:08:22.699 --> 00:08:24.920
computers that ran banks you know there

174
00:08:24.920 --> 00:08:26.509
was placer when we spend a huge amount

175
00:08:26.509 --> 00:08:27.829
of money in order to have reliable

176
00:08:27.829 --> 00:08:29.449
service and so they would replicate they

177
00:08:29.449 --> 00:08:31.220
would build replicated systems and the

178
00:08:31.220 --> 00:08:33.529
way they would deal then way would that

179
00:08:33.529 --> 00:08:35.240
they would have replication but try to

180
00:08:35.240 --> 00:08:38.240
rule out of rule out split brain it's a

181
00:08:47.360 --> 00:08:49.159
you guys use networks that essentially

182
00:08:49.159 --> 00:08:51.259
cannot fail all the time the wires

183
00:08:51.259 --> 00:08:53.840
inside your laptop you know connecting

184
00:08:53.840 --> 00:08:57.590
the CPU to the DRAM are effectively what

185
00:08:57.590 --> 00:08:59.409
you know a network that cannot fail

186
00:08:59.409 --> 00:09:02.929
between the between your CPU and DRAM so

187
00:09:02.929 --> 00:09:05.149
you know with reasonable assumptions and

188
00:09:05.149 --> 00:09:07.309
lots of money and you know sort of

189
00:09:07.309 --> 00:09:10.250
carefully controlled physical situation

190
00:09:10.250 --> 00:09:11.179
like you don't want to have a cable

191
00:09:11.179 --> 00:09:12.799
snaking across the floor that somebody

192
00:09:17.480 --> 00:09:19.759
network that cannot fail you can rule

193
00:09:19.759 --> 00:09:21.139
out split brain it's bit of an

194
00:09:21.139 --> 00:09:22.940
assumption but with enough money people

195
00:09:22.940 --> 00:09:25.370
get quite close to this because if the

196
00:09:28.700 --> 00:09:31.309
to that means server two must be down

197
00:09:31.309 --> 00:09:33.440
because it can't have been the network

198
00:09:33.440 --> 00:09:35.450
malfunctioning so that was one way that

199
00:09:35.450 --> 00:09:38.659
people sort of built replication systems

200
00:09:38.659 --> 00:09:41.950
it didn't suffer from split brain

201
00:09:44.240 --> 00:09:46.129
some human beings sort out the problem

202
00:09:46.129 --> 00:09:48.139
that is don't automatically do anything

203
00:09:48.139 --> 00:09:49.970
instead have the clients you know by

204
00:09:49.970 --> 00:09:51.860
default clients always have to wait for

205
00:09:51.860 --> 00:09:54.110
you know both replicas to respond or

206
00:09:54.110 --> 00:09:56.870
something never allowed to proceed with

207
00:09:56.870 --> 00:09:58.519
just one of them but you can you know

208
00:09:58.519 --> 00:10:00.710
call somebody's beeper to go off some

209
00:10:00.710 --> 00:10:02.539
human being goes to the machine room and

210
00:10:02.539 --> 00:10:04.250
sort of looks at the two replicas and

211
00:10:07.850 --> 00:10:10.129
or verifies that one of them has indeed

212
00:10:10.129 --> 00:10:13.460
crashed and if the other is alive and so

213
00:10:13.460 --> 00:10:14.990
you're essentially using the human as a

214
00:10:14.990 --> 00:10:17.600
as the tie breaker and the human is a

215
00:10:17.600 --> 00:10:20.750
you know if they were a computer it

216
00:10:20.750 --> 00:10:21.769
would be a single point if you

217
00:10:21.769 --> 00:10:25.669
themselves so for a long time people use

218
00:10:25.669 --> 00:10:27.289
one of the other these schemes in order

219
00:10:27.289 --> 00:10:28.970
to build replicated systems and it's not

220
00:10:32.480 --> 00:10:34.460
the network that cannot fail is

221
00:10:34.460 --> 00:10:38.870
expensive but it's not not doable but it

222
00:10:45.950 --> 00:10:48.980
correctly in the face of flaky networks

223
00:10:48.980 --> 00:10:51.289
of networks that could fail on the can

224
00:10:51.289 --> 00:10:53.210
partition so this split of the network

225
00:10:53.210 --> 00:10:54.919
in half where the two sides operate they

226
00:10:54.919 --> 00:10:56.600
can't talk to each other that's usually

227
00:10:56.600 --> 00:11:04.909
called a partition and the big insight

228
00:11:04.909 --> 00:11:06.889
that people came up with in order to

229
00:11:06.889 --> 00:11:10.100
build automated replication systems that

230
00:11:10.100 --> 00:11:12.590
don't suffer from split brain is the

231
00:11:12.590 --> 00:11:17.649
idea of a majority vote this is a

232
00:11:22.460 --> 00:11:24.110
other sentence practically in the raft

233
00:11:24.110 --> 00:11:28.519
paper sort of fundamental way of

234
00:11:28.519 --> 00:11:31.460
proceeding the first step is to have an

235
00:11:31.460 --> 00:11:33.740
odd number of servers instead of an even

236
00:11:33.740 --> 00:11:35.779
number of servers like one flaw here is

237
00:11:35.779 --> 00:11:37.940
that it's a little bit too symmetric all

238
00:11:37.940 --> 00:11:39.379
right the two sides of the split here

239
00:11:39.379 --> 00:11:41.539
just they just look the same so they run

240
00:11:41.539 --> 00:11:42.590
the same software they're gonna do the

241
00:11:42.590 --> 00:11:44.299
same thing and that's not good but if

242
00:11:44.299 --> 00:11:47.440
you have an odd number of servers then

243
00:11:47.440 --> 00:11:50.899
it's not symmetric anymore right at

244
00:11:50.899 --> 00:11:52.940
least a single network split will be

245
00:11:52.940 --> 00:11:54.740
presumably two servers on one side and

246
00:11:54.740 --> 00:11:56.179
one server on the other side and they

247
00:11:56.179 --> 00:11:58.490
won't be symmetric at all and that's

248
00:11:58.490 --> 00:12:00.830
part of what majority vote majority

249
00:12:00.830 --> 00:12:04.220
voting schemes are appealing to so basic

250
00:12:04.220 --> 00:12:05.629
ideas you have an odd number of servers

251
00:12:05.629 --> 00:12:08.299
in order to make progress of any kind so

252
00:12:08.299 --> 00:12:10.940
in raft elect a leader or cause a log

253
00:12:10.940 --> 00:12:12.620
entry to be committed in order to make

254
00:12:12.620 --> 00:12:15.379
any progress at each step you have to

255
00:12:15.379 --> 00:12:18.649
assemble a majority of the server's more

256
00:12:18.649 --> 00:12:20.149
than half more than half of all the

257
00:12:20.149 --> 00:12:22.490
servers in order to sort of approve that

258
00:12:22.490 --> 00:12:25.279
step like vote for a meet or accept a

259
00:12:32.750 --> 00:12:36.669
or three servers required to do anything

260
00:12:37.820 --> 00:12:40.250
one reason this works of course is that

261
00:12:40.250 --> 00:12:43.500
if there's a partition there can't be

262
00:12:43.500 --> 00:12:45.570
more than one partition with a majority

263
00:12:45.570 --> 00:12:47.639
of the server's in it that's one way to

264
00:12:47.639 --> 00:12:51.330
look at this a partition can have one

265
00:12:55.440 --> 00:12:56.549
partition has two then the other

266
00:12:56.549 --> 00:12:58.409
partition has to have only one server in

267
00:12:58.409 --> 00:13:00.690
it and therefore will never be able to

268
00:13:00.690 --> 00:13:02.279
assemble a majority and won't be able to

269
00:13:02.279 --> 00:13:07.350
make progress and just to be totally

270
00:13:07.350 --> 00:13:09.600
clear when we're talking about a

271
00:13:09.600 --> 00:13:11.610
majority it's always a majority out of

272
00:13:15.929 --> 00:13:17.429
me for a long time but if you have a

273
00:13:17.429 --> 00:13:19.259
system with three servers and maybe some

274
00:13:19.259 --> 00:13:20.850
of them have failed or something if you

275
00:13:20.850 --> 00:13:22.259
need to assemble in the majority it's

276
00:13:22.259 --> 00:13:24.720
always two out of three even if you know

277
00:13:24.720 --> 00:13:26.309
that one has failed the majority is

278
00:13:26.309 --> 00:13:27.450
always out of the total number of

279
00:13:27.450 --> 00:13:30.419
servers there's a more general

280
00:13:30.419 --> 00:13:33.690
formulation of this because a majority

281
00:13:33.690 --> 00:13:35.610
voting system in which two out of three

282
00:13:35.610 --> 00:13:37.169
are required to make progress it can

283
00:13:37.169 --> 00:13:40.889
survive the failure of one server right

284
00:13:40.889 --> 00:13:42.929
any two servers are enough to make

285
00:13:42.929 --> 00:13:45.179
progress if you need to be able to if

286
00:13:45.179 --> 00:13:46.740
you're you know you worried about how

287
00:13:46.740 --> 00:13:49.980
reliable your servers are or then you

288
00:13:49.980 --> 00:13:51.570
can build systems that have more servers

289
00:13:51.570 --> 00:13:53.490
and so the more general formulation is

290
00:13:53.490 --> 00:13:59.490
if you have two F + 1 servers then you

291
00:13:59.490 --> 00:14:06.929
can withstand you know so if it's three

292
00:14:06.929 --> 00:14:09.779
that means F is one and the system with

293
00:14:09.779 --> 00:14:12.809
three servers you can tolerate F servers

294
00:14:12.809 --> 00:14:17.450
step one failure and still keep going

295
00:14:19.769 --> 00:14:22.389
all right often these are called quorum

296
00:14:22.389 --> 00:14:25.350
systems because the two out of three is

297
00:14:36.759 --> 00:14:38.110
and therefore if the networks

298
00:14:38.110 --> 00:14:40.570
partitioned we can't have both halves of

299
00:14:40.570 --> 00:14:42.549
the network making progress another more

300
00:14:42.549 --> 00:14:44.500
subtle thing that's going on here is

301
00:14:44.500 --> 00:14:48.970
that if you always need a majority of

302
00:14:48.970 --> 00:14:52.629
the servers to proceed and you go

303
00:14:52.629 --> 00:14:54.250
through a sort of succession of

304
00:14:54.250 --> 00:14:55.990
operations in which reach operations

305
00:15:00.730 --> 00:15:04.690
votes for leaders arrived then at every

306
00:15:04.690 --> 00:15:06.519
step the majority you assemble for that

307
00:15:06.519 --> 00:15:09.340
step must contain at least one server

308
00:15:09.340 --> 00:15:11.289
that was in the previous majority that

309
00:15:11.289 --> 00:15:13.899
is any two majorities overlap in at

310
00:15:13.899 --> 00:15:17.799
least one server and it's really that

311
00:15:27.220 --> 00:15:28.480
have a leader a successful leader

312
00:15:28.480 --> 00:15:30.340
election and leader assembles votes from

313
00:15:30.340 --> 00:15:32.980
a majority its majority is guaranteed to

314
00:15:32.980 --> 00:15:34.779
overlap with the previous leaders

315
00:15:34.779 --> 00:15:36.490
majority and so for example the new

316
00:15:36.490 --> 00:15:39.220
leader is guaranteed to know about the

317
00:15:39.220 --> 00:15:41.279
term number used by the previous leader

318
00:15:41.279 --> 00:15:43.360
because it's a majority overlaps with

319
00:15:43.360 --> 00:15:45.299
the previous leaders majority and

320
00:15:45.299 --> 00:15:47.379
everybody in the previous leaders

321
00:15:55.570 --> 00:15:57.970
a majority of the servers in raft and

322
00:15:57.970 --> 00:15:59.769
therefore any new leaders majority must

323
00:15:59.769 --> 00:16:01.870
overlap at at least one server with

324
00:16:01.870 --> 00:16:04.779
every committed entry from the previous

325
00:16:04.779 --> 00:16:08.529
leader this is a big part of why it is

326
00:16:08.529 --> 00:16:13.110
that wrapped is correct

327
00:16:27.940 --> 00:16:31.470
these muscle ad servers

328
00:16:36.710 --> 00:16:41.110
add it or change the set of servers and

329
00:16:41.110 --> 00:16:44.600
it's possible you need to do it in a

330
00:16:44.600 --> 00:16:45.919
long-running system if you're running

331
00:16:45.919 --> 00:16:48.799
your system for five ten years you know

332
00:16:48.799 --> 00:16:50.480
you're gonna need to replace the servers

333
00:16:50.480 --> 00:16:52.490
after a while you know one of them fails

334
00:16:52.490 --> 00:16:55.279
permanently or you upgrade or you move

335
00:16:55.279 --> 00:16:56.389
machine rooms to a different machine

336
00:16:56.389 --> 00:16:58.250
room you really do need to be able to

337
00:16:58.250 --> 00:17:00.200
support changing sets of servers so

338
00:17:00.200 --> 00:17:01.639
that's a it certainly doesn't happen

339
00:17:01.639 --> 00:17:03.230
every day but it's a critical part of

340
00:17:03.230 --> 00:17:05.390
this or a long-term maintainability of

341
00:17:05.390 --> 00:17:08.480
these systems and you know the RAF

342
00:17:08.480 --> 00:17:10.519
authors sort of pat themselves on the

343
00:17:14.359 --> 00:17:21.859
because it's complex all right so using

344
00:17:21.859 --> 00:17:25.450
this idea in about 1990 or so there were

345
00:17:31.549 --> 00:17:34.210
this majority voting system to kind of

346
00:17:46.519 --> 00:17:48.380
these very early systems was called

347
00:17:48.380 --> 00:17:51.859
Paxos the RAF paper talks about this a

348
00:17:51.859 --> 00:17:54.859
lot and another of these very early

349
00:17:54.859 --> 00:17:56.420
systems was called view stamp

350
00:17:56.420 --> 00:18:00.170
replication a previa des vs r4 view

351
00:18:00.170 --> 00:18:02.839
stamp replication and even though Paxos

352
00:18:07.309 --> 00:18:09.589
actually closer to design in design to

353
00:18:09.589 --> 00:18:11.650
view statment few stamp application

354
00:18:11.650 --> 00:18:16.970
which was invented by people at MIT and

355
00:18:16.970 --> 00:18:19.279
so there's a sort of a law many decade

356
00:18:19.279 --> 00:18:21.619
history of these systems and they only

357
00:18:21.619 --> 00:18:24.799
really came to the forefront and started

358
00:18:24.799 --> 00:18:27.200
being used a lot in deployed big

359
00:18:27.200 --> 00:18:29.269
distributed sisty systems about 15 years

360
00:18:29.269 --> 00:18:31.970
ago a good 15 years after they were

361
00:18:31.970 --> 00:18:39.680
originally invented okay so let me talk

362
00:18:39.680 --> 00:18:42.339
about Rath now

363
00:18:42.769 --> 00:18:46.170
raft is a takes the form of a library

364
00:18:51.359 --> 00:18:53.579
service that each of the replicas in the

365
00:19:10.259 --> 00:19:13.920
raft replica is that at the top we can

366
00:19:13.920 --> 00:19:15.539
think of the replicas having the

367
00:19:15.539 --> 00:19:17.849
application code so it might be for lab

368
00:19:17.849 --> 00:19:20.789
3 a key-value server so maybe we have

369
00:19:20.789 --> 00:19:24.390
some key value server and in a state the

370
00:19:24.390 --> 00:19:26.880
application has state that raft is

371
00:19:26.880 --> 00:19:28.710
helping it manage replicated state and

372
00:19:28.710 --> 00:19:30.299
for a key value server it's going to be

373
00:19:30.299 --> 00:19:39.180
a table of keys and values the next

374
00:19:39.180 --> 00:19:44.339
layer down is a raft layer so the key

375
00:19:44.339 --> 00:19:45.769
value server is gonna sort of make

376
00:19:45.769 --> 00:19:47.759
function calls into raft and they're

377
00:19:54.839 --> 00:19:56.279
purposes really the most critical piece

378
00:19:56.279 --> 00:19:59.420
of state is that raft has a log of

379
00:19:59.420 --> 00:20:08.369
operations and a system with 3 breath

380
00:20:08.369 --> 00:20:09.509
will cause we're actually gonna have you

381
00:20:14.460 --> 00:20:19.950
the very same data sitting in sitting at

382
00:20:19.950 --> 00:20:22.369
both layers

383
00:20:32.380 --> 00:20:35.720
right outside of this there's gonna be

384
00:20:35.720 --> 00:20:38.869
clients and the game is that so we have

385
00:20:38.869 --> 00:20:40.640
you know client 1 and client two whole

386
00:20:40.640 --> 00:20:42.769
bunch of clients the clients don't

387
00:20:42.769 --> 00:20:44.119
really know the clients are you know

388
00:20:44.119 --> 00:20:46.789
just external code that needs to be able

389
00:20:46.789 --> 00:20:49.579
to use the service and the hope is the

390
00:20:49.579 --> 00:20:50.960
clients won't really need to be aware

391
00:20:50.960 --> 00:20:52.309
that they're talking to a replicated

392
00:20:52.309 --> 00:20:53.690
service that to the clients that are

393
00:20:53.690 --> 00:20:55.940
looking almost like it's just one server

394
00:21:00.740 --> 00:21:04.220
requests to the key to the application

395
00:21:11.720 --> 00:21:13.970
these are gonna be you know application

396
00:21:13.970 --> 00:21:15.740
level requests for a database for a key

397
00:21:15.740 --> 00:21:17.420
value server these might be put in get

398
00:21:17.420 --> 00:21:20.569
requests you know put takes a key and a

399
00:21:20.569 --> 00:21:26.470
value and updates the table and get

400
00:21:26.470 --> 00:21:29.529
asked the service to get the current key

401
00:21:29.529 --> 00:21:34.150
current value corresponding to some key

402
00:21:38.509 --> 00:21:41.990
service we're building but once one of

403
00:21:41.990 --> 00:21:43.579
these commands gets sent from the

404
00:21:43.579 --> 00:21:44.990
requests get sent from the clients of

405
00:21:44.990 --> 00:21:48.289
the server what actually happens is you

406
00:21:48.289 --> 00:21:50.769
know on a non replicated server the

407
00:21:54.829 --> 00:21:56.690
response to a book but not in a raft

408
00:21:56.690 --> 00:21:59.150
replicated service instead if assuming

409
00:21:59.150 --> 00:22:00.740
the client sends a request to leader

410
00:22:00.740 --> 00:22:04.190
what really happens is the application

411
00:22:04.190 --> 00:22:06.559
layer simply sends the request the

412
00:22:06.559 --> 00:22:08.480
clients request down into the raft layer

413
00:22:08.480 --> 00:22:09.910
to say look you know here's a request

414
00:22:09.910 --> 00:22:13.130
please get it committed into the

415
00:22:13.130 --> 00:22:15.440
replicated log and tell me when you're

416
00:22:15.440 --> 00:22:17.599
done and so at this point the rafts

417
00:22:17.599 --> 00:22:23.839
chitchat with each other until all the

418
00:22:23.839 --> 00:22:25.819
replicas are a majority the replicas get

419
00:22:31.180 --> 00:22:34.910
leader knows that all of the replicas of

420
00:22:40.339 --> 00:22:42.980
value they are saying aha that operation

421
00:22:42.980 --> 00:22:44.390
you sent me I mean

422
00:22:44.390 --> 00:22:46.130
it's been now committed into all the

423
00:22:46.130 --> 00:22:49.309
replicas and so it's safely replicated

424
00:22:49.309 --> 00:22:51.920
and at this point it's okay to execute

425
00:23:04.579 --> 00:23:09.400
in out and the logs of all the replicas

426
00:23:09.400 --> 00:23:11.779
then raft notifies the leader now the

427
00:23:11.779 --> 00:23:13.430
leader actually execute the operation

428
00:23:13.430 --> 00:23:15.440
which corresponds to you know for a put

429
00:23:15.440 --> 00:23:20.359
updating the value yet reading correct

430
00:23:26.660 --> 00:23:34.759
that's the ordinary operation of it

431
00:23:34.759 --> 00:23:36.319
submitted if it's in a majority and

432
00:23:36.319 --> 00:23:38.480
again the reason why I can't be all is

433
00:23:38.480 --> 00:23:39.589
that if we want to build a

434
00:23:39.589 --> 00:23:41.299
fault-tolerant system it has to be able

435
00:23:41.299 --> 00:23:43.519
to make progress even if some of the

436
00:23:43.519 --> 00:23:49.450
server's have failed so yeah so ever

437
00:23:49.450 --> 00:23:53.680
it's committed when it's in a majority

438
00:23:54.720 --> 00:23:57.890
[Music]

439
00:24:08.170 --> 00:24:12.710
yeah and so in addition when operations

440
00:24:12.710 --> 00:24:14.769
finally committed each of the replicas

441
00:24:14.769 --> 00:24:17.660
sends the operation up each of the raft

442
00:24:17.660 --> 00:24:20.779
library layer sends the operation up to

443
00:24:20.779 --> 00:24:22.910
the local application layer in the local

444
00:24:22.910 --> 00:24:24.589
application layer applies that operation

445
00:24:29.299 --> 00:24:32.779
same stream of operations they show up

446
00:24:32.779 --> 00:24:34.759
in these up calls in the same order they

447
00:24:34.759 --> 00:24:36.349
get applied to the state in the same

448
00:24:36.349 --> 00:24:38.960
order and you know assuming the

449
00:24:45.920 --> 00:24:48.190
replicated State will evolve in

450
00:24:48.190 --> 00:24:50.359
identically on all the replicas so

451
00:24:50.359 --> 00:24:52.400
typically this this table is what the

452
00:24:52.400 --> 00:24:55.779
paper is talking about when it talks

453
00:25:10.220 --> 00:25:11.779
I'll draw you a time diagram of how the

454
00:25:11.779 --> 00:25:13.849
messages work so let's imagine we have a

455
00:25:13.849 --> 00:25:18.589
client and server one is the leader that

456
00:25:18.589 --> 00:25:23.750
we also have server to server three and

457
00:25:23.750 --> 00:25:25.819
time flows downward on this diagram we

458
00:25:25.819 --> 00:25:27.470
imagine the client sending the original

459
00:25:27.470 --> 00:25:31.940
request to server one after that server

460
00:25:31.940 --> 00:25:35.329
ones raft layer sends an append entries

461
00:25:35.329 --> 00:25:42.799
RPC to each of the two replicas this is

462
00:25:42.799 --> 00:25:44.529
just an ordinary I'll say a put request

463
00:25:44.529 --> 00:25:49.369
this is append entries requests the

464
00:25:49.369 --> 00:25:51.980
server is now waiting for replies and

465
00:25:58.279 --> 00:26:00.799
including the leader itself so in a

466
00:26:03.769 --> 00:26:06.680
replica to respond positively to an

467
00:26:06.680 --> 00:26:09.309
append entries as soon as it assembles

468
00:26:09.309 --> 00:26:14.380
positive responses from a majority the

469
00:26:14.380 --> 00:26:15.529
leader

470
00:26:15.529 --> 00:26:18.230
execute a command figures out what the

471
00:26:18.230 --> 00:26:20.380
answer is like forget

472
00:26:20.380 --> 00:26:25.420
and sends the reply back to the client

473
00:26:25.420 --> 00:26:27.250
I mean why of course you know if s who's

474
00:26:27.250 --> 00:26:30.700
actually awry alive it'll send back its

475
00:26:30.700 --> 00:26:32.200
response too but we're not waiting for

476
00:26:32.200 --> 00:26:35.470
it although it's useful to know and

477
00:26:35.470 --> 00:26:40.890
figure - all right everybody see this

478
00:26:40.890 --> 00:26:43.119
this is the sort of ordinary operation

479
00:26:43.119 --> 00:26:46.890
of the system no no failures

480
00:26:51.200 --> 00:26:55.460
oh gosh yeah I like I left out important

481
00:26:55.460 --> 00:26:57.559
steps so you know this point the leader

482
00:26:57.559 --> 00:26:59.750
knows oh I got you know I'm adora t have

483
00:26:59.750 --> 00:27:01.519
put it in no log I can go ahead and

484
00:27:01.519 --> 00:27:03.230
execute it and reply yes to the client

485
00:27:03.230 --> 00:27:05.150
because it's committed but server two

486
00:27:05.150 --> 00:27:06.380
doesn't know anything yet it just knows

487
00:27:06.380 --> 00:27:07.640
well you know I got this request from

488
00:27:07.640 --> 00:27:09.589
the leader but I don't know if it's

489
00:27:09.589 --> 00:27:11.779
committed yet depends on for example

490
00:27:11.779 --> 00:27:13.519
whether my reply got back to the leader

491
00:27:13.519 --> 00:27:15.259
for all server to knows it's reply was

492
00:27:15.259 --> 00:27:16.940
brought by the network maybe the leader

493
00:27:16.940 --> 00:27:18.710
never heard the reply and never decided

494
00:27:18.710 --> 00:27:20.359
to commit this request so there's

495
00:27:38.319 --> 00:27:40.730
there's an extra message here exactly

496
00:27:40.730 --> 00:27:42.200
what that message is depends a little

497
00:27:42.200 --> 00:27:45.859
bit on what what else is going on it's

498
00:27:45.859 --> 00:27:49.519
at least in raft there's not an explicit

499
00:27:49.519 --> 00:27:51.319
commit message instead the information

500
00:27:51.319 --> 00:27:53.720
is piggybacked inside the next append

501
00:27:53.720 --> 00:27:55.640
entries that leader sends out the next

502
00:27:55.640 --> 00:27:57.619
append entries RPC it sends out for

503
00:27:57.619 --> 00:28:00.259
whatever reason like there's a commit

504
00:28:00.259 --> 00:28:01.819
meter commit or something filled in that

505
00:28:01.819 --> 00:28:05.779
RPC and the next time the leader needs

506
00:28:05.779 --> 00:28:07.880
have to send a heartbeat heartbeat or

507
00:28:13.369 --> 00:28:16.569
or something it'll send out the new hire

508
00:28:16.569 --> 00:28:19.279
leader commit value and at that point

509
00:28:19.279 --> 00:28:25.250
the replicas will execute the operation

510
00:28:25.250 --> 00:28:30.789
and apply it to their state yes

511
00:28:39.700 --> 00:28:43.390
oh yes so this is a this is a protocol

512
00:28:43.390 --> 00:28:45.269
that has a quite a bit of chitchat in it

513
00:28:45.269 --> 00:28:51.130
and it's not super fast indeed you know

514
00:28:54.730 --> 00:28:57.460
at least you know another instance that

515
00:28:57.460 --> 00:28:58.809
multiple messages has to wait for the

516
00:28:58.809 --> 00:29:00.549
responses send something back so there's

517
00:29:00.549 --> 00:29:02.200
a bunch of message round-trip times kind

518
00:29:02.200 --> 00:29:05.640
of embedded here

519
00:29:10.759 --> 00:29:15.259
yes if so this is up to you as the

520
00:29:15.259 --> 00:29:17.930
implementer actually exactly when the

521
00:29:17.930 --> 00:29:21.170
leader sends out the updated commit

522
00:29:21.170 --> 00:29:26.599
index if client requests a comeback only

523
00:29:30.740 --> 00:29:33.319
or send out a special append entries

524
00:29:33.319 --> 00:29:37.549
message if client requests come quite

525
00:29:37.549 --> 00:29:38.539
frequently then it doesn't matter

526
00:29:38.539 --> 00:29:40.279
because if they come you know there's

527
00:29:43.519 --> 00:29:45.230
so you can piggyback so without

528
00:29:45.230 --> 00:29:46.670
generating an extra message which is

529
00:29:46.670 --> 00:29:48.410
somewhat expensive you can get the

530
00:29:53.450 --> 00:29:58.819
think the time at which the replicas

531
00:30:04.640 --> 00:30:06.500
there's no failures if there's no

532
00:30:06.500 --> 00:30:10.700
failures replicas executing the request

533
00:30:10.700 --> 00:30:12.680
isn't really on the critical path like

534
00:30:12.680 --> 00:30:13.970
the client isn't waiting for them the

535
00:30:13.970 --> 00:30:15.200
client saw me waiting for the leader to

536
00:30:15.200 --> 00:30:20.539
execute so it may not be that it may not

537
00:30:20.539 --> 00:30:23.599
affect client perceived latency sort of

538
00:30:23.599 --> 00:30:26.980
exactly how this gets staged

539
00:30:37.519 --> 00:30:45.900
all right one question you should ask is

540
00:30:45.900 --> 00:30:48.750
why does the system why is the system so

541
00:30:48.750 --> 00:30:52.640
focused on blogs what are the logs doing

542
00:30:52.640 --> 00:30:54.930
and it's sort of worth trying to come up

543
00:30:54.930 --> 00:30:56.630
with an explicit answers to that one

544
00:30:56.630 --> 00:31:00.210
answer to why the system is totally

545
00:31:00.210 --> 00:31:04.200
focused on logs is that the log is the

546
00:31:04.200 --> 00:31:05.700
kind of mechanism by which the leader

547
00:31:05.700 --> 00:31:08.730
orders operations it's vital for these

548
00:31:08.730 --> 00:31:10.829
replicated state machines that all the

549
00:31:10.829 --> 00:31:13.890
replicas apply not just the same client

550
00:31:13.890 --> 00:31:15.720
operations to their start but the same

551
00:31:15.720 --> 00:31:18.690
operations in the same order but they

552
00:31:18.690 --> 00:31:20.609
all have to apply that these operations

553
00:31:20.609 --> 00:31:22.259
coming from the clients in the same

554
00:31:22.259 --> 00:31:24.240
order and the log among many other

555
00:31:24.240 --> 00:31:26.579
things is part of the machinery by which

556
00:31:26.579 --> 00:31:30.690
the or the leader assigns an order to

557
00:31:30.690 --> 00:31:32.430
the incoming client operations I give

558
00:31:32.430 --> 00:31:34.619
you know ten clients send operations to

559
00:31:37.950 --> 00:31:39.299
make sure everybody all the replicas

560
00:31:39.299 --> 00:31:41.880
obey that order and the log is you know

561
00:31:46.740 --> 00:31:52.680
order it's chosen another use of the log

562
00:31:52.680 --> 00:31:56.700
is that between this point and this

563
00:31:56.700 --> 00:32:00.329
point server 3 has received an operation

564
00:32:00.329 --> 00:32:02.519
that it is not yet sure is committed and

565
00:32:02.519 --> 00:32:04.559
it cannot execute it yet it has to put

566
00:32:04.559 --> 00:32:07.440
the this operation aside somewhere until

567
00:32:07.440 --> 00:32:11.339
the increment to the leader commit value

568
00:32:11.339 --> 00:32:13.500
comes in and so another thing that the

569
00:32:17.130 --> 00:32:18.660
sort of sets aside operations that are

570
00:32:18.660 --> 00:32:20.490
still tentative that have arrived but

571
00:32:20.490 --> 00:32:21.990
are not yet known to be committed and

572
00:32:21.990 --> 00:32:23.339
they may have to be thrown away as we'll

573
00:32:29.730 --> 00:32:33.500
is that the leader needs to remember

574
00:32:33.500 --> 00:32:36.299
operations in its log because it may

575
00:32:36.299 --> 00:32:38.970
need to retransmit them to followers if

576
00:32:38.970 --> 00:32:40.769
some followers offline maybe it's

577
00:32:40.769 --> 00:32:41.880
something briefly happened to its

578
00:32:41.880 --> 00:32:42.269
network

579
00:32:42.269 --> 00:32:44.150
action or something misses some messages

580
00:32:44.150 --> 00:32:46.440
the leader needs to be able to resend

581
00:32:46.440 --> 00:32:49.109
log messages that any followers missed

582
00:32:49.109 --> 00:32:50.700
and so the leader needs a place where

583
00:32:50.700 --> 00:32:52.859
can set aside copies of messages of

584
00:32:52.859 --> 00:32:54.569
client requests even ones that it's

585
00:32:54.569 --> 00:32:56.970
already executed in order to be able to

586
00:32:56.970 --> 00:33:00.539
resend them to the client I mean we send

587
00:33:05.880 --> 00:33:07.950
them to keep the log is that at least in

588
00:33:15.259 --> 00:33:17.759
and you really need if it you really

589
00:33:17.759 --> 00:33:19.470
want a server that crashes - in fact we

590
00:33:19.470 --> 00:33:21.599
start and rejoin the raft cluster

591
00:33:21.599 --> 00:33:23.250
otherwise you're now operating with only

592
00:33:23.250 --> 00:33:24.809
two out of three servers and you can't

593
00:33:24.809 --> 00:33:26.819
survive any more failures we need to

594
00:33:26.819 --> 00:33:29.400
reincorporate failed and rebooted

595
00:33:29.400 --> 00:33:31.950
servers and the log is sort of where or

596
00:33:31.950 --> 00:33:34.440
what a server rebooted server uses the

597
00:33:34.440 --> 00:33:37.170
log persisted to its disk because one of

598
00:33:37.170 --> 00:33:39.569
the rules is that each raft server needs

599
00:33:39.569 --> 00:33:41.160
to write its log to its disk where it

600
00:33:41.160 --> 00:33:42.539
will still be after it crashes and

601
00:33:42.539 --> 00:33:44.460
restarts that log is what the server

602
00:33:44.460 --> 00:33:48.240
uses or replays the operations in that

603
00:33:48.240 --> 00:33:50.369
log from the beginning to sort of create

604
00:33:50.369 --> 00:33:52.710
its state as of when it crashed and then

605
00:33:52.710 --> 00:33:54.809
then it carries on from there so the log

606
00:33:54.809 --> 00:33:56.339
is also used as part of the persistence

607
00:33:56.339 --> 00:33:58.500
plan as a sequence of commands to

608
00:33:58.500 --> 00:34:01.130
rebuild the state

609
00:34:16.280 --> 00:34:20.269
well ultimately okay so the question is

610
00:34:20.269 --> 00:34:23.340
suppose the leader is capable of

611
00:34:23.340 --> 00:34:25.199
executing a thousand client commands a

612
00:34:25.199 --> 00:34:26.880
second and the followers are only

613
00:34:26.880 --> 00:34:28.710
incapable of executing a hundred client

614
00:34:28.710 --> 00:34:30.179
commands per second that's sort of

615
00:34:41.599 --> 00:34:43.800
replicas the followers acknowledge

616
00:34:43.800 --> 00:34:45.630
commands before they execute them so

617
00:34:45.630 --> 00:34:47.190
they mate rate at which they acknowledge

618
00:34:47.190 --> 00:34:48.750
and accumulate stuff in their logs is

619
00:34:52.469 --> 00:34:55.530
second if they do that forever then they

620
00:34:55.530 --> 00:34:57.690
will build up unbounded size logs

621
00:34:57.690 --> 00:35:00.300
because their execution rate falls it

622
00:35:00.300 --> 00:35:02.369
will fall on an unbounded amount behind

623
00:35:02.369 --> 00:35:04.710
the rate at which the leader has given

624
00:35:04.710 --> 00:35:06.210
the messages sort of under the rules of

625
00:35:06.210 --> 00:35:08.820
our game and so what that means they

626
00:35:08.820 --> 00:35:11.250
will eventually run out of memory at

627
00:35:11.250 --> 00:35:13.440
some point so after they have a billion

628
00:35:13.440 --> 00:35:15.389
after they fall a billion log entries

629
00:35:15.389 --> 00:35:16.769
behind those just like they'll call the

630
00:35:16.769 --> 00:35:18.510
memory allocator for space for a new

631
00:35:18.510 --> 00:35:22.829
blog entry and it will fail so yeah and

632
00:35:22.829 --> 00:35:27.420
Raph doesn't Raph doesn't have the flow

633
00:35:27.420 --> 00:35:30.360
controls that's required to cope with

634
00:35:30.360 --> 00:35:34.349
this so I think in a real system you

635
00:35:34.349 --> 00:35:36.179
would actually need you know probably

636
00:35:36.179 --> 00:35:37.769
piggybacked and doesn't need to be

637
00:35:37.769 --> 00:35:39.920
real-time but you probably need some

638
00:35:39.920 --> 00:35:43.920
kind of additional communication here

639
00:35:43.920 --> 00:35:45.570
that says well here's how far I've

640
00:35:45.570 --> 00:35:48.150
gotten in execution so that the leader

641
00:35:48.150 --> 00:35:50.519
can say well you know too many thousands

642
00:35:56.630 --> 00:35:58.860
production system that you're trying to

643
00:35:58.860 --> 00:36:01.650
push to the absolute max you would you

644
00:36:01.650 --> 00:36:03.300
might well need an extra message to

645
00:36:03.300 --> 00:36:05.250
throttle the leader if it got too far

646
00:36:05.250 --> 00:36:07.400
ahead

647
00:36:38.300 --> 00:36:39.920
that it persisted to disk because that's

648
00:36:39.920 --> 00:36:42.889
one of the rules of figure two so the

649
00:36:42.889 --> 00:36:43.940
server will be able to be just logged

650
00:36:49.820 --> 00:36:52.550
the log and also it doesn't know at

651
00:36:52.550 --> 00:36:54.710
least when it first reboots by the rule

652
00:36:54.710 --> 00:36:56.599
that figure two it doesn't even know how

653
00:36:56.599 --> 00:36:59.329
much of the log is committed so the

654
00:36:59.329 --> 00:37:00.619
first answer to your question is that

655
00:37:00.619 --> 00:37:03.920
immediately after a restart you know

656
00:37:03.920 --> 00:37:05.599
after a server crashes and restarts and

657
00:37:05.599 --> 00:37:07.489
reads its log it is not allowed to do

658
00:37:07.489 --> 00:37:10.219
anything with the log because it does

659
00:37:10.219 --> 00:37:11.869
not know how far the system has

660
00:37:11.869 --> 00:37:14.780
committed in its log maybe as long as

661
00:37:14.780 --> 00:37:16.550
has a thousand uncommitted entries and

662
00:37:16.550 --> 00:37:18.230
zero committed entries for all it notes

663
00:37:18.230 --> 00:37:20.800
so

664
00:37:24.809 --> 00:37:26.980
it's a leader dye support that doesn't

665
00:37:26.980 --> 00:37:28.750
help either but let's suppose they've

666
00:37:28.750 --> 00:37:32.590
all crashed this is getting ahead of its

667
00:37:32.590 --> 00:37:33.670
getting a bit ahead of me but well

668
00:37:33.670 --> 00:37:34.809
suppose they've all crashed and so all

669
00:37:34.809 --> 00:37:37.420
they have is the state that was marked

670
00:37:37.420 --> 00:37:40.179
as non-volatile in figure 2 which

671
00:37:45.309 --> 00:37:46.869
there's a crash but they all crash and

672
00:37:46.869 --> 00:37:48.690
they always start none of them knows

673
00:37:48.690 --> 00:37:52.869
initially how far they had been have

674
00:37:52.869 --> 00:37:55.269
executed before the crash so what

675
00:37:55.269 --> 00:37:57.429
happens is that you leader election one

676
00:37:57.429 --> 00:38:00.340
of them gets picked as a leader and that

677
00:38:00.340 --> 00:38:03.820
leader if you sort of track through what

678
00:38:03.820 --> 00:38:06.519
figure 2 says about how a pendant Rees

679
00:38:06.519 --> 00:38:08.469
is supposed to work the leader will

680
00:38:08.469 --> 00:38:10.679
actually figure out as a byproduct of

681
00:38:10.679 --> 00:38:12.820
sending out a pendant or sending out the

682
00:38:19.690 --> 00:38:28.300
basically that that all of the that a

683
00:38:28.300 --> 00:38:30.940
majority of the replicas agree on their

684
00:38:30.940 --> 00:38:33.690
laws because that's the commit point

685
00:38:33.690 --> 00:38:35.650
another way of looking at it is that

686
00:38:35.650 --> 00:38:37.750
once you choose a leader through the

687
00:38:37.750 --> 00:38:39.489
append entries mechanism the leader

688
00:38:39.489 --> 00:38:41.559
forces all of the other replicas to have

689
00:38:46.480 --> 00:38:48.820
paper explains at that point since the

690
00:38:48.820 --> 00:38:50.590
leader knows that it's forced all the

691
00:38:50.590 --> 00:38:52.570
replicas to have it I didn't have logs

692
00:38:52.570 --> 00:38:54.940
that are identicals to it then it knows

693
00:38:54.940 --> 00:38:57.119
that all the replicas must also have a

694
00:38:57.119 --> 00:39:00.789
there must be a majority of replicas

695
00:39:00.789 --> 00:39:03.159
with that all those log injuries in that

696
00:39:03.159 --> 00:39:04.900
logs which are now are identical must

697
00:39:09.880 --> 00:39:13.719
point a leader you know the append

698
00:39:13.719 --> 00:39:15.820
entries code described in Figure 2 for

699
00:39:15.820 --> 00:39:17.800
the leader will increment the leaders

700
00:39:17.800 --> 00:39:19.929
commit point and everybody can now

701
00:39:19.929 --> 00:39:21.820
execute the entire log from the

702
00:39:21.820 --> 00:39:24.400
beginning and recreate their state from

703
00:39:24.400 --> 00:39:29.730
scratch possibly extremely laborious Lee

704
00:39:29.880 --> 00:39:32.650
so that's what figure two says it's

705
00:39:32.650 --> 00:39:34.929
obviously this be executing from scratch

706
00:39:34.929 --> 00:39:37.780
is not very attractive but it's where

707
00:39:42.969 --> 00:39:44.110
this is more efficient to use as

708
00:39:44.110 --> 00:39:45.730
checkpoints and we'll talk about

709
00:39:45.730 --> 00:39:50.889
tomorrow okay so this was a sequence in

710
00:39:50.889 --> 00:39:54.989
sort of ordinary non failure operation

711
00:39:55.380 --> 00:39:57.250
another thing I want to briefly mention

712
00:39:57.250 --> 00:40:00.760
is what this interface looks like you've

713
00:40:00.760 --> 00:40:03.219
probably all seen a little bit of it due

714
00:40:03.219 --> 00:40:05.409
to working on the labs but roughly

715
00:40:05.409 --> 00:40:07.420
speaking if you have let's say that this

716
00:40:07.420 --> 00:40:12.400
key value layer with its state and the

717
00:40:18.329 --> 00:40:20.920
of the interface between them there's

718
00:40:26.230 --> 00:40:27.909
the key value layer has to give it to

719
00:40:27.909 --> 00:40:29.889
wrap and say please you know fit this

720
00:40:29.889 --> 00:40:31.420
request into the log somewhere and

721
00:40:31.420 --> 00:40:36.760
that's the start function that you'll

722
00:40:36.760 --> 00:40:40.420
see in Raph go and really just takes one

723
00:40:40.420 --> 00:40:44.349
argument the client command the key

724
00:40:44.349 --> 00:40:45.550
value they're saying please I got this

725
00:40:45.550 --> 00:40:47.110
command to get into the log and tell me

726
00:40:47.110 --> 00:40:50.320
when it's committed and the other piece

727
00:40:50.320 --> 00:40:54.309
of the interface is that by and by the

728
00:40:54.309 --> 00:40:55.929
raft layer will notify the key value

729
00:40:55.929 --> 00:40:58.179
layer that AHA that operation that you

730
00:40:58.179 --> 00:40:59.739
sent to me in a start command a while

731
00:40:59.739 --> 00:41:01.389
ago which may well not be the most

732
00:41:01.389 --> 00:41:03.429
recent start right there you know a

733
00:41:03.429 --> 00:41:05.320
hundred client commands could come in

734
00:41:05.320 --> 00:41:07.599
and cause calls to start before any of

735
00:41:07.599 --> 00:41:11.289
them are committed so by and by this

736
00:41:11.289 --> 00:41:14.260
upward communication is takes the form

737
00:41:14.260 --> 00:41:16.630
of a message on a go channel that the

738
00:41:16.630 --> 00:41:20.170
raft library sends on and key value

739
00:41:20.170 --> 00:41:23.920
layer is supposed to read from so

740
00:41:23.920 --> 00:41:28.119
there's this apply called the apply

741
00:41:28.119 --> 00:41:31.360
channel and on it on it you send apply

742
00:41:31.360 --> 00:41:33.900
message

743
00:41:37.440 --> 00:41:39.639
this start and of course you need the

744
00:41:39.639 --> 00:41:42.309
the key value layer needs to be able to

745
00:41:42.309 --> 00:41:44.559
match up message that receives an apply

746
00:41:44.559 --> 00:41:47.429
channel with calls to start that it made

747
00:41:47.429 --> 00:41:49.929
and so the start command actually

748
00:41:49.929 --> 00:41:52.599
returns enough information for that

749
00:41:52.599 --> 00:41:54.250
matchup to happen it returns the index

750
00:41:54.250 --> 00:41:58.539
that start functions basically returns

751
00:41:58.539 --> 00:42:00.460
the index in the log where if this

752
00:42:00.460 --> 00:42:02.170
command is committed which it might not

753
00:42:02.170 --> 00:42:05.679
be it'll be committed at this index and

754
00:42:05.679 --> 00:42:07.150
I think it also returns the current term

755
00:42:07.150 --> 00:42:08.380
and some other stuff we don't care about

756
00:42:08.380 --> 00:42:11.590
very much and then this apply message is

757
00:42:11.590 --> 00:42:26.530
going to contain the index command and

758
00:42:26.530 --> 00:42:27.969
all the replicas will get these apply

759
00:42:27.969 --> 00:42:29.769
messages so they'll all know though I

760
00:42:29.769 --> 00:42:33.519
should apply this command figure out

761
00:42:33.519 --> 00:42:35.170
what this command means and apply it to

762
00:42:35.170 --> 00:42:37.510
my local State and they also get the

763
00:42:37.510 --> 00:42:38.980
index the index is really only useful

764
00:42:38.980 --> 00:42:42.280
I'm the leader so it can figure out what

765
00:42:42.280 --> 00:42:43.750
client would what client requests were

766
00:42:43.750 --> 00:42:46.110
talking about

767
00:43:00.889 --> 00:43:03.889
by

768
00:43:14.409 --> 00:43:16.570
the answer a slightly different question

769
00:43:16.570 --> 00:43:18.909
let's suppose the client sends any

770
00:43:18.909 --> 00:43:21.730
request in let's say it's a put or a get

771
00:43:21.730 --> 00:43:23.409
could be put or again it doesn't really

772
00:43:23.409 --> 00:43:29.949
matter I'd say it to get the point in

773
00:43:29.949 --> 00:43:32.500
which the it's a client sense and again

774
00:43:32.500 --> 00:43:33.909
and waits for a response the point at

775
00:43:39.639 --> 00:43:41.679
command is committed so this is going to

776
00:43:41.679 --> 00:43:48.969
be a sort of get reply so the client

777
00:43:48.969 --> 00:43:52.230
doesn't see anything back I mean and so

778
00:43:52.230 --> 00:43:54.250
that means in terms of the actual

779
00:43:54.250 --> 00:43:56.829
software stack that means that the key

780
00:43:56.829 --> 00:43:59.440
value the RPC will arrive the key value

781
00:44:03.820 --> 00:44:06.699
value layer but the key value layer will

782
00:44:06.699 --> 00:44:08.650
not yet reply to the client because it

783
00:44:08.650 --> 00:44:10.840
does not know if it's good actually it

784
00:44:10.840 --> 00:44:12.550
hasn't executed the clients request now

785
00:44:12.550 --> 00:44:13.840
it doesn't even know if it ever will

786
00:44:13.840 --> 00:44:16.570
because it's not sure if the request is

787
00:44:16.570 --> 00:44:18.820
going to be committed right in the

788
00:44:18.820 --> 00:44:20.500
situation which may not be committed is

789
00:44:20.500 --> 00:44:23.590
if the key value layer you know guess

790
00:44:23.590 --> 00:44:25.269
the request calls start and immediately

791
00:44:25.269 --> 00:44:27.159
after starboard turn two crashes right

792
00:44:27.159 --> 00:44:28.960
certainly hasn't sent out its apply what

793
00:44:28.960 --> 00:44:30.219
append messages or whatever

794
00:44:30.219 --> 00:44:33.519
nothing's be committed yep so so the

795
00:44:33.519 --> 00:44:36.599
game is start returns time passes the

796
00:44:36.599 --> 00:44:40.719
relevant apply message corresponding to

797
00:44:40.719 --> 00:44:42.489
that client request appears to the key

798
00:44:42.489 --> 00:44:44.199
value server on the apply channel and

799
00:44:44.199 --> 00:44:47.440
only then and that causes the key value

800
00:44:47.440 --> 00:44:50.650
server to execute the request and send

801
00:44:58.230 --> 00:45:00.159
and that's like all this is very

802
00:45:00.159 --> 00:45:02.170
important when it doesn't really matter

803
00:45:02.170 --> 00:45:04.360
if all everything goes well but if

804
00:45:04.360 --> 00:45:06.639
there's a failure we're now at the point

805
00:45:06.639 --> 00:45:07.780
where we start worrying about theatres I

806
00:45:07.780 --> 00:45:09.760
mean extremely interested in if there

807
00:45:09.760 --> 00:45:13.139
was a failure what did the client see

808
00:45:13.949 --> 00:45:18.550
all right and so one thing that does

809
00:45:18.550 --> 00:45:23.710
come up is that all of you should be

810
00:45:23.710 --> 00:45:24.940
familiar with this that at least

811
00:45:24.940 --> 00:45:26.710
initially one interesting thing about

812
00:45:26.710 --> 00:45:28.539
the logs is that they may not be

813
00:45:28.539 --> 00:45:30.760
identical there are a whole bunch of

814
00:45:30.760 --> 00:45:33.820
situations in which at least for brief

815
00:45:33.820 --> 00:45:36.369
periods of time the ends of the

816
00:45:36.369 --> 00:45:39.159
different replicas logs may diverge like

817
00:45:39.159 --> 00:45:41.710
for example if a leader starts to send

818
00:45:41.710 --> 00:45:43.389
out a round of append messages but

819
00:45:43.389 --> 00:45:45.159
crashes before it's able to send all

820
00:45:45.159 --> 00:45:46.900
them out you know that'll mean that some

821
00:45:50.500 --> 00:45:51.940
log entry and the ones that didn't get

822
00:45:51.940 --> 00:45:54.400
that append messages RPC won't have

823
00:45:54.400 --> 00:45:56.440
appended them so it's easy to see that

824
00:45:56.440 --> 00:45:58.980
the logs are I'm gonna diverge sometimes

825
00:45:58.980 --> 00:46:02.860
the good news is that the the way a raft

826
00:46:02.860 --> 00:46:05.380
works actually ends up forcing the logs

827
00:46:05.380 --> 00:46:08.230
to be identical after a while there may

828
00:46:08.230 --> 00:46:10.480
be transient differences but in the long

829
00:46:10.480 --> 00:46:13.239
run all the logs will sort of be

830
00:46:13.239 --> 00:46:15.340
modified by the leader until the leader

831
00:46:15.340 --> 00:46:17.139
insurers are all identical and only then

832
00:46:17.139 --> 00:46:24.489
are they executed okay so I think the

833
00:46:24.489 --> 00:46:27.190
next there's really two big topics to

834
00:46:27.190 --> 00:46:29.289
talk about here for raft one is how

835
00:46:29.289 --> 00:46:31.449
leader election works which is lab two

836
00:46:31.449 --> 00:46:35.170
and the other is how the leader deals

837
00:46:35.170 --> 00:46:37.269
with the different replicas logs

838
00:46:37.269 --> 00:46:39.699
particularly after failure so first I

839
00:46:39.699 --> 00:46:42.690
want to talk about leader election

840
00:46:44.940 --> 00:46:47.380
question to ask is how come the system

841
00:46:47.380 --> 00:46:48.880
even has a leader why do we need a

842
00:46:48.880 --> 00:46:51.820
leader the part of the answer is you do

843
00:46:51.820 --> 00:46:53.710
not need a leader to build a system like

844
00:46:53.710 --> 00:46:56.889
this you it is possible to build an

845
00:46:56.889 --> 00:46:59.139
agreement system by which a cluster of

846
00:46:59.139 --> 00:47:02.139
servers agrees you know the sequence of

847
00:47:02.139 --> 00:47:04.210
entries in a log without having any kind

848
00:47:04.210 --> 00:47:05.739
of designated leader

849
00:47:05.739 --> 00:47:07.960
and indeed the original pack so system

850
00:47:07.960 --> 00:47:09.909
which the paper refers to original Paxos

851
00:47:09.909 --> 00:47:13.150
did not have a leader so it's possible

852
00:47:13.150 --> 00:47:15.460
the reason why raft has a leader is

853
00:47:15.460 --> 00:47:18.789
basically that there's probably a lot of

854
00:47:18.789 --> 00:47:20.380
reasons but one of the foremost reasons

855
00:47:20.380 --> 00:47:22.150
is that you can build a more efficient

856
00:47:22.150 --> 00:47:24.400
in the common case in which the server's

857
00:47:24.400 --> 00:47:27.130
don't fail it's possible to build a more

858
00:47:27.130 --> 00:47:28.659
efficient system if you have a leader

859
00:47:28.659 --> 00:47:30.639
because with a designated leader

860
00:47:30.639 --> 00:47:33.309
everybody knows who the leader is you

861
00:47:33.309 --> 00:47:37.539
can basically get agreement on requests

862
00:47:37.539 --> 00:47:39.280
that with one round of messages per

863
00:47:39.280 --> 00:47:41.469
request where as leader of this systems

864
00:47:41.469 --> 00:47:43.480
have more of the flavor of well you need

865
00:47:43.480 --> 00:47:45.579
a first round to kind of agree on a

866
00:47:45.579 --> 00:47:47.619
temporary leader and then a second round

867
00:47:47.619 --> 00:47:50.619
actually send out the requests so it's

868
00:47:50.619 --> 00:47:53.460
probably the case that use of a leader

869
00:47:53.460 --> 00:47:56.610
now speeds up the system by a factor two

870
00:47:56.610 --> 00:47:58.750
and it also makes it sort of easier to

871
00:47:58.750 --> 00:48:04.210
think about what's going on raft goes

872
00:48:04.210 --> 00:48:08.679
through a sequence of leaders and it

873
00:48:08.679 --> 00:48:11.170
uses these term numbers in order to sort

874
00:48:11.170 --> 00:48:13.239
of disambiguate which leader we're

875
00:48:13.239 --> 00:48:14.349
talking about it turns out that

876
00:48:14.349 --> 00:48:15.610
followers don't really need to know the

877
00:48:15.610 --> 00:48:17.380
identity of the leader they really just

878
00:48:17.380 --> 00:48:18.519
need to know what the current term

879
00:48:18.519 --> 00:48:23.199
number is each term has at most one

880
00:48:23.199 --> 00:48:25.989
leader that's a critical property you

881
00:48:25.989 --> 00:48:27.369
know for every term there might be no

882
00:48:31.360 --> 00:48:34.179
leaders during the same term every term

883
00:48:34.179 --> 00:48:42.190
has it must most one leader how do the

884
00:48:42.190 --> 00:48:44.489
leaders get created in the first place

885
00:48:54.130 --> 00:48:56.320
going to do something and the something

886
00:48:56.320 --> 00:48:59.199
that it does is that if an entire leader

887
00:48:59.199 --> 00:49:02.469
election period expires without the

888
00:49:02.469 --> 00:49:04.480
server having heard any message from the

889
00:49:04.480 --> 00:49:08.139
current leader then the server sort of

890
00:49:12.579 --> 00:49:15.480
have this election timer

891
00:49:17.869 --> 00:49:23.630
and if it expires we start an election

892
00:49:28.460 --> 00:49:30.690
and what it means to start an election

893
00:49:30.690 --> 00:49:35.570
is basically that you increment the term

894
00:49:35.570 --> 00:49:38.489
the the candidate the server that's

895
00:49:38.489 --> 00:49:39.929
decided it's going to be a candidate and

896
00:49:39.929 --> 00:49:41.519
sort of force a new election first

897
00:49:41.519 --> 00:49:43.949
increments this term because it wants

898
00:49:43.949 --> 00:49:45.449
them to be a new leader namely itself

899
00:49:45.449 --> 00:49:47.880
and you know leader a term can't have

900
00:49:47.880 --> 00:49:49.170
more than one leader so we got to start

901
00:49:49.170 --> 00:49:51.769
a new term in order to have a new leader

902
00:49:51.769 --> 00:49:54.570
and then it sends out these requests

903
00:49:54.570 --> 00:50:00.840
boats are pea seeds I'm going to send

904
00:50:00.840 --> 00:50:02.820
out a full round of request votes and

905
00:50:02.820 --> 00:50:05.130
you may only have to send out n minus

906
00:50:05.130 --> 00:50:06.449
one requests votes because one of the

907
00:50:06.449 --> 00:50:08.340
rules is that a new candidate always

908
00:50:08.340 --> 00:50:13.530
votes for itself in the election so one

909
00:50:13.530 --> 00:50:16.469
thing to note about this is that it's

910
00:50:16.469 --> 00:50:17.969
not quite the case that if the leader

911
00:50:17.969 --> 00:50:19.380
didn't fail we won't have an election

912
00:50:19.380 --> 00:50:22.349
but if the leader does fail then we will

913
00:50:22.349 --> 00:50:24.480
have election an election assuming any

914
00:50:24.480 --> 00:50:26.400
other server is up because some day the

915
00:50:26.400 --> 00:50:28.230
other servers election timers go will go

916
00:50:28.230 --> 00:50:30.239
off but as leader didn't fail we might

917
00:50:30.239 --> 00:50:32.400
still unfortunately get an election so

918
00:50:32.400 --> 00:50:34.920
if the network is slow or drops a few

919
00:50:38.820 --> 00:50:40.440
though there was a perfectly good leader

920
00:50:40.440 --> 00:50:42.389
we may nevertheless have a new election

921
00:50:42.389 --> 00:50:43.739
so we have to sort of keep that in mind

922
00:50:43.739 --> 00:50:44.639
when we're thinking about the

923
00:50:44.639 --> 00:50:48.510
correctness and what that in turn means

924
00:50:48.510 --> 00:50:50.369
is that if there's a new election it

925
00:50:50.369 --> 00:50:52.409
could easily be the case that the old

926
00:50:52.409 --> 00:50:54.360
leader is still hanging around and still

927
00:50:54.360 --> 00:50:56.190
thinks it's the leader like if there's a

928
00:50:56.190 --> 00:50:58.710
network partition for example and the

929
00:50:58.710 --> 00:51:00.869
old leader is still alive and well in a

930
00:51:00.869 --> 00:51:03.360
minority partition the majority

931
00:51:03.360 --> 00:51:05.280
partition may run an election and indeed

932
00:51:05.280 --> 00:51:06.869
a successful election and choose a new

933
00:51:06.869 --> 00:51:09.989
leader all totally unknown to the

934
00:51:09.989 --> 00:51:11.880
previous leader so we also have to worry

935
00:51:11.880 --> 00:51:13.530
about you know what's that previous

936
00:51:13.530 --> 00:51:15.420
leader gonna do since it does not know

937
00:51:15.420 --> 00:51:19.400
there was a new election yes

938
00:51:42.130 --> 00:51:44.869
okay so the question is are there can

939
00:51:44.869 --> 00:51:46.940
there be pathological cases in which for

940
00:51:46.940 --> 00:51:50.449
example one-way network communication

941
00:51:50.449 --> 00:51:52.340
can prevent the system from making

942
00:51:52.340 --> 00:51:54.550
progress I believe the answer is yes

943
00:51:54.550 --> 00:51:56.929
certainly so for example if the current

944
00:51:56.929 --> 00:52:00.980
leader if its network somehow half fails

945
00:52:00.980 --> 00:52:02.840
in a way the current leader can send out

946
00:52:07.280 --> 00:52:09.949
then the heartbeats that it sends out

947
00:52:09.949 --> 00:52:11.869
which are delivered because it's

948
00:52:11.869 --> 00:52:13.909
outgoing network connection works its

949
00:52:13.909 --> 00:52:18.110
outgoing heartbeats will suppress any

950
00:52:18.110 --> 00:52:20.300
other server from starting an election

951
00:52:20.300 --> 00:52:22.280
but the fact that it's incoming Network

952
00:52:22.280 --> 00:52:24.800
why or apparently is broken will prevent

953
00:52:24.800 --> 00:52:26.719
it from hearing and executing any client

954
00:52:26.719 --> 00:52:29.210
commands it's absolutely the case that

955
00:52:29.210 --> 00:52:35.360
raft is not proof against all sort of

956
00:52:35.360 --> 00:52:37.190
all crazy Network problems that can come

957
00:52:37.190 --> 00:52:38.900
up I believe the ones I've thought about

958
00:52:38.900 --> 00:52:42.260
I believe are fixable in the sense that

959
00:52:42.260 --> 00:52:46.969
the we could solve this one by having a

960
00:52:46.969 --> 00:52:49.340
sort of requiring a two-way heartbeat in

961
00:52:49.340 --> 00:52:51.769
which if the leader sends out heartbeats

962
00:52:51.769 --> 00:52:53.449
but you know there were in which

963
00:52:53.449 --> 00:52:55.699
followers are required to reply in some

964
00:52:55.699 --> 00:52:56.989
way to heartbeats I guess they are

965
00:52:56.989 --> 00:52:59.239
already required to apply if the leader

966
00:52:59.239 --> 00:53:01.869
stop seeing replies to its heartbeats

967
00:53:01.869 --> 00:53:04.460
then after some amount of time and which

968
00:53:04.460 --> 00:53:06.230
is seasonals replies the leader decides

969
00:53:06.230 --> 00:53:09.230
to step down I feel like that specific

970
00:53:09.230 --> 00:53:12.530
issue can be fixed and many others can

971
00:53:17.900 --> 00:53:19.599
happen to networks including some that

972
00:53:19.599 --> 00:53:23.590
the protocol is not prepared for

973
00:53:28.739 --> 00:53:32.260
okay so we got these meter elections we

974
00:53:32.260 --> 00:53:33.849
need to ensure that there is at most at

975
00:53:33.849 --> 00:53:35.440
most one meter per term

976
00:53:40.239 --> 00:53:42.699
requires a candidate to get yes votes

977
00:53:47.980 --> 00:53:52.389
one yes vote per term so in any given

978
00:53:52.389 --> 00:53:55.690
term you know it basically means that in

979
00:53:55.690 --> 00:53:58.179
any given term Easter votes only once

980
00:54:03.280 --> 00:54:06.570
votes because everybody votes only once

981
00:54:06.570 --> 00:54:09.670
so the majorities majority rule causes

982
00:54:09.670 --> 00:54:11.530
there to be at most one winning

983
00:54:11.530 --> 00:54:17.400
candidate and so then we get at most one

984
00:54:17.400 --> 00:54:21.150
candidate elected per turn

985
00:54:24.449 --> 00:54:28.630
and in addition critically the majority

986
00:54:28.630 --> 00:54:31.929
rule means that you can get elected even

987
00:54:31.929 --> 00:54:34.449
if some servers have crashed right if a

988
00:54:37.690 --> 00:54:39.699
still elect a leader if more than half a

989
00:54:39.699 --> 00:54:41.530
crash or not available or in another

990
00:54:41.530 --> 00:54:43.389
partition or something then actually the

991
00:54:43.389 --> 00:54:44.829
system will just sit there trying again

992
00:54:49.480 --> 00:54:54.730
not a majority of live servers if an

993
00:54:54.730 --> 00:54:57.400
election succeeds everybody would be

994
00:54:57.400 --> 00:54:58.960
great if everybody learned about it I

995
00:54:58.960 --> 00:55:01.360
mean need to ask ourselves how do all

996
00:55:01.360 --> 00:55:02.980
the parties learn learn what happened

997
00:55:02.980 --> 00:55:04.750
the server that wins an election

998
00:55:04.750 --> 00:55:07.300
assuming it doesn't crash the server

999
00:55:07.300 --> 00:55:09.550
that wins election will actually see a

1000
00:55:09.550 --> 00:55:12.730
majority or positive votes for its

1001
00:55:12.730 --> 00:55:15.400
request vote from a majority of the

1002
00:55:15.400 --> 00:55:17.739
other servers so the candidates running

1003
00:55:17.739 --> 00:55:19.539
the election that wins it the Kennedy

1004
00:55:19.539 --> 00:55:20.710
that wins the election will actually

1005
00:55:20.710 --> 00:55:22.960
know directly uh I got a majority of

1006
00:55:28.900 --> 00:55:30.789
the way that the candidate informs other

1007
00:55:30.789 --> 00:55:33.670
servers is that heartbeat the rules and

1008
00:55:33.670 --> 00:55:34.869
figure to say oh if you're in an

1009
00:55:34.869 --> 00:55:36.280
election your immediately required to

1010
00:55:36.280 --> 00:55:37.360
send out an independent

1011
00:55:37.360 --> 00:55:39.940
trees to all the other servers now the

1012
00:55:39.940 --> 00:55:41.920
append entries that heartbeat append

1013
00:55:41.920 --> 00:55:45.159
entries doesn't explicitly say I won the

1014
00:55:45.159 --> 00:55:47.829
election you know I'm a leader for term

1015
00:55:53.710 --> 00:55:57.550
communicated is that no one is allowed

1016
00:55:57.550 --> 00:56:00.250
to send out an append entries unless

1017
00:56:00.250 --> 00:56:02.800
they're a leader for that term so the

1018
00:56:02.800 --> 00:56:05.559
fact that I I'm a you know I'm a server

1019
00:56:09.579 --> 00:56:12.730
append entries whose term is 19 that

1020
00:56:19.389 --> 00:56:21.360
receiving append entries for that term

1021
00:56:21.360 --> 00:56:24.670
and that append entries also has the

1022
00:56:24.670 --> 00:56:27.369
effect of resetting everybody's election

1023
00:56:27.369 --> 00:56:30.280
time timer so as long as the leader is

1024
00:56:30.280 --> 00:56:32.110
up and it sends out heartbeat messages

1025
00:56:32.110 --> 00:56:34.599
or append entries at least you know at

1026
00:56:34.599 --> 00:56:36.909
the rate that's supposed to every time a

1027
00:56:36.909 --> 00:56:38.650
server receives an append entries it'll

1028
00:56:38.650 --> 00:56:42.570
reset its selection timer and sort of

1029
00:56:42.570 --> 00:56:45.250
suppress anybody from being a new

1030
00:56:45.250 --> 00:56:47.289
candidate so as long as everything's

1031
00:56:47.289 --> 00:56:49.539
functioning the repeated heartbeats will

1032
00:56:49.539 --> 00:56:52.300
prevent any further elections of course

1033
00:56:52.300 --> 00:56:53.860
it the network fails or packets are

1034
00:56:53.860 --> 00:56:55.570
dropped there may nevertheless be an

1035
00:56:55.570 --> 00:56:57.880
election but if all goes well we're sort

1036
00:56:57.880 --> 00:57:03.489
of unlikely to get an election this

1037
00:57:03.489 --> 00:57:05.739
scheme could fail in the sense that it

1038
00:57:05.739 --> 00:57:07.329
can't fail in the sense of electing to

1039
00:57:07.329 --> 00:57:09.849
leaders fair term but it can fail in the

1040
00:57:09.849 --> 00:57:11.380
sense of electing zero leaders for a

1041
00:57:11.380 --> 00:57:14.320
term that's sort of morningway it may

1042
00:57:14.320 --> 00:57:16.210
fail is that if too many servers are

1043
00:57:16.210 --> 00:57:18.280
dead or unavailable or a bad network

1044
00:57:18.280 --> 00:57:19.690
connection so if you can't assemble a

1045
00:57:19.690 --> 00:57:21.880
majority you can't be elected nothing

1046
00:57:21.880 --> 00:57:24.489
happens the more interesting way in

1047
00:57:24.489 --> 00:57:27.150
which an election can fail is if

1048
00:57:33.130 --> 00:57:35.800
leaders become candidate close together

1049
00:57:35.800 --> 00:57:38.500
enough in time that they split the vote

1050
00:57:38.500 --> 00:57:43.110
between them or say three leaders

1051
00:57:46.369 --> 00:57:49.179
supposing we have a three replica system

1052
00:57:49.179 --> 00:57:51.860
all their election timers go off at the

1053
00:57:51.860 --> 00:57:54.760
same time every server both for itself

1054
00:57:54.760 --> 00:57:57.650
and then when each of them receives a

1055
00:58:00.710 --> 00:58:02.780
and so it says no so that means that it

1056
00:58:05.929 --> 00:58:09.800
nobody's elected so then their election

1057
00:58:09.800 --> 00:58:11.449
timers will go off again because the

1058
00:58:11.449 --> 00:58:12.889
election timers only be said if it gets

1059
00:58:12.889 --> 00:58:14.360
an append entries but there's no leader

1060
00:58:14.360 --> 00:58:16.460
so no append entries they'll all have

1061
00:58:16.460 --> 00:58:17.929
their election timers go off again and

1062
00:58:20.269 --> 00:58:22.159
they'll all go for themselves nobody

1063
00:58:22.159 --> 00:58:27.139
will get a majority so so clearly I'm

1064
00:58:27.139 --> 00:58:28.360
sure you're all aware at this point

1065
00:58:28.360 --> 00:58:31.519
there's more to this story and the way

1066
00:58:31.519 --> 00:58:35.630
Raft makes this possibility of split

1067
00:58:35.630 --> 00:58:38.719
votes unlikely but not impossible

1068
00:58:44.210 --> 00:58:46.400
randomization the way to think of it is

1069
00:58:46.400 --> 00:58:47.900
that supposing you have some time line

1070
00:58:47.900 --> 00:58:52.130
I'm gonna draw a vents on there's some

1071
00:58:52.130 --> 00:58:54.170
point at which everybody received the

1072
00:58:54.170 --> 00:58:57.440
last append entries right and then maybe

1073
00:58:57.440 --> 00:58:58.789
the server died let's just assume the

1074
00:59:08.110 --> 00:59:11.119
this we set their election timers when

1075
00:59:11.119 --> 00:59:13.159
they received at the same time because

1076
00:59:13.159 --> 00:59:14.570
they probably all receive this append

1077
00:59:18.289 --> 00:59:21.530
the future the future but they chose

1078
00:59:21.530 --> 00:59:23.630
different random times in the future

1079
00:59:23.630 --> 00:59:25.369
which then we're gonna go off

1080
00:59:30.230 --> 00:59:32.360
this point set their election timers for

1081
00:59:43.880 --> 00:59:46.210
crucial point about this picture is that

1082
00:59:51.260 --> 00:59:54.559
other one is second right that's what's

1083
00:59:54.559 --> 00:59:56.599
going on here and the one that's first

1084
01:00:01.400 --> 01:00:02.869
first before the other ones election

1085
01:00:02.869 --> 01:00:05.929
timer and if we're close were not

1086
01:00:05.929 --> 01:00:06.409
unlucky

1087
01:00:06.409 --> 01:00:08.420
it'll have time to send out a full round

1088
01:00:08.420 --> 01:00:11.750
of vote requests and get answers from

1089
01:00:11.750 --> 01:00:13.630
everybody who everybody's alive before

1090
01:00:13.630 --> 01:00:16.820
the second election timer goes off from

1091
01:00:16.820 --> 01:00:22.570
any other server so does everybody see

1092
01:00:22.570 --> 01:00:26.139
how the randomization D synchronizes

1093
01:00:26.139 --> 01:00:30.710
these candidates unfortunately there's a

1094
01:00:30.710 --> 01:00:33.230
bit of art in setting the contents

1095
01:00:33.230 --> 01:00:34.969
constants for these election timers

1096
01:00:34.969 --> 01:00:36.489
there's some sort of competing

1097
01:00:36.489 --> 01:00:40.210
requirements you might want to fulfill

1098
01:00:40.210 --> 01:00:43.309
so one obvious requirement is that the

1099
01:00:43.309 --> 01:00:45.230
election timer has to be at least as

1100
01:00:47.809 --> 01:00:49.789
you know this is pretty obvious that the

1101
01:00:49.789 --> 01:00:51.409
leader sends out heartbeats every

1102
01:00:51.409 --> 01:00:53.690
hundred milliseconds you better make

1103
01:00:53.690 --> 01:00:55.519
sure there's no point in having the

1104
01:00:55.519 --> 01:00:57.320
election time or anybody's election time

1105
01:00:57.320 --> 01:00:58.849
or ever go off Borja for 100

1106
01:00:58.849 --> 01:01:00.530
milliseconds because then it will go off

1107
01:01:00.530 --> 01:01:06.800
before the lower limit is certainly the

1108
01:01:06.800 --> 01:01:08.570
lower limit is one heartbeat interval in

1109
01:01:08.570 --> 01:01:10.940
fact because the network may drop

1110
01:01:10.940 --> 01:01:13.699
packets you probably want to have the

1111
01:01:13.699 --> 01:01:16.309
minimum election timer value be a couple

1112
01:01:16.309 --> 01:01:18.829
of times the heartbeat interval so 400

1113
01:01:21.440 --> 01:01:24.320
election time or be you know say 300

1114
01:01:24.320 --> 01:01:26.119
milliseconds you know three times the

1115
01:01:26.119 --> 01:01:29.449
heartbeat interval so that's the sort of

1116
01:01:29.449 --> 01:01:33.710
minimum is the heart heartbeat so this

1117
01:01:33.710 --> 01:01:35.570
frequent you want the minimum to be you

1118
01:01:35.570 --> 01:01:39.469
know a couple of times that or here so

1119
01:01:39.469 --> 01:01:40.639
what about the maximum you know you're

1120
01:01:45.710 --> 01:01:50.960
should we set the kind of maximum time

1121
01:01:50.960 --> 01:01:54.710
that we're randomizing over there's a

1122
01:01:54.710 --> 01:01:57.739
couple of considerations here in a real

1123
01:01:57.739 --> 01:02:04.409
system you know this maximum time effect

1124
01:02:04.409 --> 01:02:06.239
how quickly the system can recover from

1125
01:02:06.239 --> 01:02:09.420
failure because remember from the time

1126
01:02:09.420 --> 01:02:11.909
at which the server fails until the

1127
01:02:11.909 --> 01:02:14.730
first election timer goes off the whole

1128
01:02:14.730 --> 01:02:17.429
system is frozen there's no leader you

1129
01:02:17.429 --> 01:02:18.869
know the clients requests are being

1130
01:02:18.869 --> 01:02:20.190
thrown away because there's no leader

1131
01:02:20.190 --> 01:02:22.320
and we're not assigning a new leader

1132
01:02:22.320 --> 01:02:24.869
even though you know presumably these

1133
01:02:24.869 --> 01:02:27.389
other servers are up so the beer we

1134
01:02:27.389 --> 01:02:29.670
choose this maximum the long or delay

1135
01:02:34.769 --> 01:02:38.219
important depends on sort of how high

1136
01:02:38.219 --> 01:02:40.199
performance we need this to be and how

1137
01:02:40.199 --> 01:02:42.869
often we think there will be failures

1138
01:02:42.869 --> 01:02:44.909
failures happen once a year then who

1139
01:02:44.909 --> 01:02:46.309
cares

1140
01:02:46.309 --> 01:02:48.599
we're expecting failures frequently we

1141
01:02:48.599 --> 01:02:51.329
may care very much how long it takes to

1142
01:02:51.329 --> 01:02:53.670
recover okay so that's one consideration

1143
01:02:53.670 --> 01:02:56.329
the other consideration is that this gap

1144
01:02:56.329 --> 01:02:59.400
that is the expected gap in time between

1145
01:02:59.400 --> 01:03:01.409
the first time are going off and the

1146
01:03:01.409 --> 01:03:04.889
second timer going off this gap really

1147
01:03:04.889 --> 01:03:07.889
in order to be useful has to be longer

1148
01:03:07.889 --> 01:03:09.929
than the time it takes for the candidate

1149
01:03:09.929 --> 01:03:12.329
to assemble votes from everybody that is

1150
01:03:21.840 --> 01:03:25.860
get a response a response from all the

1151
01:03:25.860 --> 01:03:27.809
other servers and if that's the case we

1152
01:03:27.809 --> 01:03:28.980
need to make maximum at least long

1153
01:03:28.980 --> 01:03:30.570
enough that there's pretty likely to be

1154
01:03:30.570 --> 01:03:32.219
10 milliseconds difference between the

1155
01:03:32.219 --> 01:03:34.110
smallest random number and the next

1156
01:03:40.550 --> 01:03:46.469
and for you the test code will get upset

1157
01:03:46.469 --> 01:03:54.360
if you if you don't recover from a

1158
01:03:54.360 --> 01:03:56.849
leader failure in a couple seconds and

1159
01:03:56.849 --> 01:03:58.920
so just pragmatically you need to tune

1160
01:03:58.920 --> 01:04:00.989
this maximum down so that it's highly

1161
01:04:00.989 --> 01:04:03.719
likely that you'll be able to complete a

1162
01:04:03.719 --> 01:04:05.940
leader election within a few seconds but

1163
01:04:05.940 --> 01:04:09.539
that's not a very tight constraint any

1164
01:04:09.539 --> 01:04:13.670
questions about the election time outs

1165
01:04:13.670 --> 01:04:19.909
one tiny point is that you want to

1166
01:04:19.909 --> 01:04:23.190
choose new random time outs every time

1167
01:04:23.190 --> 01:04:26.699
there's every time you every time I node

1168
01:04:26.699 --> 01:04:28.739
sets it to like me sets its election

1169
01:04:28.739 --> 01:04:31.230
timer that is don't choose a random

1170
01:04:31.230 --> 01:04:34.829
number when the server is first created

1171
01:04:37.469 --> 01:04:39.719
unlucky choice that is you choose this

1172
01:04:39.719 --> 01:04:42.269
one server happens by ill chance to

1173
01:04:42.269 --> 01:04:44.159
choose the same random number as another

1174
01:04:48.829 --> 01:04:51.300
that's why you want to almost certainly

1175
01:04:51.300 --> 01:04:53.340
choose a different a new fresh random

1176
01:04:53.340 --> 01:04:56.130
number for the election time out value

1177
01:04:56.130 --> 01:05:02.940
every time you reset the timer all right

1178
01:05:02.940 --> 01:05:06.800
so the final issue about leader election

1179
01:05:11.190 --> 01:05:12.960
network cable is broken and the old

1180
01:05:12.960 --> 01:05:14.789
leader is sort of out there with a

1181
01:05:14.789 --> 01:05:17.219
couple clients and a minority of servers

1182
01:05:17.219 --> 01:05:20.519
and there's a majority in the other half

1183
01:05:20.519 --> 01:05:21.630
of the network and the majority of the

1184
01:05:21.630 --> 01:05:22.710
new half of the network elects a new

1185
01:05:22.710 --> 01:05:28.199
leader what about the old leader why why

1186
01:05:28.199 --> 01:05:32.789
won't the old leader cause incorrect

1187
01:05:32.789 --> 01:05:35.389
execution

1188
01:06:06.309 --> 01:06:09.980
yes to two potential problems one is or

1189
01:06:09.980 --> 01:06:12.860
one some non problem is that if there's

1190
01:06:12.860 --> 01:06:14.510
a leader off in another partition and it

1191
01:06:20.929 --> 01:06:24.260
that leader that you know in a partition

1192
01:06:24.260 --> 01:06:25.400
with a minority yeah it'll send out

1193
01:06:25.400 --> 01:06:27.500
append entries but because it's in the

1194
01:06:27.500 --> 01:06:29.929
minority partition it won't be able to

1195
01:06:29.929 --> 01:06:31.940
get responses back from a majority of

1196
01:06:31.940 --> 01:06:33.860
the server's including itself and so it

1197
01:06:33.860 --> 01:06:36.110
will never commit the operation it will

1198
01:06:39.829 --> 01:06:42.469
that it executed it either and so that

1199
01:06:42.469 --> 01:06:45.860
means that yeah an old server often a

1200
01:06:45.860 --> 01:06:47.929
different partition people many clients

1201
01:06:47.929 --> 01:06:49.670
may send a request but they'll never get

1202
01:07:24.829 --> 01:07:27.760
spend a good 45 minutes talking about

1203
01:07:33.260 --> 01:07:40.389
about in leader election okay

1204
01:07:42.219 --> 01:07:44.929
okay so how about the contents of the

1205
01:07:44.929 --> 01:07:49.159
logs and how in particular how a newly

1206
01:07:49.159 --> 01:07:51.739
elected leader possibly picking up the

1207
01:07:51.739 --> 01:07:54.440
pieces after an awkward crash of the

1208
01:07:54.440 --> 01:07:56.750
previous leader how does a newly elected

1209
01:07:56.750 --> 01:07:59.630
leader sort out the possibly divergent

1210
01:07:59.630 --> 01:08:02.300
logs on the different replicas in order

1211
01:08:02.300 --> 01:08:06.139
to restore sort of consistent state in

1212
01:08:06.139 --> 01:08:14.659
the system all right so the first

1213
01:08:14.659 --> 01:08:17.869
question is what can think this is this

1214
01:08:17.869 --> 01:08:19.670
whole topic it's really only interesting

1215
01:08:19.670 --> 01:08:21.920
after a server crashes right if the

1216
01:08:21.920 --> 01:08:25.460
server stays up then relatively few

1217
01:08:25.460 --> 01:08:26.930
things can go wrong if we have a server

1218
01:08:26.930 --> 01:08:28.640
that's up and has a majority you know

1219
01:08:28.640 --> 01:08:29.869
during the period of time when it's up

1220
01:08:35.899 --> 01:08:37.760
and the followers are not allowed to

1221
01:08:37.760 --> 01:08:39.649
disagree they're required to accept they

1222
01:08:39.649 --> 01:08:41.420
just do by the rules of figure two if

1223
01:08:41.420 --> 01:08:43.100
they've been more or less keeping up you

1224
01:08:43.100 --> 01:08:44.659
know they just take whatever the leader

1225
01:08:44.659 --> 01:08:46.220
sends them independent reason appended

1226
01:08:46.220 --> 01:08:48.500
to the log and obey commit messages and

1227
01:08:48.500 --> 01:08:50.300
execute there's hardly anything to go

1228
01:08:55.609 --> 01:08:58.520
sort of midway through you know sending

1229
01:08:58.520 --> 01:09:01.939
out messages or a new leader crashes you

1230
01:09:01.939 --> 01:09:03.229
know sort of just after it's been

1231
01:09:03.229 --> 01:09:06.949
elected but before it's done anything

1232
01:09:06.949 --> 01:09:10.130
very useful so one thing we're very

1233
01:09:10.130 --> 01:09:11.779
interested in is what can the logs look

1234
01:09:11.779 --> 01:09:16.670
like after some sequence of crashes okay

1235
01:09:16.670 --> 01:09:19.520
so here's an example supposing we have

1236
01:09:19.520 --> 01:09:26.180
two servers and the way I'm gonna draw

1237
01:09:26.180 --> 01:09:27.590
out these diagrams because we're gonna

1238
01:09:27.590 --> 01:09:30.880
be looking a lot at a lot of sort of

1239
01:09:30.880 --> 01:09:32.989
situations where the logs look like this

1240
01:09:32.989 --> 01:09:34.789
and we're gonna be wondering is that

1241
01:09:34.789 --> 01:09:36.649
possible and what happens if they do

1242
01:09:36.649 --> 01:09:38.479
look like that so my notation is going

1243
01:09:38.479 --> 01:09:40.369
to be I'm gonna write out log entries

1244
01:09:40.369 --> 01:09:44.869
for each of the servers sort of aligned

1245
01:09:44.869 --> 01:09:47.840
to indicate slots corresponding slots in

1246
01:09:47.840 --> 01:09:50.270
the log and the values I'm going to

1247
01:09:50.270 --> 01:09:53.329
write here are the term numbers rather

1248
01:09:53.329 --> 01:09:54.340
than

1249
01:09:54.340 --> 01:09:56.890
client operations I'm going to you know

1250
01:09:56.890 --> 01:09:59.220
this is slot one this is thought to

1251
01:09:59.220 --> 01:10:02.380
everybody saw a command from term three

1252
01:10:02.380 --> 01:10:05.229
in slot 1 and server tuned server three

1253
01:10:05.229 --> 01:10:08.319
saw command from also term three and the

1254
01:10:08.319 --> 01:10:10.239
second slot the server one has nothing

1255
01:10:10.239 --> 01:10:14.800
there at all and so question for this

1256
01:10:14.800 --> 01:10:16.479
like the very first question is can this

1257
01:10:16.479 --> 01:10:21.659
arrive could this setup arise and how

1258
01:10:21.659 --> 01:10:24.659
yes

1259
01:11:02.130 --> 01:11:04.840
so you know maybe server 3 was the

1260
01:11:04.840 --> 01:11:06.279
leader for just repeating what you said

1261
01:11:06.279 --> 01:11:08.319
maybe server 3 is the leader for term 3

1262
01:11:08.319 --> 01:11:09.970
he got a command that sent out to

1263
01:11:09.970 --> 01:11:11.380
everybody everybody received a dependent

1264
01:11:11.380 --> 01:11:14.350
at the log and then I got a server 3 got

1265
01:11:14.350 --> 01:11:18.159
a second request from a client and maybe

1266
01:11:18.159 --> 01:11:19.810
it sent it to all three servers but the

1267
01:11:19.810 --> 01:11:21.130
message got lost on the way to server

1268
01:11:28.149 --> 01:11:29.829
log before it sends out append entries

1269
01:11:29.829 --> 01:11:32.380
and maybe the append entry RPC only got

1270
01:11:32.380 --> 01:11:34.390
to server 2 so this situation you know

1271
01:11:34.390 --> 01:11:36.159
it's like the simplest situation and was

1272
01:11:36.159 --> 01:11:38.460
actually the logs are not different and

1273
01:11:38.460 --> 01:11:43.479
we know how it could possibly arise and

1274
01:11:43.479 --> 01:11:45.250
so if server 3 which is a leadership

1275
01:11:45.250 --> 01:11:46.479
crash now you know the next server

1276
01:11:46.479 --> 01:11:49.300
they're gonna need to make sure server 1

1277
01:11:49.300 --> 01:11:54.819
well first of all if server 3 crashes or

1278
01:11:54.819 --> 01:11:56.140
we'll be at an election and some of the

1279
01:11:56.140 --> 01:11:57.789
leader is chosen you know two things

1280
01:11:57.789 --> 01:12:00.159
have to happen the new leader has got to

1281
01:12:00.159 --> 01:12:04.989
recognize that this command could have

1282
01:12:04.989 --> 01:12:06.909
committed it's not allowed to throw it

1283
01:12:06.909 --> 01:12:07.750
away

1284
01:12:07.750 --> 01:12:09.939
and it needs to make sure server one

1285
01:12:13.600 --> 01:12:17.949
else had in that slot all right so after

1286
01:12:17.949 --> 01:12:20.439
a crash somebody you know server 3

1287
01:12:20.439 --> 01:12:22.420
suppose another way this can come up is

1288
01:12:22.420 --> 01:12:24.159
server 3 might have sent out the append

1289
01:12:24.159 --> 01:12:26.140
entries the server 2 but then crashed

1290
01:12:26.140 --> 01:12:27.699
before sending the append entries to

1291
01:12:27.699 --> 01:12:30.399
server 3 so if were you know electing a

1292
01:12:30.399 --> 01:12:32.409
new leader it could because we got a

1293
01:12:32.409 --> 01:12:34.529
crash before the message was sent

1294
01:12:44.829 --> 01:12:48.189
the slots in the law and so we can refer

1295
01:12:48.189 --> 01:12:55.560
to them got slot 10 11 12 13

1296
01:12:55.729 --> 01:12:57.149
[Music]

1297
01:12:57.149 --> 01:13:04.359
again it's same setup except now we have

1298
01:13:04.359 --> 01:13:07.779
in slide 12 we have server 2 as a

1299
01:13:07.779 --> 01:13:11.170
command from term for and server 3 has a

1300
01:13:11.170 --> 01:13:14.729
term command from term 5

1301
01:13:15.789 --> 01:13:19.609
so you know before we analyze these to

1302
01:13:19.609 --> 01:13:21.470
figure out what would happen and what

1303
01:13:21.470 --> 01:13:22.970
would a server do if it saw this we need

1304
01:13:22.970 --> 01:13:24.979
to ask could this even occur because

1305
01:13:28.520 --> 01:13:30.619
configuration arose sometimes the answer

1306
01:13:30.619 --> 01:13:32.899
is it cannot arise so we do not have to

1307
01:13:32.899 --> 01:13:37.130
worry about it the question is could

1308
01:13:37.130 --> 01:13:39.939
this arise and how

1309
01:13:57.899 --> 01:14:02.989
all right so any

1310
01:14:12.819 --> 01:14:15.909
[Music]

1311
01:14:52.659 --> 01:14:55.659
yeah

1312
01:15:02.430 --> 01:15:05.670
arise and so the way we can then get the

1313
01:15:05.670 --> 01:15:07.529
four and a five here is let's suppose in

1314
01:15:07.529 --> 01:15:08.909
the next leader election server twos

1315
01:15:08.909 --> 01:15:11.699
elected leader now for term for its

1316
01:15:11.699 --> 01:15:13.439
elected leader because a request from a

1317
01:15:13.439 --> 01:15:15.899
client it appends it to its own log and

1318
01:15:21.479 --> 01:15:25.409
just crashed now in this election and

1319
01:15:25.409 --> 01:15:27.510
then so now we have to ask whether who

1320
01:15:27.510 --> 01:15:29.369
could be elected or we have to give him

1321
01:15:29.369 --> 01:15:30.720
back of our heads oh gosh what could be

1322
01:15:30.720 --> 01:15:32.729
elected so we're gonna claim server

1323
01:15:32.729 --> 01:15:34.470
three could be elected the reason why I

1324
01:15:34.470 --> 01:15:35.760
could be elected is because it only

1325
01:15:35.760 --> 01:15:38.130
needs request vote responses from

1326
01:15:38.130 --> 01:15:40.500
majority that majority is server one and

1327
01:15:40.500 --> 01:15:42.779
server three you know there's no no

1328
01:15:42.779 --> 01:15:44.369
problem no conflict between these two

1329
01:15:44.369 --> 01:15:46.560
logs so server three can be elected for

1330
01:15:46.560 --> 01:15:48.770
term five get a request from a client

1331
01:15:48.770 --> 01:15:51.810
append it to its own log and crash and

1332
01:15:51.810 --> 01:15:54.180
that's how you get this this

1333
01:15:54.180 --> 01:15:57.149
configuration so you know you need to be

1334
01:15:57.149 --> 01:16:04.140
able to to work through these things in

1335
01:16:04.140 --> 01:16:05.789
order to get to the stage of saying yes

1336
01:16:05.789 --> 01:16:07.140
this could happen and therefore raft

1337
01:16:07.140 --> 01:16:09.390
must do something sensible as opposed to

1338
01:16:09.390 --> 01:16:11.310
it cannot happen because some things

1339
01:16:11.310 --> 01:16:13.729
can't happen

1340
01:16:17.539 --> 01:16:23.930
all right so so what can happen now we

1341
01:16:29.109 --> 01:16:34.550
does something sensible now as for the

1342
01:16:34.550 --> 01:16:36.770
range of things before we talk about

1343
01:16:36.770 --> 01:16:39.859
what RAF would actually would actually

1344
01:16:39.859 --> 01:16:43.609
do we need to have some sense of what

1345
01:16:43.609 --> 01:16:48.489
would be an acceptable outcome right and

1346
01:16:48.489 --> 01:16:53.449
just eyeballing this we know that the

1347
01:16:53.449 --> 01:16:55.189
command in slot 10 since it's known by

1348
01:17:05.659 --> 01:17:06.949
could for all we know have been

1349
01:17:06.949 --> 01:17:09.380
committed so we can't throw it away the

1350
01:17:09.380 --> 01:17:11.300
command in slot 12 however neither of

1351
01:17:11.300 --> 01:17:13.189
them could possibly have been committed

1352
01:17:13.189 --> 01:17:16.149
so we're entitled we don't know haven't

1353
01:17:16.149 --> 01:17:18.739
we'll actually do but raft is entitled

1354
01:17:18.739 --> 01:17:21.680
to drop both of these even though it is

1355
01:17:21.680 --> 01:17:23.479
not entitled to drop it and either of

1356
01:17:23.479 --> 01:17:26.890
the commands in a 10 or 11

1357
01:17:26.890 --> 01:17:28.850
this is entitled dropped it's not

1358
01:17:28.850 --> 01:17:31.579
required to drop either one of them but

1359
01:17:31.579 --> 01:17:33.380
I mean oh it certainly must drop one at

1360
01:17:33.380 --> 01:17:35.329
least one because you have to have

1361
01:17:35.329 --> 01:17:39.640
identical log contents in the end

1362
01:17:43.289 --> 01:17:47.560
this could have been committed it the we

1363
01:17:47.560 --> 01:17:50.100
can't tell by looking at the laws

1364
01:17:50.100 --> 01:17:52.329
exactly how far the leader got before

1365
01:17:52.329 --> 01:17:55.510
crashing so one possibility is that for

1366
01:17:55.510 --> 01:17:59.140
this command or even this command one

1367
01:17:59.140 --> 01:18:00.789
possibility is that leaders send out the

1368
01:18:00.789 --> 01:18:02.829
append messages with a new command and

1369
01:18:02.829 --> 01:18:05.619
then immediately crashed so it never got

1370
01:18:05.619 --> 01:18:08.109
any response back because it crashed so

1371
01:18:08.109 --> 01:18:09.640
the old leader did not know if it was

1372
01:18:09.640 --> 01:18:12.340
committed and if it didn't get a

1373
01:18:12.340 --> 01:18:14.409
response back that means it didn't

1374
01:18:14.409 --> 01:18:17.590
execute it and it didn't send out but

1375
01:18:17.590 --> 01:18:18.939
you know it didn't send out that

1376
01:18:18.939 --> 01:18:22.239
incremented commit index and so maybe

1377
01:18:22.239 --> 01:18:24.609
the replicas didn't execute it either so

1378
01:18:24.609 --> 01:18:26.949
it's actually possible that this wasn't

1379
01:18:26.949 --> 01:18:29.979
committed so even though RAF doesn't

1380
01:18:29.979 --> 01:18:35.609
know it could be legal for raft

1381
01:18:35.609 --> 01:18:40.779
if raft knew more than it does know it

1382
01:18:40.779 --> 01:18:43.600
might be legal to drop this log entry

1383
01:18:52.989 --> 01:18:55.300
committed and raft can't prove it wasn't

1384
01:18:55.300 --> 01:18:58.449
so it must treat it as committed because

1385
01:19:03.310 --> 01:19:05.619
append entry replies and replying to the

1386
01:19:05.619 --> 01:19:08.260
client so just looking at this we can't

1387
01:19:08.260 --> 01:19:10.600
rule out the possibility that either

1388
01:19:10.600 --> 01:19:14.140
possibility that the leader responded to

1389
01:19:14.140 --> 01:19:15.789
the client in which case we cannot throw

1390
01:19:15.789 --> 01:19:17.229
away this entry because a client knows

1391
01:19:17.229 --> 01:19:18.970
about it or the possibility the leader

1392
01:19:33.390 --> 01:19:36.390
yeah

1393
01:19:46.489 --> 01:19:51.590
no there's no maana server crash before

1394
01:19:51.590 --> 01:19:53.630
getting the response it's alright well

1395
01:19:53.600 --> 01:19:53.730
let's continue this on Thursday

