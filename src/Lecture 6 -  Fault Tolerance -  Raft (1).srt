1
00:00:00,670 --> 00:00:06,769
all right well let's get started

2
00:00:06,969 --> 00:00:10,290
today and indeed today and tomorrow I'm

3
00:00:10,490 --> 00:00:14,129
gonna talk about raft both because I

4
00:00:14,329 --> 00:00:16,039
hope it'll be helpful you for you in

5
00:00:16,239 --> 00:00:19,140
implanting though the labs and also

6
00:00:19,339 --> 00:00:21,449
because you know it's just a case study

7
00:00:21,649 --> 00:00:23,010
in the details of how to get state

8
00:00:23,210 --> 00:00:28,350
machine replication correct so we have

9
00:00:28,550 --> 00:00:30,870
introduction to the problem you may have

10
00:00:31,070 --> 00:00:33,748
noticed a pattern in fault-tolerant

11
00:00:33,948 --> 00:00:35,599
systems that we've looked at so far

12
00:00:35,799 --> 00:00:40,439
one is that MapReduce replicates

13
00:00:40,640 --> 00:00:43,439
computation but the replication is

14
00:00:43,640 --> 00:00:45,748
controlled the whole computation is

15
00:00:45,948 --> 00:00:49,919
controlled by a single master another

16
00:00:50,119 --> 00:00:51,928
example I'd like to draw your attention

17
00:00:52,128 --> 00:00:55,138
to is that GFS replicates data right as

18
00:00:55,338 --> 00:00:56,579
this primary backup scheme for

19
00:00:56,780 --> 00:00:58,349
replicating the actual contents of files

20
00:00:58,549 --> 00:01:01,288
but it relies on a single master to

21
00:01:01,488 --> 00:01:03,509
choose who the primary is for every

22
00:01:03,710 --> 00:01:07,709
piece of data another example vmware ft

23
00:01:07,909 --> 00:01:09,509
replicates computational write on a

24
00:01:09,709 --> 00:01:11,640
primary virtual machine and a backup

25
00:01:11,840 --> 00:01:14,429
virtual machine but in order to figure

26
00:01:14,629 --> 00:01:16,049
out what to do next if one of them seems

27
00:01:16,250 --> 00:01:18,988
to a fail it relies on a single test and

28
00:01:19,188 --> 00:01:21,808
set server to help the choose to help it

29
00:01:22,009 --> 00:01:23,518
ensure that exactly one of the primary

30
00:01:23,718 --> 00:01:25,980
of the backup takes over if there's some

31
00:01:26,180 --> 00:01:29,189
kind of failure so in all three of these

32
00:01:29,390 --> 00:01:31,619
cases sure there was a replication

33
00:01:31,819 --> 00:01:34,018
system but sort of tucked away in a

34
00:01:34,218 --> 00:01:35,878
corner in the replication system there

35
00:01:36,078 --> 00:01:37,679
was some scheme where a single entity

36
00:01:37,879 --> 00:01:39,988
was required to make a critical decision

37
00:01:40,188 --> 00:01:43,349
about who the primary was in the cases

38
00:01:43,549 --> 00:01:47,009
we care about so a very nice thing about

39
00:01:47,209 --> 00:01:49,918
having a single entity decide who's

40
00:01:50,118 --> 00:01:52,918
gonna be the primary is that it can't

41
00:01:53,118 --> 00:01:55,259
disagree with itself right there's only

42
00:01:55,459 --> 00:01:57,418
one of it makes some decision that's the

43
00:01:57,618 --> 00:02:00,719
decision it made but the bad thing about

44
00:02:00,920 --> 00:02:02,819
having a single entity decide like who

45
00:02:03,019 --> 00:02:04,649
the primary is is that it itself as a

46
00:02:04,849 --> 00:02:06,390
single point of failure and so you can

47
00:02:06,590 --> 00:02:07,918
view these systems that we've looked at

48
00:02:08,118 --> 00:02:11,750
it sort of pushing the real heart of the

49
00:02:11,949 --> 00:02:13,590
fault tolerance

50
00:02:13,789 --> 00:02:16,410
Machinery into a little corner that is

51
00:02:16,610 --> 00:02:18,420
the single entity that decides who's

52
00:02:18,620 --> 00:02:20,519
going to be the primary if there's a

53
00:02:20,718 --> 00:02:23,610
failure now this whole thing is about

54
00:02:23,810 --> 00:02:25,230
how to avoid split brain the reason why

55
00:02:25,430 --> 00:02:27,360
we have to have have to be extremely

56
00:02:27,560 --> 00:02:29,789
careful about making the decision about

57
00:02:29,989 --> 00:02:31,319
who should be the primary if there's a

58
00:02:31,519 --> 00:02:33,750
failure is that otherwise we risks split

59
00:02:33,949 --> 00:02:37,830
brain and just make this point super

60
00:02:38,030 --> 00:02:44,909
clear I'm gonna just remind you what the

61
00:02:45,109 --> 00:02:47,039
problem is and why it's a serious

62
00:02:47,239 --> 00:02:49,789
problem so supposing for example where

63
00:02:49,989 --> 00:02:52,739
we want to build ourselves a replicated

64
00:02:52,938 --> 00:02:54,209
test and set server that is we're

65
00:02:54,408 --> 00:02:56,189
worried about the fact that vmware ft

66
00:02:56,389 --> 00:02:58,409
relies on this test and set server to

67
00:02:58,609 --> 00:03:00,360
choose who the primary is so let's build

68
00:03:00,560 --> 00:03:02,550
a replicated testing set server i'm

69
00:03:02,750 --> 00:03:04,319
gonna do this it's gonna be broken it's

70
00:03:04,519 --> 00:03:08,759
just an illustration for why why it's

71
00:03:08,959 --> 00:03:10,409
difficult to get this but brain problem

72
00:03:10,609 --> 00:03:11,819
correctly so you know we're gonna

73
00:03:12,019 --> 00:03:16,110
imagine we have a network and maybe two

74
00:03:16,310 --> 00:03:18,179
servers which are supposed to be

75
00:03:18,378 --> 00:03:20,819
replicas of our test and set service

76
00:03:21,019 --> 00:03:22,980
connected and you know maybe two clients

77
00:03:23,180 --> 00:03:24,749
they need to know who's the primary

78
00:03:24,949 --> 00:03:26,340
right now or actually maybe these

79
00:03:26,539 --> 00:03:28,740
clients in this case are the primary in

80
00:03:28,939 --> 00:03:34,469
the back up in vmware ft so if it's a

81
00:03:34,669 --> 00:03:35,969
test and set service then you know both

82
00:03:36,169 --> 00:03:37,920
these databases mostly servers start out

83
00:03:38,120 --> 00:03:40,080
with their state that is the state of

84
00:03:40,280 --> 00:03:42,420
this test flight back in zero and the

85
00:03:42,620 --> 00:03:44,520
one operation their clients can send is

86
00:03:44,719 --> 00:03:46,050
the test and set operation which is

87
00:03:46,250 --> 00:03:50,550
supposed to set the flag of the

88
00:03:50,750 --> 00:03:52,679
replicated service to one so i should

89
00:03:52,878 --> 00:03:54,990
set both copies and then return the old

90
00:03:55,189 --> 00:03:57,300
value so it's essentially acts as a kind

91
00:03:57,500 --> 00:04:02,310
of simplified lock server okay so the

92
00:04:02,509 --> 00:04:05,399
problem situation the lowly worried

93
00:04:05,598 --> 00:04:08,730
about split-brain arises when a client

94
00:04:08,930 --> 00:04:11,039
can talk to one of the servers but can't

95
00:04:11,239 --> 00:04:12,569
talk to the other so we're imagining

96
00:04:12,769 --> 00:04:14,789
either that when clients send a request

97
00:04:14,989 --> 00:04:17,610
they send it to both I'm just gonna

98
00:04:17,810 --> 00:04:18,959
assume that now and almost doesn't

99
00:04:19,158 --> 00:04:20,730
matter so let's assume that the protocol

100
00:04:20,930 --> 00:04:21,990
is that the clients supposed to send

101
00:04:22,189 --> 00:04:24,180
ordinarily any request to both servers

102
00:04:24,379 --> 00:04:27,060
and somehow we you know we need

103
00:04:27,259 --> 00:04:29,129
think through what the clients should do

104
00:04:29,329 --> 00:04:31,069
if one of the server's doesn't respond

105
00:04:31,269 --> 00:04:33,210
right or what the system should do if

106
00:04:33,410 --> 00:04:34,379
one of the server seems to gotten

107
00:04:34,579 --> 00:04:38,100
responsive so let's imagine now the

108
00:04:38,300 --> 00:04:40,139
client one can contact server one but

109
00:04:40,339 --> 00:04:42,000
not server two how should the system

110
00:04:42,199 --> 00:04:46,319
react one possibility is for is that we

111
00:04:46,519 --> 00:04:48,180
think well you know gosh we certainly

112
00:04:48,379 --> 00:04:49,410
don't want to just talk to client to

113
00:04:49,610 --> 00:04:50,730
server one because that would leave the

114
00:04:50,930 --> 00:04:53,250
second replica inconsistent if we set

115
00:04:53,449 --> 00:04:54,780
this value to one but didn't also set

116
00:04:54,980 --> 00:04:55,620
this value to one

117
00:04:55,819 --> 00:04:57,449
so maybe the rule should be that the

118
00:04:57,649 --> 00:04:59,189
client is always required to talk to

119
00:04:59,389 --> 00:05:01,650
both replicas to both servers for any

120
00:05:01,850 --> 00:05:03,060
operation and shouldn't be allowed to

121
00:05:03,259 --> 00:05:05,639
just talk to one of them so why is that

122
00:05:05,839 --> 00:05:10,620
the wrong answer so the rule is o in our

123
00:05:10,819 --> 00:05:12,270
replicated system the clients always

124
00:05:12,470 --> 00:05:15,090
require to talk to both replicas in

125
00:05:15,290 --> 00:05:22,530
order to make progress at all in fact

126
00:05:22,730 --> 00:05:25,290
it's worse it's worse than talking to a

127
00:05:25,490 --> 00:05:27,030
single server because now the system has

128
00:05:27,230 --> 00:05:30,449
a problem if either of these servers is

129
00:05:30,649 --> 00:05:33,270
crashed or or you can't talk to it at

130
00:05:33,470 --> 00:05:34,680
least with a non replicated service

131
00:05:34,879 --> 00:05:35,939
you're only depending on one server but

132
00:05:36,139 --> 00:05:37,379
here we am both servers have to be a lot

133
00:05:37,579 --> 00:05:39,840
if we require the client to talk to both

134
00:05:40,040 --> 00:05:41,639
servers then both servers has to be live

135
00:05:41,839 --> 00:05:43,500
so we can't possibly require the client

136
00:05:43,699 --> 00:05:46,650
to actually you know wait for both

137
00:05:46,850 --> 00:05:48,810
servers to respond if we don't have

138
00:05:49,009 --> 00:05:50,160
fault tolerance we need it to be able to

139
00:05:50,360 --> 00:05:52,350
proceed so another obvious answer is

140
00:05:52,550 --> 00:05:54,870
that if the client can't talk to both

141
00:05:55,069 --> 00:05:56,160
well it just talks to the one who can

142
00:05:56,360 --> 00:05:59,689
talk to and figures the other ones dead

143
00:05:59,889 --> 00:06:02,430
so what's up why is that also not the

144
00:06:02,629 --> 00:06:04,899
right answer

145
00:06:08,509 --> 00:06:10,050
the troubling scenario is if the other

146
00:06:10,250 --> 00:06:11,910
server is actually alive so suppose the

147
00:06:12,110 --> 00:06:13,740
actual problem or encountering is not

148
00:06:13,939 --> 00:06:16,560
that this server crashed which would be

149
00:06:16,759 --> 00:06:19,949
good for us but the much worse issue

150
00:06:20,149 --> 00:06:21,300
that something went wrong with the

151
00:06:21,500 --> 00:06:23,699
network cable and that this client can

152
00:06:23,899 --> 00:06:26,009
talk to climb one can talk to server one

153
00:06:26,209 --> 00:06:27,689
but not server two and there's maybe

154
00:06:27,889 --> 00:06:29,400
some other client out there that conduct

155
00:06:29,600 --> 00:06:32,850
a server two but not server one so if we

156
00:06:33,050 --> 00:06:35,400
make the rule that if a client can talk

157
00:06:35,600 --> 00:06:38,100
to both servers that it's okay in order

158
00:06:38,300 --> 00:06:39,480
to be fault tolerant that I just talked

159
00:06:39,680 --> 00:06:43,319
to one then what's just inevitably gonna

160
00:06:43,519 --> 00:06:45,930
happen said this cable is gonna break

161
00:06:46,129 --> 00:06:47,970
thus cutting the network in half client

162
00:06:48,170 --> 00:06:51,120
one is gonna send a test and set request

163
00:06:51,319 --> 00:06:53,550
to server one server one will you know

164
00:06:53,750 --> 00:06:56,069
set it state to one and return the

165
00:06:56,269 --> 00:06:58,230
previous value of zero to client one and

166
00:06:58,430 --> 00:06:59,460
so that mean client mom will think it

167
00:06:59,660 --> 00:07:01,980
has the lock and if it's a VMware ft

168
00:07:02,180 --> 00:07:04,110
server will think it can be takeovers

169
00:07:04,310 --> 00:07:06,540
primarily but this replica still of zero

170
00:07:06,740 --> 00:07:08,370
in it all right so now if client to

171
00:07:08,569 --> 00:07:10,110
who've also sends a test and set request

172
00:07:10,310 --> 00:07:12,720
to you know what price to send them to

173
00:07:12,920 --> 00:07:14,189
both sees that server one appears to be

174
00:07:14,389 --> 00:07:16,620
down follows the rule that says well you

175
00:07:16,819 --> 00:07:17,759
just send to the one server but you can

176
00:07:17,959 --> 00:07:22,259
talk to then it will also think that it

177
00:07:22,459 --> 00:07:23,670
would either quiet because client you

178
00:07:23,870 --> 00:07:25,319
also think that it acquired the lock and

179
00:07:25,519 --> 00:07:27,030
so now you know if we were imagining

180
00:07:27,230 --> 00:07:28,620
this test and that server was going to

181
00:07:28,819 --> 00:07:29,790
be used with the and where ft we have

182
00:07:29,990 --> 00:07:34,819
not both replicas both of these VMware

183
00:07:35,019 --> 00:07:37,770
machines I think they could be primary

184
00:07:37,970 --> 00:07:40,980
by themselves without consulting the

185
00:07:41,180 --> 00:07:42,449
other server so that's a complete

186
00:07:42,649 --> 00:07:45,150
failure so with this set up and two

187
00:07:45,350 --> 00:07:47,639
servers it seemed like we had this we

188
00:07:47,839 --> 00:07:49,500
just had to choose either you wait for

189
00:07:49,699 --> 00:07:51,920
both and you're not fault-tolerant or

190
00:07:52,120 --> 00:07:54,240
you wait for just one and you're not

191
00:07:54,439 --> 00:07:57,150
correct and then our correct version

192
00:07:57,350 --> 00:07:59,360
it's often called split brain so

193
00:07:59,560 --> 00:08:06,939
everybody see this well

194
00:08:09,129 --> 00:08:12,439
so this was basically where things stood

195
00:08:12,639 --> 00:08:16,319
until the late 80s and when people but

196
00:08:16,519 --> 00:08:17,850
people did want to build replicated

197
00:08:18,050 --> 00:08:20,309
systems you know like the computers that

198
00:08:20,509 --> 00:08:22,499
control telephone switches or the

199
00:08:22,699 --> 00:08:24,718
computers that ran banks you know there

200
00:08:24,918 --> 00:08:26,309
was placer when we spend a huge amount

201
00:08:26,509 --> 00:08:27,629
of money in order to have reliable

202
00:08:27,829 --> 00:08:29,249
service and so they would replicate they

203
00:08:29,449 --> 00:08:31,019
would build replicated systems and the

204
00:08:31,218 --> 00:08:33,328
way they would deal then way would that

205
00:08:33,528 --> 00:08:35,039
they would have replication but try to

206
00:08:35,240 --> 00:08:38,039
rule out of rule out split brain it's a

207
00:08:38,240 --> 00:08:40,889
couple of techniques one is they would

208
00:08:41,089 --> 00:08:44,878
build a network that could not fail and

209
00:08:45,078 --> 00:08:47,159
so usually what that means and in fact

210
00:08:47,360 --> 00:08:48,959
you guys use networks that essentially

211
00:08:49,159 --> 00:08:51,058
cannot fail all the time the wires

212
00:08:51,259 --> 00:08:53,639
inside your laptop you know connecting

213
00:08:53,839 --> 00:08:57,389
the CPU to the DRAM are effectively what

214
00:08:57,589 --> 00:08:59,209
you know a network that cannot fail

215
00:08:59,409 --> 00:09:02,729
between the between your CPU and DRAM so

216
00:09:02,929 --> 00:09:04,948
you know with reasonable assumptions and

217
00:09:05,149 --> 00:09:07,109
lots of money and you know sort of

218
00:09:07,309 --> 00:09:10,049
carefully controlled physical situation

219
00:09:10,250 --> 00:09:10,979
like you don't want to have a cable

220
00:09:11,179 --> 00:09:12,599
snaking across the floor that somebody

221
00:09:12,799 --> 00:09:14,839
can step on you know it's got to be

222
00:09:15,039 --> 00:09:17,279
physically designed set up with a

223
00:09:17,480 --> 00:09:19,558
network that cannot fail you can rule

224
00:09:19,759 --> 00:09:20,938
out split brain it's bit of an

225
00:09:21,139 --> 00:09:22,738
assumption but with enough money people

226
00:09:22,938 --> 00:09:25,169
get quite close to this because if the

227
00:09:25,370 --> 00:09:26,849
network cannot fail that basically means

228
00:09:27,049 --> 00:09:28,498
that the client can't talk to a server

229
00:09:28,698 --> 00:09:31,109
to that means server two must be down

230
00:09:31,309 --> 00:09:33,238
because it can't have been the network

231
00:09:33,438 --> 00:09:35,248
malfunctioning so that was one way that

232
00:09:35,448 --> 00:09:38,459
people sort of built replication systems

233
00:09:38,659 --> 00:09:41,948
it didn't suffer from split brain

234
00:09:42,009 --> 00:09:44,039
another possibility would be to have

235
00:09:44,240 --> 00:09:45,929
some human beings sort out the problem

236
00:09:46,129 --> 00:09:47,938
that is don't automatically do anything

237
00:09:48,139 --> 00:09:49,769
instead have the clients you know by

238
00:09:49,970 --> 00:09:51,659
default clients always have to wait for

239
00:09:51,860 --> 00:09:53,909
you know both replicas to respond or

240
00:09:54,110 --> 00:09:56,669
something never allowed to proceed with

241
00:09:56,870 --> 00:09:58,318
just one of them but you can you know

242
00:09:58,519 --> 00:10:00,508
call somebody's beeper to go off some

243
00:10:00,708 --> 00:10:02,339
human being goes to the machine room and

244
00:10:02,539 --> 00:10:04,049
sort of looks at the two replicas and

245
00:10:04,250 --> 00:10:06,808
either turns one off to make sure it's

246
00:10:07,009 --> 00:10:07,649
definitely dead

247
00:10:07,850 --> 00:10:09,929
or verifies that one of them has indeed

248
00:10:10,129 --> 00:10:13,258
crashed and if the other is alive and so

249
00:10:13,458 --> 00:10:14,789
you're essentially using the human as a

250
00:10:14,990 --> 00:10:17,399
as the tie breaker and the human is a

251
00:10:17,600 --> 00:10:20,549
you know if they were a computer it

252
00:10:20,750 --> 00:10:21,568
would be a single point if you

253
00:10:21,769 --> 00:10:25,469
themselves so for a long time people use

254
00:10:25,669 --> 00:10:27,089
one of the other these schemes in order

255
00:10:27,289 --> 00:10:28,769
to build replicated systems and it's not

256
00:10:28,970 --> 00:10:30,808
you know they can be made to work the

257
00:10:31,009 --> 00:10:32,279
humans don't respond very quickly and

258
00:10:32,480 --> 00:10:34,258
the network that cannot fail is

259
00:10:34,458 --> 00:10:38,668
expensive but it's not not doable but it

260
00:10:38,869 --> 00:10:41,818
turned out that you can actually build

261
00:10:42,019 --> 00:10:45,748
automated failover systems that can work

262
00:10:45,948 --> 00:10:48,779
correctly in the face of flaky networks

263
00:10:48,980 --> 00:10:51,089
of networks that could fail on the can

264
00:10:51,289 --> 00:10:53,008
partition so this split of the network

265
00:10:53,208 --> 00:10:54,719
in half where the two sides operate they

266
00:10:54,919 --> 00:10:56,399
can't talk to each other that's usually

267
00:10:56,600 --> 00:11:04,709
called a partition and the big insight

268
00:11:04,909 --> 00:11:06,688
that people came up with in order to

269
00:11:06,889 --> 00:11:09,899
build automated replication systems that

270
00:11:10,100 --> 00:11:12,389
don't suffer from split brain is the

271
00:11:12,589 --> 00:11:17,649
idea of a majority vote this is a

272
00:11:20,078 --> 00:11:22,258
concept that shows up in like every

273
00:11:22,458 --> 00:11:23,909
other sentence practically in the raft

274
00:11:24,110 --> 00:11:28,318
paper sort of fundamental way of

275
00:11:28,519 --> 00:11:31,258
proceeding the first step is to have an

276
00:11:31,458 --> 00:11:33,539
odd number of servers instead of an even

277
00:11:33,740 --> 00:11:35,578
number of servers like one flaw here is

278
00:11:35,778 --> 00:11:37,738
that it's a little bit too symmetric all

279
00:11:37,938 --> 00:11:39,178
right the two sides of the split here

280
00:11:39,379 --> 00:11:41,339
just they just look the same so they run

281
00:11:41,539 --> 00:11:42,389
the same software they're gonna do the

282
00:11:42,589 --> 00:11:44,098
same thing and that's not good but if

283
00:11:44,298 --> 00:11:47,238
you have an odd number of servers then

284
00:11:47,438 --> 00:11:50,698
it's not symmetric anymore right at

285
00:11:50,899 --> 00:11:52,738
least a single network split will be

286
00:11:52,938 --> 00:11:54,539
presumably two servers on one side and

287
00:11:54,740 --> 00:11:55,978
one server on the other side and they

288
00:11:56,178 --> 00:11:58,289
won't be symmetric at all and that's

289
00:11:58,490 --> 00:12:00,628
part of what majority vote majority

290
00:12:00,828 --> 00:12:04,019
voting schemes are appealing to so basic

291
00:12:04,220 --> 00:12:05,428
ideas you have an odd number of servers

292
00:12:05,629 --> 00:12:08,098
in order to make progress of any kind so

293
00:12:08,298 --> 00:12:10,738
in raft elect a leader or cause a log

294
00:12:10,938 --> 00:12:12,418
entry to be committed in order to make

295
00:12:12,619 --> 00:12:15,178
any progress at each step you have to

296
00:12:15,379 --> 00:12:18,448
assemble a majority of the server's more

297
00:12:18,649 --> 00:12:19,948
than half more than half of all the

298
00:12:20,149 --> 00:12:22,288
servers in order to sort of approve that

299
00:12:22,489 --> 00:12:25,078
step like vote for a meet or accept a

300
00:12:25,278 --> 00:12:28,858
new log entry and commit it so you know

301
00:12:29,058 --> 00:12:32,548
the most straightforward way is that two

302
00:12:32,749 --> 00:12:36,668
or three servers required to do anything

303
00:12:37,818 --> 00:12:40,048
one reason this works of course is that

304
00:12:40,249 --> 00:12:43,298
if there's a partition there can't be

305
00:12:43,499 --> 00:12:45,368
more than one partition with a majority

306
00:12:45,568 --> 00:12:47,438
of the server's in it that's one way to

307
00:12:47,639 --> 00:12:51,128
look at this a partition can have one

308
00:12:51,328 --> 00:12:52,808
server in it which it's not a majority

309
00:12:53,009 --> 00:12:55,238
or maybe you can have two but if one

310
00:12:55,438 --> 00:12:56,349
partition has two then the other

311
00:12:56,549 --> 00:12:58,209
partition has to have only one server in

312
00:12:58,409 --> 00:13:00,488
it and therefore will never be able to

313
00:13:00,688 --> 00:13:02,078
assemble a majority and won't be able to

314
00:13:02,278 --> 00:13:07,149
make progress and just to be totally

315
00:13:07,350 --> 00:13:09,399
clear when we're talking about a

316
00:13:09,600 --> 00:13:11,409
majority it's always a majority out of

317
00:13:11,610 --> 00:13:13,839
all of the server's not just a live

318
00:13:14,039 --> 00:13:15,729
servers this is the point that confused

319
00:13:15,929 --> 00:13:17,229
me for a long time but if you have a

320
00:13:17,429 --> 00:13:19,058
system with three servers and maybe some

321
00:13:19,259 --> 00:13:20,649
of them have failed or something if you

322
00:13:20,850 --> 00:13:22,058
need to assemble in the majority it's

323
00:13:22,259 --> 00:13:24,519
always two out of three even if you know

324
00:13:24,720 --> 00:13:26,108
that one has failed the majority is

325
00:13:26,308 --> 00:13:27,248
always out of the total number of

326
00:13:27,448 --> 00:13:30,219
servers there's a more general

327
00:13:30,419 --> 00:13:33,488
formulation of this because a majority

328
00:13:33,688 --> 00:13:35,409
voting system in which two out of three

329
00:13:35,610 --> 00:13:36,969
are required to make progress it can

330
00:13:37,169 --> 00:13:40,688
survive the failure of one server right

331
00:13:40,889 --> 00:13:42,729
any two servers are enough to make

332
00:13:42,929 --> 00:13:44,979
progress if you need to be able to if

333
00:13:45,179 --> 00:13:46,539
you're you know you worried about how

334
00:13:46,740 --> 00:13:49,779
reliable your servers are or then you

335
00:13:49,980 --> 00:13:51,368
can build systems that have more servers

336
00:13:51,568 --> 00:13:53,289
and so the more general formulation is

337
00:13:53,490 --> 00:13:59,289
if you have two F + 1 servers then you

338
00:13:59,490 --> 00:14:06,729
can withstand you know so if it's three

339
00:14:06,929 --> 00:14:09,578
that means F is one and the system with

340
00:14:09,778 --> 00:14:12,608
three servers you can tolerate F servers

341
00:14:12,808 --> 00:14:17,448
step one failure and still keep going

342
00:14:19,769 --> 00:14:22,188
all right often these are called quorum

343
00:14:22,389 --> 00:14:25,149
systems because the two out of three is

344
00:14:25,350 --> 00:14:28,849
sometimes held a quorum okay so one

345
00:14:29,049 --> 00:14:30,318
property I've already mentioned about

346
00:14:30,519 --> 00:14:33,828
these majority voting systems is that at

347
00:14:34,028 --> 00:14:36,558
most one partition can have a majority

348
00:14:36,759 --> 00:14:37,909
and therefore if the networks

349
00:14:38,110 --> 00:14:40,368
partitioned we can't have both halves of

350
00:14:40,568 --> 00:14:42,349
the network making progress another more

351
00:14:42,549 --> 00:14:44,298
subtle thing that's going on here is

352
00:14:44,499 --> 00:14:48,769
that if you always need a majority of

353
00:14:48,970 --> 00:14:52,428
the servers to proceed and you go

354
00:14:52,629 --> 00:14:54,048
through a sort of succession of

355
00:14:54,249 --> 00:14:55,789
operations in which reach operations

356
00:14:55,990 --> 00:14:57,889
somebody assembled a majority like you

357
00:14:58,089 --> 00:15:00,529
know votes for leaders or let's say

358
00:15:00,730 --> 00:15:04,488
votes for leaders arrived then at every

359
00:15:04,688 --> 00:15:06,318
step the majority you assemble for that

360
00:15:06,519 --> 00:15:09,139
step must contain at least one server

361
00:15:09,339 --> 00:15:11,089
that was in the previous majority that

362
00:15:11,289 --> 00:15:13,698
is any two majorities overlap in at

363
00:15:13,899 --> 00:15:17,599
least one server and it's really that

364
00:15:17,799 --> 00:15:20,808
property more than anything else that

365
00:15:21,009 --> 00:15:24,858
raft is relying on to avoid split brain

366
00:15:25,058 --> 00:15:27,019
it's the fact that for example when you

367
00:15:27,220 --> 00:15:28,279
have a leader a successful leader

368
00:15:28,480 --> 00:15:30,139
election and leader assembles votes from

369
00:15:30,339 --> 00:15:32,779
a majority its majority is guaranteed to

370
00:15:32,980 --> 00:15:34,578
overlap with the previous leaders

371
00:15:34,778 --> 00:15:36,289
majority and so for example the new

372
00:15:36,490 --> 00:15:39,019
leader is guaranteed to know about the

373
00:15:39,220 --> 00:15:41,078
term number used by the previous leader

374
00:15:41,278 --> 00:15:43,159
because it's a majority overlaps with

375
00:15:43,360 --> 00:15:45,098
the previous leaders majority and

376
00:15:45,298 --> 00:15:47,178
everybody in the previous leaders

377
00:15:47,379 --> 00:15:48,858
majority knew about the previous leaders

378
00:15:49,058 --> 00:15:49,868
term number

379
00:15:50,068 --> 00:15:52,818
similarly anything the previous leader

380
00:15:53,019 --> 00:15:55,368
could have committed must be present in

381
00:15:55,568 --> 00:15:57,769
a majority of the servers in raft and

382
00:15:57,970 --> 00:15:59,568
therefore any new leaders majority must

383
00:15:59,769 --> 00:16:01,668
overlap at at least one server with

384
00:16:01,869 --> 00:16:04,578
every committed entry from the previous

385
00:16:04,778 --> 00:16:08,328
leader this is a big part of why it is

386
00:16:08,528 --> 00:16:13,110
that wrapped is correct

387
00:16:14,440 --> 00:16:17,870
any questions about the general concept

388
00:16:18,070 --> 00:16:22,860
of majority voting systems

389
00:16:27,940 --> 00:16:31,470
these muscle ad servers

390
00:16:31,759 --> 00:16:33,870
it's possible intersection something

391
00:16:34,070 --> 00:16:36,509
maybe six in the paper explains how to

392
00:16:36,710 --> 00:16:40,909
add it or change the set of servers and

393
00:16:41,110 --> 00:16:44,399
it's possible you need to do it in a

394
00:16:44,600 --> 00:16:45,719
long-running system if you're running

395
00:16:45,919 --> 00:16:48,599
your system for five ten years you know

396
00:16:48,799 --> 00:16:50,279
you're gonna need to replace the servers

397
00:16:50,480 --> 00:16:52,289
after a while you know one of them fails

398
00:16:52,490 --> 00:16:55,079
permanently or you upgrade or you move

399
00:16:55,279 --> 00:16:56,189
machine rooms to a different machine

400
00:16:56,389 --> 00:16:58,049
room you really do need to be able to

401
00:16:58,250 --> 00:17:00,000
support changing sets of servers so

402
00:17:00,200 --> 00:17:01,439
that's a it certainly doesn't happen

403
00:17:01,639 --> 00:17:03,029
every day but it's a critical part of

404
00:17:03,230 --> 00:17:05,190
this or a long-term maintainability of

405
00:17:05,390 --> 00:17:08,279
these systems and you know the RAF

406
00:17:08,480 --> 00:17:10,319
authors sort of pat themselves on the

407
00:17:10,519 --> 00:17:12,899
back that they have a scheme that deals

408
00:17:13,099 --> 00:17:14,159
with this which as well they might

409
00:17:14,359 --> 00:17:21,659
because it's complex all right so using

410
00:17:21,859 --> 00:17:25,249
this idea in about 1990 or so there were

411
00:17:25,449 --> 00:17:27,839
two systems proposed at about the same

412
00:17:28,039 --> 00:17:31,349
time that realized that you could use

413
00:17:31,549 --> 00:17:34,009
this majority voting system to kind of

414
00:17:34,210 --> 00:17:37,819
get around the apparent impossibility of

415
00:17:38,019 --> 00:17:40,950
avoiding split brain by using basically

416
00:17:41,150 --> 00:17:42,869
by using three servers instead of two

417
00:17:43,069 --> 00:17:46,319
and taking majority votes and in one of

418
00:17:46,519 --> 00:17:48,180
these very early systems was called

419
00:17:48,380 --> 00:17:51,659
Paxos the RAF paper talks about this a

420
00:17:51,859 --> 00:17:54,659
lot and another of these very early

421
00:17:54,859 --> 00:17:56,220
systems was called view stamp

422
00:17:56,420 --> 00:17:59,970
replication a previa des vs r4 view

423
00:18:00,170 --> 00:18:02,639
stamp replication and even though Paxos

424
00:18:02,839 --> 00:18:04,819
pod is by far the more widely known

425
00:18:05,019 --> 00:18:07,109
system in this department raft is

426
00:18:07,309 --> 00:18:09,389
actually closer to design in design to

427
00:18:09,589 --> 00:18:11,450
view statment few stamp application

428
00:18:11,650 --> 00:18:16,769
which was invented by people at MIT and

429
00:18:16,970 --> 00:18:19,079
so there's a sort of a law many decade

430
00:18:19,279 --> 00:18:21,419
history of these systems and they only

431
00:18:21,619 --> 00:18:24,599
really came to the forefront and started

432
00:18:24,799 --> 00:18:27,000
being used a lot in deployed big

433
00:18:27,200 --> 00:18:29,069
distributed sisty systems about 15 years

434
00:18:29,269 --> 00:18:31,769
ago a good 15 years after they were

435
00:18:31,970 --> 00:18:39,480
originally invented okay so let me talk

436
00:18:39,680 --> 00:18:42,340
about Rath now

437
00:18:42,769 --> 00:18:45,969
raft is a takes the form of a library

438
00:18:46,169 --> 00:18:48,848
intended to be included in some service

439
00:18:49,048 --> 00:18:51,159
application so if you have a replicated

440
00:18:51,359 --> 00:18:53,379
service that each of the replicas in the

441
00:18:53,579 --> 00:18:54,819
service is gonna be some application

442
00:18:55,019 --> 00:18:56,950
code which you know receives rpcs or

443
00:18:57,150 --> 00:18:59,829
something plus a raft library and the

444
00:19:00,029 --> 00:19:01,539
raft libraries cooperate with each other

445
00:19:01,740 --> 00:19:05,829
to mean replication maintain replication

446
00:19:06,029 --> 00:19:10,059
so sort of software overview of a single

447
00:19:10,259 --> 00:19:13,719
raft replica is that at the top we can

448
00:19:13,919 --> 00:19:15,338
think of the replicas having the

449
00:19:15,538 --> 00:19:17,649
application code so it might be for lab

450
00:19:17,849 --> 00:19:20,588
3 a key-value server so maybe we have

451
00:19:20,788 --> 00:19:24,190
some key value server and in a state the

452
00:19:24,390 --> 00:19:26,680
application has state that raft is

453
00:19:26,880 --> 00:19:28,509
helping it manage replicated state and

454
00:19:28,710 --> 00:19:30,098
for a key value server it's going to be

455
00:19:30,298 --> 00:19:38,979
a table of keys and values the next

456
00:19:39,179 --> 00:19:44,139
layer down is a raft layer so the key

457
00:19:44,339 --> 00:19:45,569
value server is gonna sort of make

458
00:19:45,769 --> 00:19:47,559
function calls into raft and they're

459
00:19:47,759 --> 00:19:48,879
gonna chitchat back and forth a little

460
00:19:49,079 --> 00:19:51,869
bit and raft keeps a little bit of state

461
00:19:52,069 --> 00:19:54,639
you can see it in Figure 2 and for our

462
00:19:54,839 --> 00:19:56,079
purposes really the most critical piece

463
00:19:56,279 --> 00:19:59,219
of state is that raft has a log of

464
00:19:59,419 --> 00:20:08,169
operations and a system with 3 breath

465
00:20:08,369 --> 00:20:09,309
will cause we're actually gonna have you

466
00:20:09,509 --> 00:20:11,829
know 3 servers that have exactly the

467
00:20:12,029 --> 00:20:14,259
same identical structure and hopefully

468
00:20:14,460 --> 00:20:19,750
the very same data sitting in sitting at

469
00:20:19,950 --> 00:20:22,370
both layers

470
00:20:32,380 --> 00:20:35,519
right outside of this there's gonna be

471
00:20:35,720 --> 00:20:38,669
clients and the game is that so we have

472
00:20:38,869 --> 00:20:40,440
you know client 1 and client two whole

473
00:20:40,640 --> 00:20:42,568
bunch of clients the clients don't

474
00:20:42,769 --> 00:20:43,919
really know the clients are you know

475
00:20:44,119 --> 00:20:46,588
just external code that needs to be able

476
00:20:46,788 --> 00:20:49,379
to use the service and the hope is the

477
00:20:49,579 --> 00:20:50,759
clients won't really need to be aware

478
00:20:50,960 --> 00:20:52,108
that they're talking to a replicated

479
00:20:52,308 --> 00:20:53,490
service that to the clients that are

480
00:20:53,690 --> 00:20:55,740
looking almost like it's just one server

481
00:20:55,940 --> 00:20:58,828
and they talked with one server and so

482
00:20:59,028 --> 00:21:00,539
the clients actually send client

483
00:21:00,740 --> 00:21:04,019
requests to the key to the application

484
00:21:04,220 --> 00:21:07,889
layer of the current leader the replica

485
00:21:08,089 --> 00:21:11,519
that's the current leader in raft and so

486
00:21:11,720 --> 00:21:13,769
these are gonna be you know application

487
00:21:13,970 --> 00:21:15,539
level requests for a database for a key

488
00:21:15,740 --> 00:21:17,219
value server these might be put in get

489
00:21:17,419 --> 00:21:20,369
requests you know put takes a key and a

490
00:21:20,569 --> 00:21:26,269
value and updates the table and get

491
00:21:26,470 --> 00:21:29,328
asked the service to get the current key

492
00:21:29,528 --> 00:21:33,948
current value corresponding to some key

493
00:21:34,148 --> 00:21:35,879
so this like has nothing about to do

494
00:21:36,079 --> 00:21:36,869
with raft it's just sort of

495
00:21:37,069 --> 00:21:38,309
client-server interaction for whatever

496
00:21:38,509 --> 00:21:41,789
service we're building but once one of

497
00:21:41,990 --> 00:21:43,379
these commands gets sent from the

498
00:21:43,579 --> 00:21:44,789
requests get sent from the clients of

499
00:21:44,990 --> 00:21:48,088
the server what actually happens is you

500
00:21:48,288 --> 00:21:50,568
know on a non replicated server the

501
00:21:50,769 --> 00:21:52,799
application code would like execute this

502
00:21:53,000 --> 00:21:54,629
request and say update the table and

503
00:21:54,829 --> 00:21:56,490
response to a book but not in a raft

504
00:21:56,690 --> 00:21:58,948
replicated service instead if assuming

505
00:21:59,148 --> 00:22:00,539
the client sends a request to leader

506
00:22:00,740 --> 00:22:03,990
what really happens is the application

507
00:22:04,190 --> 00:22:06,358
layer simply sends the request the

508
00:22:06,558 --> 00:22:08,279
clients request down into the raft layer

509
00:22:08,480 --> 00:22:09,709
to say look you know here's a request

510
00:22:09,909 --> 00:22:12,930
please get it committed into the

511
00:22:13,130 --> 00:22:15,240
replicated log and tell me when you're

512
00:22:15,440 --> 00:22:17,399
done and so at this point the rafts

513
00:22:17,599 --> 00:22:23,639
chitchat with each other until all the

514
00:22:23,839 --> 00:22:25,619
replicas are a majority the replicas get

515
00:22:25,819 --> 00:22:28,799
this new operation into their logs said

516
00:22:29,000 --> 00:22:30,979
it is replicated and then when its

517
00:22:31,179 --> 00:22:34,709
leader knows that all of the replicas of

518
00:22:34,909 --> 00:22:37,828
a copy of this only then as a raft sent

519
00:22:38,028 --> 00:22:40,139
a notification up back up to the key

520
00:22:40,339 --> 00:22:42,779
value they are saying aha that operation

521
00:22:42,980 --> 00:22:44,188
you sent me I mean

522
00:22:44,388 --> 00:22:45,928
it's been now committed into all the

523
00:22:46,128 --> 00:22:49,108
replicas and so it's safely replicated

524
00:22:49,308 --> 00:22:51,719
and at this point it's okay to execute

525
00:22:51,919 --> 00:22:54,888
that operation a raft you know the

526
00:22:55,088 --> 00:22:56,878
client sends a request with the key

527
00:22:57,078 --> 00:22:58,918
value layer Q value layer does not

528
00:22:59,118 --> 00:23:01,798
execute it yet so we're not sure because

529
00:23:01,999 --> 00:23:04,378
it hasn't been replicated only when it's

530
00:23:04,578 --> 00:23:09,198
in out and the logs of all the replicas

531
00:23:09,398 --> 00:23:11,578
then raft notifies the leader now the

532
00:23:11,778 --> 00:23:13,229
leader actually execute the operation

533
00:23:13,429 --> 00:23:15,240
which corresponds to you know for a put

534
00:23:15,440 --> 00:23:20,158
updating the value yet reading correct

535
00:23:20,358 --> 00:23:21,838
value out of the table and then finally

536
00:23:22,038 --> 00:23:26,459
sends the reply back to the client so

537
00:23:26,659 --> 00:23:34,558
that's the ordinary operation of it

538
00:23:34,759 --> 00:23:36,118
submitted if it's in a majority and

539
00:23:36,318 --> 00:23:38,278
again the reason why I can't be all is

540
00:23:38,479 --> 00:23:39,388
that if we want to build a

541
00:23:39,588 --> 00:23:41,098
fault-tolerant system it has to be able

542
00:23:41,298 --> 00:23:43,318
to make progress even if some of the

543
00:23:43,519 --> 00:23:49,249
server's have failed so yeah so ever

544
00:23:49,449 --> 00:23:53,679
it's committed when it's in a majority

545
00:23:54,720 --> 00:23:57,890
[Music]

546
00:24:08,170 --> 00:24:12,509
yeah and so in addition when operations

547
00:24:12,710 --> 00:24:14,569
finally committed each of the replicas

548
00:24:14,769 --> 00:24:17,460
sends the operation up each of the raft

549
00:24:17,660 --> 00:24:20,579
library layer sends the operation up to

550
00:24:20,779 --> 00:24:22,710
the local application layer in the local

551
00:24:22,910 --> 00:24:24,389
application layer applies that operation

552
00:24:24,589 --> 00:24:26,849
to its state its state and so they all

553
00:24:27,049 --> 00:24:29,099
so hopefully all the replicas seem the

554
00:24:29,299 --> 00:24:32,579
same stream of operations they show up

555
00:24:32,779 --> 00:24:34,559
in these up calls in the same order they

556
00:24:34,759 --> 00:24:36,149
get applied to the state in the same

557
00:24:36,349 --> 00:24:38,759
order and you know assuming the

558
00:24:38,960 --> 00:24:40,799
operations are deterministic which they

559
00:24:41,000 --> 00:24:45,720
better be the state of the replicas

560
00:24:45,920 --> 00:24:47,990
replicated State will evolve in

561
00:24:48,190 --> 00:24:50,159
identically on all the replicas so

562
00:24:50,359 --> 00:24:52,200
typically this this table is what the

563
00:24:52,400 --> 00:24:55,579
paper is talking about when it talks

564
00:24:55,779 --> 00:25:01,889
about state a different way of viewing

565
00:25:02,089 --> 00:25:05,279
this interaction and one that'll sort of

566
00:25:05,480 --> 00:25:06,899
notation that will come up a lot in this

567
00:25:07,099 --> 00:25:10,019
course is that a sort of time diagram

568
00:25:10,220 --> 00:25:11,579
I'll draw you a time diagram of how the

569
00:25:11,779 --> 00:25:13,649
messages work so let's imagine we have a

570
00:25:13,849 --> 00:25:18,389
client and server one is the leader that

571
00:25:18,589 --> 00:25:23,549
we also have server to server three and

572
00:25:23,750 --> 00:25:25,619
time flows downward on this diagram we

573
00:25:25,819 --> 00:25:27,269
imagine the client sending the original

574
00:25:27,470 --> 00:25:31,740
request to server one after that server

575
00:25:31,940 --> 00:25:35,129
ones raft layer sends an append entries

576
00:25:35,329 --> 00:25:42,599
RPC to each of the two replicas this is

577
00:25:42,799 --> 00:25:44,329
just an ordinary I'll say a put request

578
00:25:44,529 --> 00:25:49,169
this is append entries requests the

579
00:25:49,369 --> 00:25:51,779
server is now waiting for replies and

580
00:25:51,980 --> 00:25:54,809
the server's from other replicas as soon

581
00:25:55,009 --> 00:25:58,079
as replies from a majority arrive back

582
00:25:58,279 --> 00:26:00,599
including the leader itself so in a

583
00:26:00,799 --> 00:26:01,889
system with only three about because the

584
00:26:02,089 --> 00:26:03,569
leader only has to wait for one other

585
00:26:03,769 --> 00:26:06,479
replica to respond positively to an

586
00:26:06,679 --> 00:26:09,108
append entries as soon as it assembles

587
00:26:09,308 --> 00:26:14,180
positive responses from a majority the

588
00:26:14,380 --> 00:26:15,329
leader

589
00:26:15,529 --> 00:26:18,029
execute a command figures out what the

590
00:26:18,230 --> 00:26:20,180
answer is like forget

591
00:26:20,380 --> 00:26:25,220
and sends the reply back to the client

592
00:26:25,420 --> 00:26:27,049
I mean why of course you know if s who's

593
00:26:27,250 --> 00:26:30,500
actually awry alive it'll send back its

594
00:26:30,700 --> 00:26:32,000
response too but we're not waiting for

595
00:26:32,200 --> 00:26:35,269
it although it's useful to know and

596
00:26:35,470 --> 00:26:40,690
figure - all right everybody see this

597
00:26:40,890 --> 00:26:42,919
this is the sort of ordinary operation

598
00:26:43,119 --> 00:26:46,889
of the system no no failures

599
00:26:51,200 --> 00:26:55,259
oh gosh yeah I like I left out important

600
00:26:55,460 --> 00:26:57,359
steps so you know this point the leader

601
00:26:57,559 --> 00:26:59,549
knows oh I got you know I'm adora t have

602
00:26:59,750 --> 00:27:01,319
put it in no log I can go ahead and

603
00:27:01,519 --> 00:27:03,029
execute it and reply yes to the client

604
00:27:03,230 --> 00:27:04,950
because it's committed but server two

605
00:27:05,150 --> 00:27:06,180
doesn't know anything yet it just knows

606
00:27:06,380 --> 00:27:07,440
well you know I got this request from

607
00:27:07,640 --> 00:27:09,389
the leader but I don't know if it's

608
00:27:09,589 --> 00:27:11,579
committed yet depends on for example

609
00:27:11,779 --> 00:27:13,319
whether my reply got back to the leader

610
00:27:13,519 --> 00:27:15,059
for all server to knows it's reply was

611
00:27:15,259 --> 00:27:16,740
brought by the network maybe the leader

612
00:27:16,940 --> 00:27:18,509
never heard the reply and never decided

613
00:27:18,710 --> 00:27:20,159
to commit this request so there's

614
00:27:20,359 --> 00:27:23,809
actually another stage once the server

615
00:27:24,009 --> 00:27:28,139
realizes that a request is committed it

616
00:27:28,339 --> 00:27:30,869
then needs to tell the other replicas

617
00:27:31,069 --> 00:27:37,240
that fact and so there are there's

618
00:27:38,319 --> 00:27:40,529
there's an extra message here exactly

619
00:27:40,730 --> 00:27:42,000
what that message is depends a little

620
00:27:42,200 --> 00:27:45,659
bit on what what else is going on it's

621
00:27:45,859 --> 00:27:49,319
at least in raft there's not an explicit

622
00:27:49,519 --> 00:27:51,119
commit message instead the information

623
00:27:51,319 --> 00:27:53,519
is piggybacked inside the next append

624
00:27:53,720 --> 00:27:55,440
entries that leader sends out the next

625
00:27:55,640 --> 00:27:57,419
append entries RPC it sends out for

626
00:27:57,619 --> 00:28:00,059
whatever reason like there's a commit

627
00:28:00,259 --> 00:28:01,619
meter commit or something filled in that

628
00:28:01,819 --> 00:28:05,579
RPC and the next time the leader needs

629
00:28:05,779 --> 00:28:07,680
have to send a heartbeat heartbeat or

630
00:28:07,880 --> 00:28:09,899
needs to send out a new client request

631
00:28:10,099 --> 00:28:13,169
because some different client requests

632
00:28:13,369 --> 00:28:16,369
or something it'll send out the new hire

633
00:28:16,569 --> 00:28:19,079
leader commit value and at that point

634
00:28:19,279 --> 00:28:25,049
the replicas will execute the operation

635
00:28:25,250 --> 00:28:30,789
and apply it to their state yes

636
00:28:39,700 --> 00:28:43,190
oh yes so this is a this is a protocol

637
00:28:43,390 --> 00:28:45,069
that has a quite a bit of chitchat in it

638
00:28:45,269 --> 00:28:50,930
and it's not super fast indeed you know

639
00:28:51,130 --> 00:28:52,849
yeah client sends in request request has

640
00:28:53,049 --> 00:28:54,529
to get to the server the server talks to

641
00:28:54,730 --> 00:28:57,259
at least you know another instance that

642
00:28:57,460 --> 00:28:58,609
multiple messages has to wait for the

643
00:28:58,809 --> 00:29:00,349
responses send something back so there's

644
00:29:00,549 --> 00:29:02,000
a bunch of message round-trip times kind

645
00:29:02,200 --> 00:29:05,640
of embedded here

646
00:29:10,759 --> 00:29:15,059
yes if so this is up to you as the

647
00:29:15,259 --> 00:29:17,729
implementer actually exactly when the

648
00:29:17,929 --> 00:29:20,969
leader sends out the updated commit

649
00:29:21,169 --> 00:29:26,399
index if client requests a comeback only

650
00:29:26,599 --> 00:29:28,889
very occasionally then you know the

651
00:29:29,089 --> 00:29:30,539
leader may want to send out a heartbeat

652
00:29:30,740 --> 00:29:33,119
or send out a special append entries

653
00:29:33,319 --> 00:29:37,348
message if client requests come quite

654
00:29:37,548 --> 00:29:38,339
frequently then it doesn't matter

655
00:29:38,539 --> 00:29:40,079
because if they come you know there's

656
00:29:40,279 --> 00:29:41,879
thousand arrive per second and gee so

657
00:29:42,079 --> 00:29:43,319
it'll be another one along very soon and

658
00:29:43,519 --> 00:29:45,029
so you can piggyback so without

659
00:29:45,230 --> 00:29:46,469
generating an extra message which is

660
00:29:46,669 --> 00:29:48,210
somewhat expensive you can get the

661
00:29:48,410 --> 00:29:49,858
information out on the next message you

662
00:29:50,058 --> 00:29:53,250
were gonna send anyway in fact I I don't

663
00:29:53,450 --> 00:29:58,619
think the time at which the replicas

664
00:29:58,819 --> 00:30:01,819
execute the request is critical because

665
00:30:02,019 --> 00:30:04,440
nobody's waiting for it at least if

666
00:30:04,640 --> 00:30:06,299
there's no failures if there's no

667
00:30:06,500 --> 00:30:10,500
failures replicas executing the request

668
00:30:10,700 --> 00:30:12,479
isn't really on the critical path like

669
00:30:12,679 --> 00:30:13,769
the client isn't waiting for them the

670
00:30:13,970 --> 00:30:15,000
client saw me waiting for the leader to

671
00:30:15,200 --> 00:30:20,339
execute so it may not be that it may not

672
00:30:20,539 --> 00:30:23,399
affect client perceived latency sort of

673
00:30:23,599 --> 00:30:26,980
exactly how this gets staged

674
00:30:37,519 --> 00:30:45,700
all right one question you should ask is

675
00:30:45,900 --> 00:30:48,549
why does the system why is the system so

676
00:30:48,750 --> 00:30:52,440
focused on blogs what are the logs doing

677
00:30:52,640 --> 00:30:54,730
and it's sort of worth trying to come up

678
00:30:54,930 --> 00:30:56,430
with an explicit answers to that one

679
00:30:56,630 --> 00:31:00,009
answer to why the system is totally

680
00:31:00,210 --> 00:31:04,000
focused on logs is that the log is the

681
00:31:04,200 --> 00:31:05,500
kind of mechanism by which the leader

682
00:31:05,700 --> 00:31:08,529
orders operations it's vital for these

683
00:31:08,730 --> 00:31:10,629
replicated state machines that all the

684
00:31:10,829 --> 00:31:13,690
replicas apply not just the same client

685
00:31:13,890 --> 00:31:15,519
operations to their start but the same

686
00:31:15,720 --> 00:31:18,490
operations in the same order but they

687
00:31:18,690 --> 00:31:20,409
all have to apply that these operations

688
00:31:20,609 --> 00:31:22,059
coming from the clients in the same

689
00:31:22,259 --> 00:31:24,039
order and the log among many other

690
00:31:24,240 --> 00:31:26,379
things is part of the machinery by which

691
00:31:26,579 --> 00:31:30,490
the or the leader assigns an order to

692
00:31:30,690 --> 00:31:32,230
the incoming client operations I give

693
00:31:32,430 --> 00:31:34,419
you know ten clients send operations to

694
00:31:34,619 --> 00:31:35,889
the leader at the same time the client

695
00:31:36,089 --> 00:31:37,750
the leader has to pick pick an order

696
00:31:37,950 --> 00:31:39,099
make sure everybody all the replicas

697
00:31:39,299 --> 00:31:41,680
obey that order and the log is you know

698
00:31:41,880 --> 00:31:43,889
the fact that the log has numbered slots

699
00:31:44,089 --> 00:31:46,539
as part of half a meter expresses the

700
00:31:46,740 --> 00:31:52,480
order it's chosen another use of the log

701
00:31:52,680 --> 00:31:56,500
is that between this point and this

702
00:31:56,700 --> 00:32:00,129
point server 3 has received an operation

703
00:32:00,329 --> 00:32:02,319
that it is not yet sure is committed and

704
00:32:02,519 --> 00:32:04,359
it cannot execute it yet it has to put

705
00:32:04,559 --> 00:32:07,240
the this operation aside somewhere until

706
00:32:07,440 --> 00:32:11,139
the increment to the leader commit value

707
00:32:11,339 --> 00:32:13,299
comes in and so another thing that the

708
00:32:13,500 --> 00:32:14,889
log is doing is that on the followers

709
00:32:15,089 --> 00:32:16,930
the log is the place where the follower

710
00:32:17,130 --> 00:32:18,460
sort of sets aside operations that are

711
00:32:18,660 --> 00:32:20,289
still tentative that have arrived but

712
00:32:20,490 --> 00:32:21,789
are not yet known to be committed and

713
00:32:21,990 --> 00:32:23,139
they may have to be thrown away as we'll

714
00:32:23,339 --> 00:32:26,829
see so that's another use I'm the I sort

715
00:32:27,029 --> 00:32:29,529
of do love that use on the leader side

716
00:32:29,730 --> 00:32:33,299
is that the leader needs to remember

717
00:32:33,500 --> 00:32:36,099
operations in its log because it may

718
00:32:36,299 --> 00:32:38,769
need to retransmit them to followers if

719
00:32:38,970 --> 00:32:40,569
some followers offline maybe it's

720
00:32:40,769 --> 00:32:41,680
something briefly happened to its

721
00:32:41,880 --> 00:32:42,068
network

722
00:32:42,269 --> 00:32:43,948
action or something misses some messages

723
00:32:44,148 --> 00:32:46,240
the leader needs to be able to resend

724
00:32:46,440 --> 00:32:48,908
log messages that any followers missed

725
00:32:49,108 --> 00:32:50,500
and so the leader needs a place where

726
00:32:50,700 --> 00:32:52,658
can set aside copies of messages of

727
00:32:52,858 --> 00:32:54,369
client requests even ones that it's

728
00:32:54,569 --> 00:32:56,769
already executed in order to be able to

729
00:32:56,969 --> 00:33:00,338
resend them to the client I mean we send

730
00:33:00,538 --> 00:33:03,818
them to replicas that missed missed that

731
00:33:04,019 --> 00:33:05,678
operation and a final reason for all of

732
00:33:05,878 --> 00:33:07,750
them to keep the log is that at least in

733
00:33:07,950 --> 00:33:10,808
the world of figure 2 if a server

734
00:33:11,009 --> 00:33:15,058
crashes and restarts and wants to rejoin

735
00:33:15,259 --> 00:33:17,558
and you really need if it you really

736
00:33:17,759 --> 00:33:19,269
want a server that crashes - in fact we

737
00:33:19,469 --> 00:33:21,398
start and rejoin the raft cluster

738
00:33:21,598 --> 00:33:23,048
otherwise you're now operating with only

739
00:33:23,249 --> 00:33:24,608
two out of three servers and you can't

740
00:33:24,808 --> 00:33:26,619
survive any more failures we need to

741
00:33:26,819 --> 00:33:29,198
reincorporate failed and rebooted

742
00:33:29,398 --> 00:33:31,750
servers and the log is sort of where or

743
00:33:31,950 --> 00:33:34,240
what a server rebooted server uses the

744
00:33:34,440 --> 00:33:36,969
log persisted to its disk because one of

745
00:33:37,169 --> 00:33:39,369
the rules is that each raft server needs

746
00:33:39,569 --> 00:33:40,959
to write its log to its disk where it

747
00:33:41,159 --> 00:33:42,338
will still be after it crashes and

748
00:33:42,538 --> 00:33:44,259
restarts that log is what the server

749
00:33:44,459 --> 00:33:48,038
uses or replays the operations in that

750
00:33:48,239 --> 00:33:50,168
log from the beginning to sort of create

751
00:33:50,368 --> 00:33:52,509
its state as of when it crashed and then

752
00:33:52,709 --> 00:33:54,608
then it carries on from there so the log

753
00:33:54,808 --> 00:33:56,138
is also used as part of the persistence

754
00:33:56,338 --> 00:33:58,298
plan as a sequence of commands to

755
00:33:58,499 --> 00:34:01,129
rebuild the state

756
00:34:16,280 --> 00:34:20,070
well ultimately okay so the question is

757
00:34:20,269 --> 00:34:23,139
suppose the leader is capable of

758
00:34:23,338 --> 00:34:25,000
executing a thousand client commands a

759
00:34:25,199 --> 00:34:26,679
second and the followers are only

760
00:34:26,878 --> 00:34:28,510
incapable of executing a hundred client

761
00:34:28,710 --> 00:34:29,979
commands per second that's sort of

762
00:34:30,179 --> 00:34:35,860
sustained rate you know full speed v so

763
00:34:36,059 --> 00:34:41,399
one thing to note is that the the

764
00:34:41,599 --> 00:34:43,600
replicas the followers acknowledge

765
00:34:43,800 --> 00:34:45,429
commands before they execute them so

766
00:34:45,628 --> 00:34:46,990
they mate rate at which they acknowledge

767
00:34:47,190 --> 00:34:48,550
and accumulate stuff in their logs is

768
00:34:48,750 --> 00:34:50,860
not limited so you know maybe they can

769
00:34:51,059 --> 00:34:52,269
acknowledge that a thousand requests per

770
00:34:52,469 --> 00:34:55,330
second if they do that forever then they

771
00:34:55,530 --> 00:34:57,490
will build up unbounded size logs

772
00:34:57,690 --> 00:35:00,100
because their execution rate falls it

773
00:35:00,300 --> 00:35:02,169
will fall on an unbounded amount behind

774
00:35:02,369 --> 00:35:04,510
the rate at which the leader has given

775
00:35:04,710 --> 00:35:06,010
the messages sort of under the rules of

776
00:35:06,210 --> 00:35:08,620
our game and so what that means they

777
00:35:08,820 --> 00:35:11,050
will eventually run out of memory at

778
00:35:11,250 --> 00:35:13,240
some point so after they have a billion

779
00:35:13,440 --> 00:35:15,190
after they fall a billion log entries

780
00:35:15,389 --> 00:35:16,570
behind those just like they'll call the

781
00:35:16,769 --> 00:35:18,310
memory allocator for space for a new

782
00:35:18,510 --> 00:35:22,630
blog entry and it will fail so yeah and

783
00:35:22,829 --> 00:35:27,220
Raph doesn't Raph doesn't have the flow

784
00:35:27,420 --> 00:35:30,159
controls that's required to cope with

785
00:35:30,358 --> 00:35:34,149
this so I think in a real system you

786
00:35:34,349 --> 00:35:35,980
would actually need you know probably

787
00:35:36,179 --> 00:35:37,570
piggybacked and doesn't need to be

788
00:35:37,769 --> 00:35:39,720
real-time but you probably need some

789
00:35:39,920 --> 00:35:43,720
kind of additional communication here

790
00:35:43,920 --> 00:35:45,370
that says well here's how far I've

791
00:35:45,570 --> 00:35:47,950
gotten in execution so that the leader

792
00:35:48,150 --> 00:35:50,320
can say well you know too many thousands

793
00:35:50,519 --> 00:35:52,899
of requests ahead of the point in which

794
00:35:53,099 --> 00:35:54,850
the followers have executed yes I think

795
00:35:55,050 --> 00:35:56,430
there's probably you know in a

796
00:35:56,630 --> 00:35:58,659
production system that you're trying to

797
00:35:58,858 --> 00:36:01,450
push to the absolute max you would you

798
00:36:01,650 --> 00:36:03,100
might well need an extra message to

799
00:36:03,300 --> 00:36:05,050
throttle the leader if it got too far

800
00:36:05,250 --> 00:36:07,400
ahead

801
00:36:31,699 --> 00:36:35,879
okay so the question is if if one of

802
00:36:36,079 --> 00:36:38,099
these servers crashes it has this log

803
00:36:38,298 --> 00:36:39,720
that it persisted to disk because that's

804
00:36:39,920 --> 00:36:42,690
one of the rules of figure two so the

805
00:36:42,889 --> 00:36:43,740
server will be able to be just logged

806
00:36:43,940 --> 00:36:46,830
back from disk but of course that server

807
00:36:47,030 --> 00:36:49,619
doesn't know how far it got in executing

808
00:36:49,818 --> 00:36:52,349
the log and also it doesn't know at

809
00:36:52,548 --> 00:36:54,510
least when it first reboots by the rule

810
00:36:54,710 --> 00:36:56,399
that figure two it doesn't even know how

811
00:36:56,599 --> 00:36:59,129
much of the log is committed so the

812
00:36:59,329 --> 00:37:00,419
first answer to your question is that

813
00:37:00,619 --> 00:37:03,720
immediately after a restart you know

814
00:37:03,920 --> 00:37:05,399
after a server crashes and restarts and

815
00:37:05,599 --> 00:37:07,289
reads its log it is not allowed to do

816
00:37:07,489 --> 00:37:10,019
anything with the log because it does

817
00:37:10,219 --> 00:37:11,669
not know how far the system has

818
00:37:11,869 --> 00:37:14,580
committed in its log maybe as long as

819
00:37:14,780 --> 00:37:16,349
has a thousand uncommitted entries and

820
00:37:16,548 --> 00:37:18,030
zero committed entries for all it notes

821
00:37:18,230 --> 00:37:20,798
so

822
00:37:24,809 --> 00:37:26,780
it's a leader dye support that doesn't

823
00:37:26,980 --> 00:37:28,550
help either but let's suppose they've

824
00:37:28,750 --> 00:37:32,389
all crashed this is getting ahead of its

825
00:37:32,588 --> 00:37:33,470
getting a bit ahead of me but well

826
00:37:33,670 --> 00:37:34,610
suppose they've all crashed and so all

827
00:37:34,809 --> 00:37:37,220
they have is the state that was marked

828
00:37:37,420 --> 00:37:39,980
as non-volatile in figure 2 which

829
00:37:40,179 --> 00:37:41,870
includes the log and maybe the latest

830
00:37:42,070 --> 00:37:45,110
term and so they don't know some if

831
00:37:45,309 --> 00:37:46,669
there's a crash but they all crash and

832
00:37:46,869 --> 00:37:48,490
they always start none of them knows

833
00:37:48,690 --> 00:37:52,669
initially how far they had been have

834
00:37:52,869 --> 00:37:55,070
executed before the crash so what

835
00:37:55,269 --> 00:37:57,230
happens is that you leader election one

836
00:37:57,429 --> 00:38:00,139
of them gets picked as a leader and that

837
00:38:00,338 --> 00:38:03,620
leader if you sort of track through what

838
00:38:03,820 --> 00:38:06,320
figure 2 says about how a pendant Rees

839
00:38:06,519 --> 00:38:08,269
is supposed to work the leader will

840
00:38:08,469 --> 00:38:10,480
actually figure out as a byproduct of

841
00:38:10,679 --> 00:38:12,620
sending out a pendant or sending out the

842
00:38:12,820 --> 00:38:15,800
first heartbeat really it'll fake it'll

843
00:38:16,000 --> 00:38:19,490
figure out what the latest point is

844
00:38:19,690 --> 00:38:28,100
basically that that all of the that a

845
00:38:28,300 --> 00:38:30,740
majority of the replicas agree on their

846
00:38:30,940 --> 00:38:33,490
laws because that's the commit point

847
00:38:33,690 --> 00:38:35,450
another way of looking at it is that

848
00:38:35,650 --> 00:38:37,550
once you choose a leader through the

849
00:38:37,750 --> 00:38:39,289
append entries mechanism the leader

850
00:38:39,489 --> 00:38:41,360
forces all of the other replicas to have

851
00:38:41,559 --> 00:38:43,850
identical logs to the leader and at that

852
00:38:44,050 --> 00:38:46,280
point plus a little bit of extra the

853
00:38:46,480 --> 00:38:48,620
paper explains at that point since the

854
00:38:48,820 --> 00:38:50,389
leader knows that it's forced all the

855
00:38:50,588 --> 00:38:52,370
replicas to have it I didn't have logs

856
00:38:52,570 --> 00:38:54,740
that are identicals to it then it knows

857
00:38:54,940 --> 00:38:56,919
that all the replicas must also have a

858
00:38:57,119 --> 00:39:00,590
there must be a majority of replicas

859
00:39:00,789 --> 00:39:02,960
with that all those log injuries in that

860
00:39:03,159 --> 00:39:04,700
logs which are now are identical must

861
00:39:04,900 --> 00:39:05,870
also be committed because they're held

862
00:39:06,070 --> 00:39:09,680
on a majority of replicas and at that

863
00:39:09,880 --> 00:39:13,519
point a leader you know the append

864
00:39:13,719 --> 00:39:15,620
entries code described in Figure 2 for

865
00:39:15,820 --> 00:39:17,600
the leader will increment the leaders

866
00:39:17,800 --> 00:39:19,730
commit point and everybody can now

867
00:39:19,929 --> 00:39:21,620
execute the entire log from the

868
00:39:21,820 --> 00:39:24,200
beginning and recreate their state from

869
00:39:24,400 --> 00:39:29,730
scratch possibly extremely laborious Lee

870
00:39:29,880 --> 00:39:32,450
so that's what figure two says it's

871
00:39:32,650 --> 00:39:34,730
obviously this be executing from scratch

872
00:39:34,929 --> 00:39:37,580
is not very attractive but it's where

873
00:39:37,780 --> 00:39:39,800
the basic protocol does and we'll see

874
00:39:40,000 --> 00:39:42,769
tomorrow that the the sort of version of

875
00:39:42,969 --> 00:39:43,910
this is more efficient to use as

876
00:39:44,110 --> 00:39:45,530
checkpoints and we'll talk about

877
00:39:45,730 --> 00:39:50,690
tomorrow okay so this was a sequence in

878
00:39:50,889 --> 00:39:54,989
sort of ordinary non failure operation

879
00:39:55,380 --> 00:39:57,050
another thing I want to briefly mention

880
00:39:57,250 --> 00:40:00,560
is what this interface looks like you've

881
00:40:00,760 --> 00:40:03,019
probably all seen a little bit of it due

882
00:40:03,219 --> 00:40:05,210
to working on the labs but roughly

883
00:40:05,409 --> 00:40:07,220
speaking if you have let's say that this

884
00:40:07,420 --> 00:40:12,200
key value layer with its state and the

885
00:40:12,400 --> 00:40:15,800
raft layer underneath it there's on each

886
00:40:16,000 --> 00:40:18,130
replica there's really two main pieces

887
00:40:18,329 --> 00:40:20,720
of the interface between them there's

888
00:40:20,920 --> 00:40:23,810
this method by which the key value layer

889
00:40:24,010 --> 00:40:26,030
can relay if a client sends in a request

890
00:40:26,230 --> 00:40:27,710
the key value layer has to give it to

891
00:40:27,909 --> 00:40:29,690
wrap and say please you know fit this

892
00:40:29,889 --> 00:40:31,220
request into the log somewhere and

893
00:40:31,420 --> 00:40:36,560
that's the start function that you'll

894
00:40:36,760 --> 00:40:40,220
see in Raph go and really just takes one

895
00:40:40,420 --> 00:40:44,150
argument the client command the key

896
00:40:44,349 --> 00:40:45,350
value they're saying please I got this

897
00:40:45,550 --> 00:40:46,910
command to get into the log and tell me

898
00:40:47,110 --> 00:40:50,120
when it's committed and the other piece

899
00:40:50,320 --> 00:40:54,110
of the interface is that by and by the

900
00:40:54,309 --> 00:40:55,730
raft layer will notify the key value

901
00:40:55,929 --> 00:40:57,980
layer that AHA that operation that you

902
00:40:58,179 --> 00:40:59,539
sent to me in a start command a while

903
00:40:59,739 --> 00:41:01,190
ago which may well not be the most

904
00:41:01,389 --> 00:41:03,230
recent start right there you know a

905
00:41:03,429 --> 00:41:05,120
hundred client commands could come in

906
00:41:05,320 --> 00:41:07,400
and cause calls to start before any of

907
00:41:07,599 --> 00:41:11,090
them are committed so by and by this

908
00:41:11,289 --> 00:41:14,060
upward communication is takes the form

909
00:41:14,260 --> 00:41:16,430
of a message on a go channel that the

910
00:41:16,630 --> 00:41:19,970
raft library sends on and key value

911
00:41:20,170 --> 00:41:23,720
layer is supposed to read from so

912
00:41:23,920 --> 00:41:27,920
there's this apply called the apply

913
00:41:28,119 --> 00:41:31,160
channel and on it on it you send apply

914
00:41:31,360 --> 00:41:33,900
message

915
00:41:37,440 --> 00:41:39,440
this start and of course you need the

916
00:41:39,639 --> 00:41:42,110
the key value layer needs to be able to

917
00:41:42,309 --> 00:41:44,360
match up message that receives an apply

918
00:41:44,559 --> 00:41:47,230
channel with calls to start that it made

919
00:41:47,429 --> 00:41:49,730
and so the start command actually

920
00:41:49,929 --> 00:41:52,399
returns enough information for that

921
00:41:52,599 --> 00:41:54,050
matchup to happen it returns the index

922
00:41:54,250 --> 00:41:58,340
that start functions basically returns

923
00:41:58,539 --> 00:42:00,260
the index in the log where if this

924
00:42:00,460 --> 00:42:01,970
command is committed which it might not

925
00:42:02,170 --> 00:42:05,480
be it'll be committed at this index and

926
00:42:05,679 --> 00:42:06,950
I think it also returns the current term

927
00:42:07,150 --> 00:42:08,180
and some other stuff we don't care about

928
00:42:08,380 --> 00:42:11,389
very much and then this apply message is

929
00:42:11,588 --> 00:42:26,330
going to contain the index command and

930
00:42:26,530 --> 00:42:27,769
all the replicas will get these apply

931
00:42:27,969 --> 00:42:29,570
messages so they'll all know though I

932
00:42:29,769 --> 00:42:33,320
should apply this command figure out

933
00:42:33,519 --> 00:42:34,970
what this command means and apply it to

934
00:42:35,170 --> 00:42:37,310
my local State and they also get the

935
00:42:37,510 --> 00:42:38,780
index the index is really only useful

936
00:42:38,980 --> 00:42:42,080
I'm the leader so it can figure out what

937
00:42:42,280 --> 00:42:43,550
client would what client requests were

938
00:42:43,750 --> 00:42:46,108
talking about

939
00:43:00,889 --> 00:43:03,889
by

940
00:43:14,409 --> 00:43:16,370
the answer a slightly different question

941
00:43:16,570 --> 00:43:18,710
let's suppose the client sends any

942
00:43:18,909 --> 00:43:21,530
request in let's say it's a put or a get

943
00:43:21,730 --> 00:43:23,210
could be put or again it doesn't really

944
00:43:23,409 --> 00:43:29,750
matter I'd say it to get the point in

945
00:43:29,949 --> 00:43:32,300
which the it's a client sense and again

946
00:43:32,500 --> 00:43:33,710
and waits for a response the point at

947
00:43:33,909 --> 00:43:36,800
which the leader will send a response at

948
00:43:37,000 --> 00:43:39,440
all is after the leader knows that

949
00:43:39,639 --> 00:43:41,480
command is committed so this is going to

950
00:43:41,679 --> 00:43:48,769
be a sort of get reply so the client

951
00:43:48,969 --> 00:43:52,030
doesn't see anything back I mean and so

952
00:43:52,230 --> 00:43:54,050
that means in terms of the actual

953
00:43:54,250 --> 00:43:56,630
software stack that means that the key

954
00:43:56,829 --> 00:43:59,240
value the RPC will arrive the key value

955
00:43:59,440 --> 00:44:01,820
layer will call the start function the

956
00:44:02,019 --> 00:44:03,620
start function will return to the key

957
00:44:03,820 --> 00:44:06,500
value layer but the key value layer will

958
00:44:06,699 --> 00:44:08,450
not yet reply to the client because it

959
00:44:08,650 --> 00:44:10,640
does not know if it's good actually it

960
00:44:10,840 --> 00:44:12,350
hasn't executed the clients request now

961
00:44:12,550 --> 00:44:13,640
it doesn't even know if it ever will

962
00:44:13,840 --> 00:44:16,370
because it's not sure if the request is

963
00:44:16,570 --> 00:44:18,620
going to be committed right in the

964
00:44:18,820 --> 00:44:20,300
situation which may not be committed is

965
00:44:20,500 --> 00:44:23,390
if the key value layer you know guess

966
00:44:23,590 --> 00:44:25,070
the request calls start and immediately

967
00:44:25,269 --> 00:44:26,960
after starboard turn two crashes right

968
00:44:27,159 --> 00:44:28,760
certainly hasn't sent out its apply what

969
00:44:28,960 --> 00:44:30,019
append messages or whatever

970
00:44:30,219 --> 00:44:33,320
nothing's be committed yep so so the

971
00:44:33,519 --> 00:44:36,400
game is start returns time passes the

972
00:44:36,599 --> 00:44:40,519
relevant apply message corresponding to

973
00:44:40,719 --> 00:44:42,289
that client request appears to the key

974
00:44:42,489 --> 00:44:44,000
value server on the apply channel and

975
00:44:44,199 --> 00:44:47,240
only then and that causes the key value

976
00:44:47,440 --> 00:44:50,450
server to execute the request and send

977
00:44:50,650 --> 00:44:53,010
her a plot

978
00:44:58,230 --> 00:44:59,960
and that's like all this is very

979
00:45:00,159 --> 00:45:01,970
important when it doesn't really matter

980
00:45:02,170 --> 00:45:04,160
if all everything goes well but if

981
00:45:04,360 --> 00:45:06,440
there's a failure we're now at the point

982
00:45:06,639 --> 00:45:07,580
where we start worrying about theatres I

983
00:45:07,780 --> 00:45:09,560
mean extremely interested in if there

984
00:45:09,760 --> 00:45:13,140
was a failure what did the client see

985
00:45:13,949 --> 00:45:18,350
all right and so one thing that does

986
00:45:18,550 --> 00:45:23,510
come up is that all of you should be

987
00:45:23,710 --> 00:45:24,740
familiar with this that at least

988
00:45:24,940 --> 00:45:26,510
initially one interesting thing about

989
00:45:26,710 --> 00:45:28,340
the logs is that they may not be

990
00:45:28,539 --> 00:45:30,560
identical there are a whole bunch of

991
00:45:30,760 --> 00:45:33,620
situations in which at least for brief

992
00:45:33,820 --> 00:45:36,169
periods of time the ends of the

993
00:45:36,369 --> 00:45:38,960
different replicas logs may diverge like

994
00:45:39,159 --> 00:45:41,510
for example if a leader starts to send

995
00:45:41,710 --> 00:45:43,190
out a round of append messages but

996
00:45:43,389 --> 00:45:44,960
crashes before it's able to send all

997
00:45:45,159 --> 00:45:46,700
them out you know that'll mean that some

998
00:45:46,900 --> 00:45:47,900
of the replicas that got the append

999
00:45:48,099 --> 00:45:50,300
message will append you know that new

1000
00:45:50,500 --> 00:45:51,740
log entry and the ones that didn't get

1001
00:45:51,940 --> 00:45:54,200
that append messages RPC won't have

1002
00:45:54,400 --> 00:45:56,240
appended them so it's easy to see that

1003
00:45:56,440 --> 00:45:58,780
the logs are I'm gonna diverge sometimes

1004
00:45:58,980 --> 00:46:02,659
the good news is that the the way a raft

1005
00:46:02,858 --> 00:46:05,180
works actually ends up forcing the logs

1006
00:46:05,380 --> 00:46:08,030
to be identical after a while there may

1007
00:46:08,230 --> 00:46:10,280
be transient differences but in the long

1008
00:46:10,480 --> 00:46:13,039
run all the logs will sort of be

1009
00:46:13,239 --> 00:46:15,140
modified by the leader until the leader

1010
00:46:15,340 --> 00:46:16,940
insurers are all identical and only then

1011
00:46:17,139 --> 00:46:24,289
are they executed okay so I think the

1012
00:46:24,489 --> 00:46:26,990
next there's really two big topics to

1013
00:46:27,190 --> 00:46:29,090
talk about here for raft one is how

1014
00:46:29,289 --> 00:46:31,250
leader election works which is lab two

1015
00:46:31,449 --> 00:46:34,970
and the other is how the leader deals

1016
00:46:35,170 --> 00:46:37,070
with the different replicas logs

1017
00:46:37,269 --> 00:46:39,500
particularly after failure so first I

1018
00:46:39,699 --> 00:46:42,689
want to talk about leader election

1019
00:46:44,940 --> 00:46:47,180
question to ask is how come the system

1020
00:46:47,380 --> 00:46:48,680
even has a leader why do we need a

1021
00:46:48,880 --> 00:46:51,620
leader the part of the answer is you do

1022
00:46:51,820 --> 00:46:53,510
not need a leader to build a system like

1023
00:46:53,710 --> 00:46:56,690
this you it is possible to build an

1024
00:46:56,889 --> 00:46:58,940
agreement system by which a cluster of

1025
00:46:59,139 --> 00:47:01,940
servers agrees you know the sequence of

1026
00:47:02,139 --> 00:47:04,010
entries in a log without having any kind

1027
00:47:04,210 --> 00:47:05,539
of designated leader

1028
00:47:05,739 --> 00:47:07,760
and indeed the original pack so system

1029
00:47:07,960 --> 00:47:09,710
which the paper refers to original Paxos

1030
00:47:09,909 --> 00:47:12,950
did not have a leader so it's possible

1031
00:47:13,150 --> 00:47:15,260
the reason why raft has a leader is

1032
00:47:15,460 --> 00:47:18,590
basically that there's probably a lot of

1033
00:47:18,789 --> 00:47:20,180
reasons but one of the foremost reasons

1034
00:47:20,380 --> 00:47:21,950
is that you can build a more efficient

1035
00:47:22,150 --> 00:47:24,200
in the common case in which the server's

1036
00:47:24,400 --> 00:47:26,930
don't fail it's possible to build a more

1037
00:47:27,130 --> 00:47:28,460
efficient system if you have a leader

1038
00:47:28,659 --> 00:47:30,440
because with a designated leader

1039
00:47:30,639 --> 00:47:33,110
everybody knows who the leader is you

1040
00:47:33,309 --> 00:47:37,340
can basically get agreement on requests

1041
00:47:37,539 --> 00:47:39,080
that with one round of messages per

1042
00:47:39,280 --> 00:47:41,269
request where as leader of this systems

1043
00:47:41,469 --> 00:47:43,280
have more of the flavor of well you need

1044
00:47:43,480 --> 00:47:45,380
a first round to kind of agree on a

1045
00:47:45,579 --> 00:47:47,419
temporary leader and then a second round

1046
00:47:47,619 --> 00:47:50,419
actually send out the requests so it's

1047
00:47:50,619 --> 00:47:53,260
probably the case that use of a leader

1048
00:47:53,460 --> 00:47:56,410
now speeds up the system by a factor two

1049
00:47:56,610 --> 00:47:58,550
and it also makes it sort of easier to

1050
00:47:58,750 --> 00:48:04,010
think about what's going on raft goes

1051
00:48:04,210 --> 00:48:08,480
through a sequence of leaders and it

1052
00:48:08,679 --> 00:48:10,970
uses these term numbers in order to sort

1053
00:48:11,170 --> 00:48:13,039
of disambiguate which leader we're

1054
00:48:13,239 --> 00:48:14,150
talking about it turns out that

1055
00:48:14,349 --> 00:48:15,409
followers don't really need to know the

1056
00:48:15,608 --> 00:48:17,180
identity of the leader they really just

1057
00:48:17,380 --> 00:48:18,320
need to know what the current term

1058
00:48:18,519 --> 00:48:23,000
number is each term has at most one

1059
00:48:23,199 --> 00:48:25,789
leader that's a critical property you

1060
00:48:25,989 --> 00:48:27,169
know for every term there might be no

1061
00:48:27,369 --> 00:48:28,820
leader during that term or there might

1062
00:48:29,019 --> 00:48:31,159
be one leader but there cannot be two

1063
00:48:31,358 --> 00:48:33,980
leaders during the same term every term

1064
00:48:34,179 --> 00:48:41,990
has it must most one leader how do the

1065
00:48:42,190 --> 00:48:44,289
leaders get created in the first place

1066
00:48:44,489 --> 00:48:47,900
every raft server keeps this election

1067
00:48:48,099 --> 00:48:50,000
timer which is just a it's basically

1068
00:48:50,199 --> 00:48:51,830
just out of time that it has recorded

1069
00:48:52,030 --> 00:48:53,930
that says well if that time occurs I'm

1070
00:48:54,130 --> 00:48:56,120
going to do something and the something

1071
00:48:56,320 --> 00:48:59,000
that it does is that if an entire leader

1072
00:48:59,199 --> 00:49:02,269
election period expires without the

1073
00:49:02,469 --> 00:49:04,280
server having heard any message from the

1074
00:49:04,480 --> 00:49:07,940
current leader then the server sort of

1075
00:49:08,139 --> 00:49:09,830
assumes probably that the current leader

1076
00:49:10,030 --> 00:49:12,380
is dead and starts an election so we

1077
00:49:12,579 --> 00:49:15,480
have this election timer

1078
00:49:17,869 --> 00:49:23,630
and if it expires we start an election

1079
00:49:28,460 --> 00:49:30,490
and what it means to start an election

1080
00:49:30,690 --> 00:49:35,370
is basically that you increment the term

1081
00:49:35,570 --> 00:49:38,289
the the candidate the server that's

1082
00:49:38,489 --> 00:49:39,730
decided it's going to be a candidate and

1083
00:49:39,929 --> 00:49:41,320
sort of force a new election first

1084
00:49:41,519 --> 00:49:43,750
increments this term because it wants

1085
00:49:43,949 --> 00:49:45,250
them to be a new leader namely itself

1086
00:49:45,449 --> 00:49:47,680
and you know leader a term can't have

1087
00:49:47,880 --> 00:49:48,970
more than one leader so we got to start

1088
00:49:49,170 --> 00:49:51,570
a new term in order to have a new leader

1089
00:49:51,769 --> 00:49:54,370
and then it sends out these requests

1090
00:49:54,570 --> 00:50:00,640
boats are pea seeds I'm going to send

1091
00:50:00,840 --> 00:50:02,620
out a full round of request votes and

1092
00:50:02,820 --> 00:50:04,930
you may only have to send out n minus

1093
00:50:05,130 --> 00:50:06,250
one requests votes because one of the

1094
00:50:06,449 --> 00:50:08,140
rules is that a new candidate always

1095
00:50:08,340 --> 00:50:13,330
votes for itself in the election so one

1096
00:50:13,530 --> 00:50:16,269
thing to note about this is that it's

1097
00:50:16,469 --> 00:50:17,769
not quite the case that if the leader

1098
00:50:17,969 --> 00:50:19,180
didn't fail we won't have an election

1099
00:50:19,380 --> 00:50:22,150
but if the leader does fail then we will

1100
00:50:22,349 --> 00:50:24,280
have election an election assuming any

1101
00:50:24,480 --> 00:50:26,200
other server is up because some day the

1102
00:50:26,400 --> 00:50:28,030
other servers election timers go will go

1103
00:50:28,230 --> 00:50:30,039
off but as leader didn't fail we might

1104
00:50:30,239 --> 00:50:32,200
still unfortunately get an election so

1105
00:50:32,400 --> 00:50:34,720
if the network is slow or drops a few

1106
00:50:34,920 --> 00:50:36,850
heartbeats or something we may end up

1107
00:50:37,050 --> 00:50:38,620
having election timers go off and even

1108
00:50:38,820 --> 00:50:40,240
though there was a perfectly good leader

1109
00:50:40,440 --> 00:50:42,190
we may nevertheless have a new election

1110
00:50:42,389 --> 00:50:43,539
so we have to sort of keep that in mind

1111
00:50:43,739 --> 00:50:44,440
when we're thinking about the

1112
00:50:44,639 --> 00:50:48,310
correctness and what that in turn means

1113
00:50:48,510 --> 00:50:50,169
is that if there's a new election it

1114
00:50:50,369 --> 00:50:52,210
could easily be the case that the old

1115
00:50:52,409 --> 00:50:54,159
leader is still hanging around and still

1116
00:50:54,358 --> 00:50:55,990
thinks it's the leader like if there's a

1117
00:50:56,190 --> 00:50:58,510
network partition for example and the

1118
00:50:58,710 --> 00:51:00,669
old leader is still alive and well in a

1119
00:51:00,869 --> 00:51:03,159
minority partition the majority

1120
00:51:03,358 --> 00:51:05,080
partition may run an election and indeed

1121
00:51:05,280 --> 00:51:06,669
a successful election and choose a new

1122
00:51:06,869 --> 00:51:09,789
leader all totally unknown to the

1123
00:51:09,989 --> 00:51:11,680
previous leader so we also have to worry

1124
00:51:11,880 --> 00:51:13,330
about you know what's that previous

1125
00:51:13,530 --> 00:51:15,220
leader gonna do since it does not know

1126
00:51:15,420 --> 00:51:19,400
there was a new election yes

1127
00:51:42,130 --> 00:51:44,669
okay so the question is are there can

1128
00:51:44,869 --> 00:51:46,740
there be pathological cases in which for

1129
00:51:46,940 --> 00:51:50,250
example one-way network communication

1130
00:51:50,449 --> 00:51:52,139
can prevent the system from making

1131
00:51:52,338 --> 00:51:54,350
progress I believe the answer is yes

1132
00:51:54,550 --> 00:51:56,730
certainly so for example if the current

1133
00:51:56,929 --> 00:52:00,780
leader if its network somehow half fails

1134
00:52:00,980 --> 00:52:02,639
in a way the current leader can send out

1135
00:52:02,838 --> 00:52:03,800
heartbeats

1136
00:52:04,000 --> 00:52:07,080
but can't receive any client requests

1137
00:52:07,280 --> 00:52:09,750
then the heartbeats that it sends out

1138
00:52:09,949 --> 00:52:11,669
which are delivered because it's

1139
00:52:11,869 --> 00:52:13,710
outgoing network connection works its

1140
00:52:13,909 --> 00:52:17,909
outgoing heartbeats will suppress any

1141
00:52:18,108 --> 00:52:20,100
other server from starting an election

1142
00:52:20,300 --> 00:52:22,080
but the fact that it's incoming Network

1143
00:52:22,280 --> 00:52:24,600
why or apparently is broken will prevent

1144
00:52:24,800 --> 00:52:26,519
it from hearing and executing any client

1145
00:52:26,719 --> 00:52:29,010
commands it's absolutely the case that

1146
00:52:29,210 --> 00:52:35,159
raft is not proof against all sort of

1147
00:52:35,358 --> 00:52:36,990
all crazy Network problems that can come

1148
00:52:37,190 --> 00:52:38,700
up I believe the ones I've thought about

1149
00:52:38,900 --> 00:52:42,060
I believe are fixable in the sense that

1150
00:52:42,260 --> 00:52:46,769
the we could solve this one by having a

1151
00:52:46,969 --> 00:52:49,139
sort of requiring a two-way heartbeat in

1152
00:52:49,338 --> 00:52:51,570
which if the leader sends out heartbeats

1153
00:52:51,769 --> 00:52:53,250
but you know there were in which

1154
00:52:53,449 --> 00:52:55,500
followers are required to reply in some

1155
00:52:55,699 --> 00:52:56,789
way to heartbeats I guess they are

1156
00:52:56,989 --> 00:52:59,039
already required to apply if the leader

1157
00:52:59,239 --> 00:53:01,669
stop seeing replies to its heartbeats

1158
00:53:01,869 --> 00:53:04,260
then after some amount of time and which

1159
00:53:04,460 --> 00:53:06,030
is seasonals replies the leader decides

1160
00:53:06,230 --> 00:53:09,030
to step down I feel like that specific

1161
00:53:09,230 --> 00:53:12,330
issue can be fixed and many others can

1162
00:53:12,530 --> 00:53:15,869
too but I but you know you're absolutely

1163
00:53:16,068 --> 00:53:17,700
right that very strange things can

1164
00:53:17,900 --> 00:53:19,399
happen to networks including some that

1165
00:53:19,599 --> 00:53:23,588
the protocol is not prepared for

1166
00:53:28,739 --> 00:53:32,060
okay so we got these meter elections we

1167
00:53:32,260 --> 00:53:33,649
need to ensure that there is at most at

1168
00:53:33,849 --> 00:53:35,240
most one meter per term

1169
00:53:35,440 --> 00:53:37,880
how does Rath do that well Rath requires

1170
00:53:38,079 --> 00:53:40,039
in order to be elected for a term Raft

1171
00:53:40,239 --> 00:53:42,500
requires a candidate to get yes votes

1172
00:53:42,699 --> 00:53:45,830
from a majority of the server's the

1173
00:53:46,030 --> 00:53:47,780
servers and each server will only cast

1174
00:53:47,980 --> 00:53:52,190
one yes vote per term so in any given

1175
00:53:52,389 --> 00:53:55,490
term you know it basically means that in

1176
00:53:55,690 --> 00:53:57,980
any given term Easter votes only once

1177
00:53:58,179 --> 00:54:00,860
for only one candidate you can't have

1178
00:54:01,059 --> 00:54:03,080
two candidates both get a majority of

1179
00:54:03,280 --> 00:54:06,370
votes because everybody votes only once

1180
00:54:06,570 --> 00:54:09,470
so the majorities majority rule causes

1181
00:54:09,670 --> 00:54:11,330
there to be at most one winning

1182
00:54:11,530 --> 00:54:17,200
candidate and so then we get at most one

1183
00:54:17,400 --> 00:54:21,150
candidate elected per turn

1184
00:54:24,449 --> 00:54:28,430
and in addition critically the majority

1185
00:54:28,630 --> 00:54:31,730
rule means that you can get elected even

1186
00:54:31,929 --> 00:54:34,250
if some servers have crashed right if a

1187
00:54:34,449 --> 00:54:35,810
minority of servers are crashed aren't

1188
00:54:36,010 --> 00:54:37,490
available and network problems we can

1189
00:54:37,690 --> 00:54:39,500
still elect a leader if more than half a

1190
00:54:39,699 --> 00:54:41,330
crash or not available or in another

1191
00:54:41,530 --> 00:54:43,190
partition or something then actually the

1192
00:54:43,389 --> 00:54:44,630
system will just sit there trying again

1193
00:54:44,829 --> 00:54:46,880
and again to elect a leader and never

1194
00:54:47,079 --> 00:54:49,280
elect one if it cannot in fact they're

1195
00:54:49,480 --> 00:54:54,530
not a majority of live servers if an

1196
00:54:54,730 --> 00:54:57,200
election succeeds everybody would be

1197
00:54:57,400 --> 00:54:58,760
great if everybody learned about it I

1198
00:54:58,960 --> 00:55:01,159
mean need to ask ourselves how do all

1199
00:55:01,358 --> 00:55:02,780
the parties learn learn what happened

1200
00:55:02,980 --> 00:55:04,550
the server that wins an election

1201
00:55:04,750 --> 00:55:07,100
assuming it doesn't crash the server

1202
00:55:07,300 --> 00:55:09,350
that wins election will actually see a

1203
00:55:09,550 --> 00:55:12,530
majority or positive votes for its

1204
00:55:12,730 --> 00:55:15,200
request vote from a majority of the

1205
00:55:15,400 --> 00:55:17,539
other servers so the candidates running

1206
00:55:17,739 --> 00:55:19,340
the election that wins it the Kennedy

1207
00:55:19,539 --> 00:55:20,510
that wins the election will actually

1208
00:55:20,710 --> 00:55:22,760
know directly uh I got a majority of

1209
00:55:22,960 --> 00:55:25,820
votes but nobody else directly knows who

1210
00:55:26,019 --> 00:55:28,700
the winner was or whether anybody one so

1211
00:55:28,900 --> 00:55:30,590
the way that the candidate informs other

1212
00:55:30,789 --> 00:55:33,470
servers is that heartbeat the rules and

1213
00:55:33,670 --> 00:55:34,669
figure to say oh if you're in an

1214
00:55:34,869 --> 00:55:36,080
election your immediately required to

1215
00:55:36,280 --> 00:55:37,159
send out an independent

1216
00:55:37,358 --> 00:55:39,740
trees to all the other servers now the

1217
00:55:39,940 --> 00:55:41,720
append entries that heartbeat append

1218
00:55:41,920 --> 00:55:44,960
entries doesn't explicitly say I won the

1219
00:55:45,159 --> 00:55:47,629
election you know I'm a leader for term

1220
00:55:47,829 --> 00:55:50,809
23 it's a little more subtle than that

1221
00:55:51,009 --> 00:55:53,510
the the way the information is

1222
00:55:53,710 --> 00:55:57,349
communicated is that no one is allowed

1223
00:55:57,548 --> 00:56:00,048
to send out an append entries unless

1224
00:56:00,248 --> 00:56:02,599
they're a leader for that term so the

1225
00:56:02,798 --> 00:56:05,359
fact that I I'm a you know I'm a server

1226
00:56:05,559 --> 00:56:06,829
and I saw oh there's an election for

1227
00:56:07,028 --> 00:56:09,379
term 19 and then by-and-by I sent an

1228
00:56:09,579 --> 00:56:12,530
append entries whose term is 19 that

1229
00:56:12,730 --> 00:56:14,809
tells me that somebody I don't know who

1230
00:56:15,009 --> 00:56:17,899
but somebody won the election so that's

1231
00:56:18,099 --> 00:56:19,190
how the other servers knows they were

1232
00:56:19,389 --> 00:56:21,159
receiving append entries for that term

1233
00:56:21,358 --> 00:56:24,470
and that append entries also has the

1234
00:56:24,670 --> 00:56:27,169
effect of resetting everybody's election

1235
00:56:27,369 --> 00:56:30,079
time timer so as long as the leader is

1236
00:56:30,278 --> 00:56:31,909
up and it sends out heartbeat messages

1237
00:56:32,108 --> 00:56:34,399
or append entries at least you know at

1238
00:56:34,599 --> 00:56:36,710
the rate that's supposed to every time a

1239
00:56:36,909 --> 00:56:38,450
server receives an append entries it'll

1240
00:56:38,650 --> 00:56:42,369
reset its selection timer and sort of

1241
00:56:42,568 --> 00:56:45,048
suppress anybody from being a new

1242
00:56:45,248 --> 00:56:47,089
candidate so as long as everything's

1243
00:56:47,289 --> 00:56:49,339
functioning the repeated heartbeats will

1244
00:56:49,539 --> 00:56:52,099
prevent any further elections of course

1245
00:56:52,298 --> 00:56:53,659
it the network fails or packets are

1246
00:56:53,858 --> 00:56:55,369
dropped there may nevertheless be an

1247
00:56:55,568 --> 00:56:57,680
election but if all goes well we're sort

1248
00:56:57,880 --> 00:57:03,289
of unlikely to get an election this

1249
00:57:03,489 --> 00:57:05,539
scheme could fail in the sense that it

1250
00:57:05,739 --> 00:57:07,129
can't fail in the sense of electing to

1251
00:57:07,329 --> 00:57:09,649
leaders fair term but it can fail in the

1252
00:57:09,849 --> 00:57:11,180
sense of electing zero leaders for a

1253
00:57:11,380 --> 00:57:14,119
term that's sort of morningway it may

1254
00:57:14,318 --> 00:57:16,010
fail is that if too many servers are

1255
00:57:16,210 --> 00:57:18,079
dead or unavailable or a bad network

1256
00:57:18,278 --> 00:57:19,490
connection so if you can't assemble a

1257
00:57:19,690 --> 00:57:21,680
majority you can't be elected nothing

1258
00:57:21,880 --> 00:57:24,289
happens the more interesting way in

1259
00:57:24,489 --> 00:57:26,950
which an election can fail is if

1260
00:57:27,150 --> 00:57:29,869
everybody's up you know there's no

1261
00:57:30,068 --> 00:57:32,930
failures no packets are dropped but two

1262
00:57:33,130 --> 00:57:35,599
leaders become candidate close together

1263
00:57:35,798 --> 00:57:38,298
enough in time that they split the vote

1264
00:57:38,498 --> 00:57:43,108
between them or say three leaders

1265
00:57:45,019 --> 00:57:46,169
so supposing we have three liters

1266
00:57:46,369 --> 00:57:48,980
supposing we have a three replica system

1267
00:57:49,179 --> 00:57:51,660
all their election timers go off at the

1268
00:57:51,860 --> 00:57:54,560
same time every server both for itself

1269
00:57:54,760 --> 00:57:57,450
and then when each of them receives a

1270
00:57:57,650 --> 00:57:58,860
request vote from another server well

1271
00:57:59,059 --> 00:58:00,510
it's already cast its vote for itself

1272
00:58:00,710 --> 00:58:02,580
and so it says no so that means that it

1273
00:58:02,780 --> 00:58:03,900
all three of the server's needs to get

1274
00:58:04,099 --> 00:58:05,730
one vote each nobody gets a majority and

1275
00:58:05,929 --> 00:58:09,600
nobody's elected so then their election

1276
00:58:09,800 --> 00:58:11,250
timers will go off again because the

1277
00:58:11,449 --> 00:58:12,690
election timers only be said if it gets

1278
00:58:12,889 --> 00:58:14,160
an append entries but there's no leader

1279
00:58:14,360 --> 00:58:16,260
so no append entries they'll all have

1280
00:58:16,460 --> 00:58:17,730
their election timers go off again and

1281
00:58:17,929 --> 00:58:18,900
if we're unlucky

1282
00:58:19,099 --> 00:58:20,070
they'll all go off at the same time

1283
00:58:20,269 --> 00:58:21,960
they'll all go for themselves nobody

1284
00:58:22,159 --> 00:58:26,940
will get a majority so so clearly I'm

1285
00:58:27,139 --> 00:58:28,160
sure you're all aware at this point

1286
00:58:28,360 --> 00:58:31,320
there's more to this story and the way

1287
00:58:31,519 --> 00:58:35,430
Raft makes this possibility of split

1288
00:58:35,630 --> 00:58:38,519
votes unlikely but not impossible

1289
00:58:38,719 --> 00:58:40,860
is by randomizing these election timers

1290
00:58:41,059 --> 00:58:44,010
so the way to think of it and the

1291
00:58:44,210 --> 00:58:46,200
randomization the way to think of it is

1292
00:58:46,400 --> 00:58:47,700
that supposing you have some time line

1293
00:58:47,900 --> 00:58:51,930
I'm gonna draw a vents on there's some

1294
00:58:52,130 --> 00:58:53,970
point at which everybody received the

1295
00:58:54,170 --> 00:58:57,240
last append entries right and then maybe

1296
00:58:57,440 --> 00:58:58,590
the server died let's just assume the

1297
00:58:58,789 --> 00:59:00,900
server send out a last heartbeat and

1298
00:59:01,099 --> 00:59:07,989
then died well all of the followers have

1299
00:59:08,108 --> 00:59:10,919
this we set their election timers when

1300
00:59:11,119 --> 00:59:12,960
they received at the same time because

1301
00:59:13,159 --> 00:59:14,370
they probably all receive this append

1302
00:59:14,570 --> 00:59:15,840
enters at the same time they all reset

1303
00:59:16,039 --> 00:59:18,090
their election timers for some point in

1304
00:59:18,289 --> 00:59:21,330
the future the future but they chose

1305
00:59:21,530 --> 00:59:23,430
different random times in the future

1306
00:59:23,630 --> 00:59:25,169
which then we're gonna go off

1307
00:59:25,369 --> 00:59:26,850
so it's suppose the dead leader server

1308
00:59:27,050 --> 00:59:30,030
one so now server two and server 3 at

1309
00:59:30,230 --> 00:59:32,159
this point set their election timers for

1310
00:59:32,358 --> 00:59:33,810
a random point in the future let's say

1311
00:59:34,010 --> 00:59:37,769
server to set their I like some timer to

1312
00:59:37,969 --> 00:59:40,830
go off here and server 3 set its

1313
00:59:41,030 --> 00:59:43,680
election timer to go off there and the

1314
00:59:43,880 --> 00:59:46,010
crucial point about this picture is that

1315
00:59:46,210 --> 00:59:47,880
assuming they picked different random

1316
00:59:48,079 --> 00:59:51,060
numbers one of them is first and the

1317
00:59:51,260 --> 00:59:54,360
other one is second right that's what's

1318
00:59:54,559 --> 00:59:56,400
going on here and the one that's first

1319
00:59:56,599 --> 00:59:57,869
assuming

1320
00:59:58,068 --> 00:59:59,879
this gap is big enough the one that's

1321
01:00:00,079 --> 01:00:01,200
first it's election time will go off

1322
01:00:01,400 --> 01:00:02,669
first before the other ones election

1323
01:00:02,869 --> 01:00:05,730
timer and if we're close were not

1324
01:00:05,929 --> 01:00:06,210
unlucky

1325
01:00:06,409 --> 01:00:08,220
it'll have time to send out a full round

1326
01:00:08,420 --> 01:00:11,550
of vote requests and get answers from

1327
01:00:11,750 --> 01:00:13,430
everybody who everybody's alive before

1328
01:00:13,630 --> 01:00:16,619
the second election timer goes off from

1329
01:00:16,818 --> 01:00:22,369
any other server so does everybody see

1330
01:00:22,568 --> 01:00:25,940
how the randomization D synchronizes

1331
01:00:26,139 --> 01:00:30,510
these candidates unfortunately there's a

1332
01:00:30,710 --> 01:00:33,030
bit of art in setting the contents

1333
01:00:33,230 --> 01:00:34,769
constants for these election timers

1334
01:00:34,969 --> 01:00:36,289
there's some sort of competing

1335
01:00:36,489 --> 01:00:40,010
requirements you might want to fulfill

1336
01:00:40,210 --> 01:00:43,109
so one obvious requirement is that the

1337
01:00:43,309 --> 01:00:45,030
election timer has to be at least as

1338
01:00:45,230 --> 01:00:46,830
long as the expected interval between

1339
01:00:47,030 --> 01:00:47,609
heartbeats

1340
01:00:47,809 --> 01:00:49,590
you know this is pretty obvious that the

1341
01:00:49,789 --> 01:00:51,210
leader sends out heartbeats every

1342
01:00:51,409 --> 01:00:53,490
hundred milliseconds you better make

1343
01:00:53,690 --> 01:00:55,320
sure there's no point in having the

1344
01:00:55,519 --> 01:00:57,119
election time or anybody's election time

1345
01:00:57,318 --> 01:00:58,649
or ever go off Borja for 100

1346
01:00:58,849 --> 01:01:00,330
milliseconds because then it will go off

1347
01:01:00,530 --> 01:01:06,599
before the lower limit is certainly the

1348
01:01:06,798 --> 01:01:08,369
lower limit is one heartbeat interval in

1349
01:01:08,568 --> 01:01:10,740
fact because the network may drop

1350
01:01:10,940 --> 01:01:13,500
packets you probably want to have the

1351
01:01:13,699 --> 01:01:16,109
minimum election timer value be a couple

1352
01:01:16,309 --> 01:01:18,629
of times the heartbeat interval so 400

1353
01:01:18,829 --> 01:01:19,889
millisecond heartbeats you probably want

1354
01:01:20,088 --> 01:01:21,240
to have the very shortest possible

1355
01:01:21,440 --> 01:01:24,119
election time or be you know say 300

1356
01:01:24,318 --> 01:01:25,919
milliseconds you know three times the

1357
01:01:26,119 --> 01:01:29,250
heartbeat interval so that's the sort of

1358
01:01:29,449 --> 01:01:33,510
minimum is the heart heartbeat so this

1359
01:01:33,710 --> 01:01:35,369
frequent you want the minimum to be you

1360
01:01:35,568 --> 01:01:39,269
know a couple of times that or here so

1361
01:01:39,469 --> 01:01:40,440
what about the maximum you know you're

1362
01:01:40,639 --> 01:01:42,810
gonna presumably randomize uniformly

1363
01:01:43,010 --> 01:01:45,510
over some range of times you know where

1364
01:01:45,710 --> 01:01:50,760
should we set the kind of maximum time

1365
01:01:50,960 --> 01:01:54,510
that we're randomizing over there's a

1366
01:01:54,710 --> 01:01:57,539
couple of considerations here in a real

1367
01:01:57,739 --> 01:02:04,210
system you know this maximum time effect

1368
01:02:04,409 --> 01:02:06,039
how quickly the system can recover from

1369
01:02:06,239 --> 01:02:09,220
failure because remember from the time

1370
01:02:09,420 --> 01:02:11,710
at which the server fails until the

1371
01:02:11,909 --> 01:02:14,530
first election timer goes off the whole

1372
01:02:14,730 --> 01:02:17,230
system is frozen there's no leader you

1373
01:02:17,429 --> 01:02:18,670
know the clients requests are being

1374
01:02:18,869 --> 01:02:19,990
thrown away because there's no leader

1375
01:02:20,190 --> 01:02:22,120
and we're not assigning a new leader

1376
01:02:22,320 --> 01:02:24,670
even though you know presumably these

1377
01:02:24,869 --> 01:02:27,190
other servers are up so the beer we

1378
01:02:27,389 --> 01:02:29,470
choose this maximum the long or delay

1379
01:02:29,670 --> 01:02:31,840
we're imposing on clients before

1380
01:02:32,039 --> 01:02:34,570
recovery occurs you know whether that's

1381
01:02:34,769 --> 01:02:38,019
important depends on sort of how high

1382
01:02:38,219 --> 01:02:40,000
performance we need this to be and how

1383
01:02:40,199 --> 01:02:42,670
often we think there will be failures

1384
01:02:42,869 --> 01:02:44,710
failures happen once a year then who

1385
01:02:44,909 --> 01:02:46,110
cares

1386
01:02:46,309 --> 01:02:48,400
we're expecting failures frequently we

1387
01:02:48,599 --> 01:02:51,130
may care very much how long it takes to

1388
01:02:51,329 --> 01:02:53,470
recover okay so that's one consideration

1389
01:02:53,670 --> 01:02:56,130
the other consideration is that this gap

1390
01:02:56,329 --> 01:02:59,200
that is the expected gap in time between

1391
01:02:59,400 --> 01:03:01,210
the first time are going off and the

1392
01:03:01,409 --> 01:03:04,690
second timer going off this gap really

1393
01:03:04,889 --> 01:03:07,690
in order to be useful has to be longer

1394
01:03:07,889 --> 01:03:09,730
than the time it takes for the candidate

1395
01:03:09,929 --> 01:03:12,130
to assemble votes from everybody that is

1396
01:03:12,329 --> 01:03:14,860
longer than the expected round-trip time

1397
01:03:15,059 --> 01:03:16,390
the amount of time it takes to send an

1398
01:03:16,590 --> 01:03:18,850
RPC and get the response and so maybe it

1399
01:03:19,050 --> 01:03:21,640
takes 10 milliseconds to send an RPC and

1400
01:03:21,840 --> 01:03:25,660
get a response a response from all the

1401
01:03:25,860 --> 01:03:27,610
other servers and if that's the case we

1402
01:03:27,809 --> 01:03:28,780
need to make maximum at least long

1403
01:03:28,980 --> 01:03:30,370
enough that there's pretty likely to be

1404
01:03:30,570 --> 01:03:32,019
10 milliseconds difference between the

1405
01:03:32,219 --> 01:03:33,910
smallest random number and the next

1406
01:03:34,110 --> 01:03:37,039
smallest random number

1407
01:03:40,550 --> 01:03:46,269
and for you the test code will get upset

1408
01:03:46,469 --> 01:03:54,159
if you if you don't recover from a

1409
01:03:54,358 --> 01:03:56,650
leader failure in a couple seconds and

1410
01:03:56,849 --> 01:03:58,720
so just pragmatically you need to tune

1411
01:03:58,920 --> 01:04:00,789
this maximum down so that it's highly

1412
01:04:00,989 --> 01:04:03,519
likely that you'll be able to complete a

1413
01:04:03,719 --> 01:04:05,740
leader election within a few seconds but

1414
01:04:05,940 --> 01:04:09,340
that's not a very tight constraint any

1415
01:04:09,539 --> 01:04:13,470
questions about the election time outs

1416
01:04:13,670 --> 01:04:19,710
one tiny point is that you want to

1417
01:04:19,909 --> 01:04:22,990
choose new random time outs every time

1418
01:04:23,190 --> 01:04:26,500
there's every time you every time I node

1419
01:04:26,699 --> 01:04:28,539
sets it to like me sets its election

1420
01:04:28,739 --> 01:04:31,030
timer that is don't choose a random

1421
01:04:31,230 --> 01:04:34,630
number when the server is first created

1422
01:04:34,829 --> 01:04:35,890
and then we use that same number over

1423
01:04:36,090 --> 01:04:37,269
and over again because you make an

1424
01:04:37,469 --> 01:04:39,519
unlucky choice that is you choose this

1425
01:04:39,719 --> 01:04:42,070
one server happens by ill chance to

1426
01:04:42,269 --> 01:04:43,960
choose the same random number as another

1427
01:04:44,159 --> 01:04:45,850
server that means that you're gonna have

1428
01:04:46,050 --> 01:04:48,630
split votes over and over again forever

1429
01:04:48,829 --> 01:04:51,100
that's why you want to almost certainly

1430
01:04:51,300 --> 01:04:53,140
choose a different a new fresh random

1431
01:04:53,340 --> 01:04:55,930
number for the election time out value

1432
01:04:56,130 --> 01:05:02,740
every time you reset the timer all right

1433
01:05:02,940 --> 01:05:06,600
so the final issue about leader election

1434
01:05:06,800 --> 01:05:08,830
suppose we are in this situation where

1435
01:05:09,030 --> 01:05:10,990
the old leaders partition you know the

1436
01:05:11,190 --> 01:05:12,760
network cable is broken and the old

1437
01:05:12,960 --> 01:05:14,590
leader is sort of out there with a

1438
01:05:14,789 --> 01:05:17,019
couple clients and a minority of servers

1439
01:05:17,219 --> 01:05:20,320
and there's a majority in the other half

1440
01:05:20,519 --> 01:05:21,430
of the network and the majority of the

1441
01:05:21,630 --> 01:05:22,510
new half of the network elects a new

1442
01:05:22,710 --> 01:05:28,000
leader what about the old leader why why

1443
01:05:28,199 --> 01:05:32,590
won't the old leader cause incorrect

1444
01:05:32,789 --> 01:05:35,389
execution

1445
01:06:06,309 --> 01:06:09,780
yes to two potential problems one is or

1446
01:06:09,980 --> 01:06:12,660
one some non problem is that if there's

1447
01:06:12,860 --> 01:06:14,310
a leader off in another partition and it

1448
01:06:14,510 --> 01:06:16,830
doesn't have a majority then the next

1449
01:06:17,030 --> 01:06:20,730
time a client sends it a request that

1450
01:06:20,929 --> 01:06:24,060
that leader that you know in a partition

1451
01:06:24,260 --> 01:06:25,200
with a minority yeah it'll send out

1452
01:06:25,400 --> 01:06:27,300
append entries but because it's in the

1453
01:06:27,500 --> 01:06:29,730
minority partition it won't be able to

1454
01:06:29,929 --> 01:06:31,740
get responses back from a majority of

1455
01:06:31,940 --> 01:06:33,660
the server's including itself and so it

1456
01:06:33,860 --> 01:06:35,910
will never commit the operation it will

1457
01:06:36,110 --> 01:06:36,900
never execute it

1458
01:06:37,099 --> 01:06:39,630
it'll never respond to the client saying

1459
01:06:39,829 --> 01:06:42,269
that it executed it either and so that

1460
01:06:42,469 --> 01:06:45,660
means that yeah an old server often a

1461
01:06:45,860 --> 01:06:47,730
different partition people many clients

1462
01:06:47,929 --> 01:06:49,470
may send a request but they'll never get

1463
01:06:49,670 --> 01:06:53,820
responses so no client will be fooled

1464
01:06:54,019 --> 01:06:56,430
into thinking that that old server

1465
01:06:56,630 --> 01:07:01,800
executed anything for it the other sort

1466
01:07:02,000 --> 01:07:05,250
of more tricky issue which actually I'll

1467
01:07:05,449 --> 01:07:06,840
talk about in a few minutes is the

1468
01:07:07,039 --> 01:07:10,470
possibility that before server fails it

1469
01:07:10,670 --> 01:07:13,880
sends out append entries to a subset of

1470
01:07:14,079 --> 01:07:17,460
the servers and then crashes before

1471
01:07:17,659 --> 01:07:20,850
making a commission and as a very

1472
01:07:21,050 --> 01:07:24,630
interesting question which I'll probably

1473
01:07:24,829 --> 01:07:27,560
spend a good 45 minutes talking about

1474
01:07:27,760 --> 01:07:29,850
and so actually before I turn to the

1475
01:07:30,050 --> 01:07:33,060
back topic in general any more questions

1476
01:07:33,260 --> 01:07:40,390
about in leader election okay

1477
01:07:42,219 --> 01:07:44,730
okay so how about the contents of the

1478
01:07:44,929 --> 01:07:48,960
logs and how in particular how a newly

1479
01:07:49,159 --> 01:07:51,539
elected leader possibly picking up the

1480
01:07:51,739 --> 01:07:54,240
pieces after an awkward crash of the

1481
01:07:54,440 --> 01:07:56,550
previous leader how does a newly elected

1482
01:07:56,750 --> 01:07:59,430
leader sort out the possibly divergent

1483
01:07:59,630 --> 01:08:02,100
logs on the different replicas in order

1484
01:08:02,300 --> 01:08:05,940
to restore sort of consistent state in

1485
01:08:06,139 --> 01:08:14,460
the system all right so the first

1486
01:08:14,659 --> 01:08:17,670
question is what can think this is this

1487
01:08:17,869 --> 01:08:19,470
whole topic it's really only interesting

1488
01:08:19,670 --> 01:08:21,720
after a server crashes right if the

1489
01:08:21,920 --> 01:08:25,260
server stays up then relatively few

1490
01:08:25,460 --> 01:08:26,730
things can go wrong if we have a server

1491
01:08:26,930 --> 01:08:28,440
that's up and has a majority you know

1492
01:08:28,640 --> 01:08:29,670
during the period of time when it's up

1493
01:08:29,869 --> 01:08:33,869
and has a majority it just tells the

1494
01:08:34,069 --> 01:08:35,699
followers what the logs should look like

1495
01:08:35,899 --> 01:08:37,559
and the followers are not allowed to

1496
01:08:37,759 --> 01:08:39,449
disagree they're required to accept they

1497
01:08:39,649 --> 01:08:41,220
just do by the rules of figure two if

1498
01:08:41,420 --> 01:08:42,900
they've been more or less keeping up you

1499
01:08:43,100 --> 01:08:44,460
know they just take whatever the leader

1500
01:08:44,659 --> 01:08:46,019
sends them independent reason appended

1501
01:08:46,219 --> 01:08:48,300
to the log and obey commit messages and

1502
01:08:48,500 --> 01:08:50,099
execute there's hardly anything to go

1503
01:08:50,298 --> 01:08:51,869
wrong the things that go wrong in Rapp

1504
01:08:52,069 --> 01:08:55,409
go wrong when a the old leader crashes

1505
01:08:55,609 --> 01:08:58,320
sort of midway through you know sending

1506
01:08:58,520 --> 01:09:01,739
out messages or a new leader crashes you

1507
01:09:01,939 --> 01:09:03,029
know sort of just after it's been

1508
01:09:03,229 --> 01:09:06,750
elected but before it's done anything

1509
01:09:06,949 --> 01:09:09,930
very useful so one thing we're very

1510
01:09:10,130 --> 01:09:11,579
interested in is what can the logs look

1511
01:09:11,779 --> 01:09:16,470
like after some sequence of crashes okay

1512
01:09:16,670 --> 01:09:19,320
so here's an example supposing we have

1513
01:09:19,520 --> 01:09:25,980
two servers and the way I'm gonna draw

1514
01:09:26,180 --> 01:09:27,389
out these diagrams because we're gonna

1515
01:09:27,588 --> 01:09:30,680
be looking a lot at a lot of sort of

1516
01:09:30,880 --> 01:09:32,788
situations where the logs look like this

1517
01:09:32,988 --> 01:09:34,590
and we're gonna be wondering is that

1518
01:09:34,789 --> 01:09:36,449
possible and what happens if they do

1519
01:09:36,649 --> 01:09:38,279
look like that so my notation is going

1520
01:09:38,479 --> 01:09:40,170
to be I'm gonna write out log entries

1521
01:09:40,369 --> 01:09:44,670
for each of the servers sort of aligned

1522
01:09:44,869 --> 01:09:47,639
to indicate slots corresponding slots in

1523
01:09:47,838 --> 01:09:50,070
the log and the values I'm going to

1524
01:09:50,270 --> 01:09:53,130
write here are the term numbers rather

1525
01:09:53,329 --> 01:09:54,140
than

1526
01:09:54,340 --> 01:09:56,689
client operations I'm going to you know

1527
01:09:56,889 --> 01:09:59,019
this is slot one this is thought to

1528
01:09:59,219 --> 01:10:02,180
everybody saw a command from term three

1529
01:10:02,380 --> 01:10:05,029
in slot 1 and server tuned server three

1530
01:10:05,229 --> 01:10:08,119
saw command from also term three and the

1531
01:10:08,319 --> 01:10:10,038
second slot the server one has nothing

1532
01:10:10,238 --> 01:10:14,600
there at all and so question for this

1533
01:10:14,800 --> 01:10:16,279
like the very first question is can this

1534
01:10:16,479 --> 01:10:21,458
arrive could this setup arise and how

1535
01:10:21,658 --> 01:10:24,658
yes

1536
01:11:02,130 --> 01:11:04,640
so you know maybe server 3 was the

1537
01:11:04,840 --> 01:11:06,079
leader for just repeating what you said

1538
01:11:06,279 --> 01:11:08,119
maybe server 3 is the leader for term 3

1539
01:11:08,319 --> 01:11:09,770
he got a command that sent out to

1540
01:11:09,970 --> 01:11:11,180
everybody everybody received a dependent

1541
01:11:11,380 --> 01:11:14,150
at the log and then I got a server 3 got

1542
01:11:14,350 --> 01:11:17,960
a second request from a client and maybe

1543
01:11:18,159 --> 01:11:19,610
it sent it to all three servers but the

1544
01:11:19,810 --> 01:11:20,930
message got lost on the way to server

1545
01:11:21,130 --> 01:11:22,820
one or maybe server was down at the time

1546
01:11:23,020 --> 01:11:24,829
or something and so only server to the

1547
01:11:25,029 --> 01:11:27,949
leader always append new commands to its

1548
01:11:28,149 --> 01:11:29,630
log before it sends out append entries

1549
01:11:29,829 --> 01:11:32,180
and maybe the append entry RPC only got

1550
01:11:32,380 --> 01:11:34,190
to server 2 so this situation you know

1551
01:11:34,390 --> 01:11:35,960
it's like the simplest situation and was

1552
01:11:36,159 --> 01:11:38,260
actually the logs are not different and

1553
01:11:38,460 --> 01:11:43,279
we know how it could possibly arise and

1554
01:11:43,479 --> 01:11:45,050
so if server 3 which is a leadership

1555
01:11:45,250 --> 01:11:46,279
crash now you know the next server

1556
01:11:46,479 --> 01:11:49,100
they're gonna need to make sure server 1

1557
01:11:49,300 --> 01:11:54,619
well first of all if server 3 crashes or

1558
01:11:54,819 --> 01:11:55,940
we'll be at an election and some of the

1559
01:11:56,140 --> 01:11:57,590
leader is chosen you know two things

1560
01:11:57,789 --> 01:11:59,960
have to happen the new leader has got to

1561
01:12:00,159 --> 01:12:04,789
recognize that this command could have

1562
01:12:04,989 --> 01:12:06,710
committed it's not allowed to throw it

1563
01:12:06,909 --> 01:12:07,550
away

1564
01:12:07,750 --> 01:12:09,739
and it needs to make sure server one

1565
01:12:09,939 --> 01:12:11,869
fills in this blank here with indeed

1566
01:12:12,069 --> 01:12:13,400
this very same command that everybody

1567
01:12:13,600 --> 01:12:17,750
else had in that slot all right so after

1568
01:12:17,949 --> 01:12:20,239
a crash somebody you know server 3

1569
01:12:20,439 --> 01:12:22,220
suppose another way this can come up is

1570
01:12:22,420 --> 01:12:23,960
server 3 might have sent out the append

1571
01:12:24,159 --> 01:12:25,940
entries the server 2 but then crashed

1572
01:12:26,140 --> 01:12:27,500
before sending the append entries to

1573
01:12:27,699 --> 01:12:30,199
server 3 so if were you know electing a

1574
01:12:30,399 --> 01:12:32,210
new leader it could because we got a

1575
01:12:32,409 --> 01:12:34,329
crash before the message was sent

1576
01:12:34,529 --> 01:12:36,880
here's another scenario to think about

1577
01:12:37,079 --> 01:12:44,630
three servers again no I mean a number

1578
01:12:44,829 --> 01:12:47,989
the slots in the law and so we can refer

1579
01:12:48,189 --> 01:12:55,559
to them got slot 10 11 12 13

1580
01:12:55,729 --> 01:12:56,949
[Music]

1581
01:12:57,149 --> 01:13:04,159
again it's same setup except now we have

1582
01:13:04,359 --> 01:13:07,579
in slide 12 we have server 2 as a

1583
01:13:07,779 --> 01:13:10,970
command from term for and server 3 has a

1584
01:13:11,170 --> 01:13:14,730
term command from term 5

1585
01:13:15,789 --> 01:13:19,409
so you know before we analyze these to

1586
01:13:19,609 --> 01:13:21,270
figure out what would happen and what

1587
01:13:21,470 --> 01:13:22,770
would a server do if it saw this we need

1588
01:13:22,970 --> 01:13:24,779
to ask could this even occur because

1589
01:13:24,979 --> 01:13:26,850
sometimes the answer to the question oh

1590
01:13:27,050 --> 01:13:28,320
jeez what would happen if this

1591
01:13:28,520 --> 01:13:30,420
configuration arose sometimes the answer

1592
01:13:30,619 --> 01:13:32,699
is it cannot arise so we do not have to

1593
01:13:32,899 --> 01:13:36,930
worry about it the question is could

1594
01:13:37,130 --> 01:13:39,940
this arise and how

1595
01:13:57,899 --> 01:14:02,989
all right so any

1596
01:14:12,819 --> 01:14:15,909
[Music]

1597
01:14:52,658 --> 01:14:55,658
yeah

1598
01:14:59,060 --> 01:15:02,230
in brief we know this configuration can

1599
01:15:02,430 --> 01:15:05,470
arise and so the way we can then get the

1600
01:15:05,670 --> 01:15:07,329
four and a five here is let's suppose in

1601
01:15:07,529 --> 01:15:08,710
the next leader election server twos

1602
01:15:08,909 --> 01:15:11,500
elected leader now for term for its

1603
01:15:11,699 --> 01:15:13,239
elected leader because a request from a

1604
01:15:13,439 --> 01:15:15,699
client it appends it to its own log and

1605
01:15:15,899 --> 01:15:19,840
crashes so now we have this right we

1606
01:15:20,039 --> 01:15:21,279
need a new election because the leader

1607
01:15:21,479 --> 01:15:25,210
just crashed now in this election and

1608
01:15:25,409 --> 01:15:27,310
then so now we have to ask whether who

1609
01:15:27,510 --> 01:15:29,170
could be elected or we have to give him

1610
01:15:29,369 --> 01:15:30,520
back of our heads oh gosh what could be

1611
01:15:30,720 --> 01:15:32,529
elected so we're gonna claim server

1612
01:15:32,729 --> 01:15:34,270
three could be elected the reason why I

1613
01:15:34,470 --> 01:15:35,560
could be elected is because it only

1614
01:15:35,760 --> 01:15:37,930
needs request vote responses from

1615
01:15:38,130 --> 01:15:40,300
majority that majority is server one and

1616
01:15:40,500 --> 01:15:42,579
server three you know there's no no

1617
01:15:42,779 --> 01:15:44,170
problem no conflict between these two

1618
01:15:44,369 --> 01:15:46,360
logs so server three can be elected for

1619
01:15:46,560 --> 01:15:48,570
term five get a request from a client

1620
01:15:48,770 --> 01:15:51,610
append it to its own log and crash and

1621
01:15:51,810 --> 01:15:53,980
that's how you get this this

1622
01:15:54,180 --> 01:15:56,949
configuration so you know you need to be

1623
01:15:57,149 --> 01:16:03,940
able to to work through these things in

1624
01:16:04,140 --> 01:16:05,590
order to get to the stage of saying yes

1625
01:16:05,789 --> 01:16:06,940
this could happen and therefore raft

1626
01:16:07,140 --> 01:16:09,190
must do something sensible as opposed to

1627
01:16:09,390 --> 01:16:11,110
it cannot happen because some things

1628
01:16:11,310 --> 01:16:13,730
can't happen

1629
01:16:17,538 --> 01:16:23,729
all right so so what can happen now we

1630
01:16:23,929 --> 01:16:26,850
know this can occur so hopefully we can

1631
01:16:27,050 --> 01:16:28,909
convince ourselves that raft actually

1632
01:16:29,109 --> 01:16:34,350
does something sensible now as for the

1633
01:16:34,550 --> 01:16:36,569
range of things before we talk about

1634
01:16:36,769 --> 01:16:39,659
what RAF would actually would actually

1635
01:16:39,859 --> 01:16:43,409
do we need to have some sense of what

1636
01:16:43,609 --> 01:16:48,288
would be an acceptable outcome right and

1637
01:16:48,488 --> 01:16:53,248
just eyeballing this we know that the

1638
01:16:53,448 --> 01:16:54,989
command in slot 10 since it's known by

1639
01:16:55,189 --> 01:16:58,829
all all the replicas it could have been

1640
01:16:59,029 --> 01:17:01,409
committed so we cannot throw it away

1641
01:17:01,609 --> 01:17:03,869
similarly the command in slot 11 since

1642
01:17:04,069 --> 01:17:05,458
it's in a majority of the replicas it

1643
01:17:05,658 --> 01:17:06,748
could for all we know have been

1644
01:17:06,948 --> 01:17:09,180
committed so we can't throw it away the

1645
01:17:09,380 --> 01:17:11,100
command in slot 12 however neither of

1646
01:17:11,300 --> 01:17:12,989
them could possibly have been committed

1647
01:17:13,189 --> 01:17:15,949
so we're entitled we don't know haven't

1648
01:17:16,149 --> 01:17:18,538
we'll actually do but raft is entitled

1649
01:17:18,738 --> 01:17:21,479
to drop both of these even though it is

1650
01:17:21,679 --> 01:17:23,279
not entitled to drop it and either of

1651
01:17:23,479 --> 01:17:26,689
the commands in a 10 or 11

1652
01:17:26,889 --> 01:17:28,649
this is entitled dropped it's not

1653
01:17:28,849 --> 01:17:31,378
required to drop either one of them but

1654
01:17:31,578 --> 01:17:33,180
I mean oh it certainly must drop one at

1655
01:17:33,380 --> 01:17:35,128
least one because you have to have

1656
01:17:35,328 --> 01:17:39,639
identical log contents in the end

1657
01:17:43,289 --> 01:17:47,360
this could have been committed it the we

1658
01:17:47,560 --> 01:17:49,900
can't tell by looking at the laws

1659
01:17:50,100 --> 01:17:52,130
exactly how far the leader got before

1660
01:17:52,329 --> 01:17:55,310
crashing so one possibility is that for

1661
01:17:55,510 --> 01:17:58,940
this command or even this command one

1662
01:17:59,140 --> 01:18:00,590
possibility is that leaders send out the

1663
01:18:00,789 --> 01:18:02,630
append messages with a new command and

1664
01:18:02,829 --> 01:18:05,420
then immediately crashed so it never got

1665
01:18:05,619 --> 01:18:07,909
any response back because it crashed so

1666
01:18:08,109 --> 01:18:09,440
the old leader did not know if it was

1667
01:18:09,640 --> 01:18:12,140
committed and if it didn't get a

1668
01:18:12,340 --> 01:18:14,210
response back that means it didn't

1669
01:18:14,409 --> 01:18:17,390
execute it and it didn't send out but

1670
01:18:17,590 --> 01:18:18,739
you know it didn't send out that

1671
01:18:18,939 --> 01:18:22,038
incremented commit index and so maybe

1672
01:18:22,238 --> 01:18:24,409
the replicas didn't execute it either so

1673
01:18:24,609 --> 01:18:26,748
it's actually possible that this wasn't

1674
01:18:26,948 --> 01:18:29,779
committed so even though RAF doesn't

1675
01:18:29,979 --> 01:18:35,409
know it could be legal for raft

1676
01:18:35,609 --> 01:18:40,579
if raft knew more than it does know it

1677
01:18:40,779 --> 01:18:43,400
might be legal to drop this log entry

1678
01:18:43,600 --> 01:18:44,840
because it might not have been committed

1679
01:18:45,039 --> 01:18:48,110
but because on the evidence there's no

1680
01:18:48,310 --> 01:18:50,810
way to disprove it was committed based

1681
01:18:51,010 --> 01:18:52,788
on this evidence it could have been

1682
01:18:52,988 --> 01:18:55,100
committed and raft can't prove it wasn't

1683
01:18:55,300 --> 01:18:58,248
so it must treat it as committed because

1684
01:18:58,448 --> 01:19:00,860
the leader might have received it might

1685
01:19:01,060 --> 01:19:03,110
have crashed just after receiving the

1686
01:19:03,310 --> 01:19:05,420
append entry replies and replying to the

1687
01:19:05,619 --> 01:19:08,060
client so just looking at this we can't

1688
01:19:08,260 --> 01:19:10,400
rule out the possibility that either

1689
01:19:10,600 --> 01:19:13,940
possibility that the leader responded to

1690
01:19:14,140 --> 01:19:15,590
the client in which case we cannot throw

1691
01:19:15,789 --> 01:19:17,029
away this entry because a client knows

1692
01:19:17,229 --> 01:19:18,769
about it or the possibility the leader

1693
01:19:18,969 --> 01:19:22,880
never did and yeah we could you know if

1694
01:19:23,079 --> 01:19:26,670
we have to assume that it was committed

1695
01:19:33,390 --> 01:19:36,390
yeah

1696
01:19:46,488 --> 01:19:51,390
no there's no mañana server crash before

1697
01:19:51,590 --> 01:19:53,430
getting the response it's alright well

1698
01:19:53,630 --> 01:19:58,630
let's continue this on Thursday

