WEBVTT

1
00:00:02.649 --> 00:00:07.219
all right today I want to talk about bit

2
00:00:07.219 --> 00:00:08.509
more about fault tolerance and

3
00:00:08.509 --> 00:00:10.550
replication and then look into the

4
00:00:10.550 --> 00:00:13.269
details of today's paper about vmware ft

5
00:00:20.600 --> 00:00:22.820
hardware you know computer crashes is

6
00:00:27.859 --> 00:00:29.120
can we'd like to provide our service

7
00:00:29.120 --> 00:00:31.250
also if there's network problems and the

8
00:00:52.509 --> 00:00:55.609
so maybe the easiest way to characterize

9
00:00:55.609 --> 00:00:57.170
the kind of failures we're talking about

10
00:01:11.120 --> 00:01:14.840
it's a sort of generic term and fault

11
00:01:14.840 --> 00:01:16.760
tolerance is that if something goes

12
00:01:16.760 --> 00:01:18.349
wrong would say the computer the

13
00:01:18.349 --> 00:01:23.840
computer simply stops executing it just

14
00:01:23.840 --> 00:01:27.650
stops if anything goes wrong and in

15
00:01:27.650 --> 00:01:29.239
particular it doesn't compute incorrect

16
00:01:29.239 --> 00:01:31.640
results so if somebody kicks the power

17
00:01:31.640 --> 00:01:35.239
cable out of your server that's probably

18
00:01:35.239 --> 00:01:36.950
gonna generate a fail stop failure

19
00:01:42.680 --> 00:01:44.390
server is still running so this is a

20
00:01:47.420 --> 00:01:50.480
outside like it just stopped so it's

21
00:01:50.480 --> 00:01:51.890
really these failures we can deal with

22
00:01:51.890 --> 00:01:55.810
with replication this also covers some

23
00:01:55.810 --> 00:01:59.480
hardware problems like you know maybe if

24
00:01:59.480 --> 00:02:02.299
the fan on your server breaks because it

25
00:02:02.299 --> 00:02:04.909
you know it cost 50 cents maybe that'll

26
00:02:04.909 --> 00:02:06.739
cause the CPU to overheat and the CPU

27
00:02:18.469 --> 00:02:20.500
replication systems we're talking about

28
00:02:20.500 --> 00:02:24.110
is things like bugs and software or

29
00:02:24.110 --> 00:02:29.360
design defects in hardware so basically

30
00:02:29.360 --> 00:02:33.379
not bugs because if we take some service

31
00:02:33.379 --> 00:02:35.659
you know say you're a MapReduce master

32
00:02:35.659 --> 00:02:37.460
for example you know we replicated and

33
00:02:37.460 --> 00:02:39.530
run it on two computers you know if

34
00:02:39.530 --> 00:02:41.180
there's a bug in your MapReduce master

35
00:02:41.180 --> 00:02:43.539
or my MapReduce master let's say

36
00:02:43.539 --> 00:02:45.379
replications not going to help us we're

37
00:02:45.379 --> 00:02:46.759
going to compute the same incorrect

38
00:02:46.759 --> 00:02:50.169
result on both of our copies of our

39
00:02:50.169 --> 00:02:53.960
MapReduce master and everything looked

40
00:02:53.960 --> 00:02:55.669
fine they'll agree you just happen to be

41
00:02:55.669 --> 00:02:58.370
the wrong answer so we can't depending

42
00:02:58.370 --> 00:03:01.129
against bugs in the replicated software

43
00:03:01.129 --> 00:03:02.780
and we can't defend against bugs in the

44
00:03:02.780 --> 00:03:05.270
whatever scheme we're using to manage

45
00:03:05.270 --> 00:03:08.180
the replication and similarly as I

46
00:03:08.180 --> 00:03:12.740
mentioned before we can't expect to deal

47
00:03:12.740 --> 00:03:14.180
with bugs in the hardware the hardware

48
00:03:14.180 --> 00:03:15.949
it computes incorrectly that's just

49
00:03:15.949 --> 00:03:18.530
that's the end for us at least with this

50
00:03:18.530 --> 00:03:21.830
kind of technique although you know that

51
00:03:21.830 --> 00:03:23.930
said there are definitely hardware and

52
00:03:23.930 --> 00:03:26.539
software bugs that that replication

53
00:03:26.539 --> 00:03:28.699
might if you're lucky might be able to

54
00:03:28.699 --> 00:03:30.469
cope it so if there's some unrelated

55
00:03:30.469 --> 00:03:32.240
software running in your server and it

56
00:03:32.240 --> 00:03:34.430
causes the server to crash maybe because

57
00:03:34.430 --> 00:03:36.620
your kernel to panic and reboot or

58
00:03:36.620 --> 00:03:38.449
something it has nothing to do with you

59
00:03:38.449 --> 00:03:40.639
know with your with the service you're

60
00:03:40.639 --> 00:03:42.710
replicating then that kind of failure

61
00:03:42.710 --> 00:03:45.650
for us for your service will may well be

62
00:03:45.650 --> 00:03:47.289
fail stop

63
00:03:47.289 --> 00:03:50.810
you know the kernel will panic and the

64
00:03:50.810 --> 00:03:56.479
backup replicas will take over similarly

65
00:04:03.259 --> 00:04:05.599
if you send a packet over the network

66
00:04:05.599 --> 00:04:08.210
and the network corrupts it just flips a

67
00:04:11.930 --> 00:04:13.939
the packet same thing for a disk block

68
00:04:13.939 --> 00:04:15.949
if you write some data to disk and read

69
00:04:15.949 --> 00:04:18.199
it back a month later you know maybe the

70
00:04:18.199 --> 00:04:20.779
magnetic surface isn't perfect and you

71
00:04:23.540 --> 00:04:24.980
it's actually error correcting

72
00:04:24.980 --> 00:04:26.990
that up to a certain point will fix

73
00:04:26.990 --> 00:04:28.459
errors in disk blocks that you'll be

74
00:04:28.459 --> 00:04:31.420
turning you know random hardware errors

75
00:04:31.420 --> 00:04:35.600
into as either correcting them if you're

76
00:04:35.600 --> 00:04:39.139
super lucky or at least detecting them

77
00:04:39.139 --> 00:04:40.910
and turning random corruption into a

78
00:04:40.910 --> 00:04:43.730
detected fault which you know the

79
00:04:43.730 --> 00:04:45.470
software then knows that something that

80
00:04:45.470 --> 00:04:47.689
wrong and can turn it into a fail stop

81
00:04:47.689 --> 00:04:49.910
fault by stopping executing or take some

82
00:04:49.910 --> 00:04:55.189
other remedial action but in general we

83
00:04:55.189 --> 00:04:57.560
really can only expect to handle fail

84
00:04:57.560 --> 00:05:02.180
stop faults there's other limits to

85
00:05:02.180 --> 00:05:06.470
replication to you know the the failures

86
00:05:06.470 --> 00:05:08.629
in the if we have a primary in the back

87
00:05:08.629 --> 00:05:10.610
of our two replicas or whatever we're

88
00:05:10.610 --> 00:05:12.800
really assuming that failures in the two

89
00:05:12.800 --> 00:05:16.160
are independent right if there tend to

90
00:05:16.160 --> 00:05:18.310
have correlated failures then

91
00:05:18.310 --> 00:05:20.389
replication is not going to help us so

92
00:05:20.389 --> 00:05:22.339
for example if we're a big outfit and we

93
00:05:22.339 --> 00:05:24.379
buy thousands of computers batches of

94
00:05:24.379 --> 00:05:26.389
thousands of computers identical

95
00:05:26.389 --> 00:05:28.310
computers from the same manufacturer and

96
00:05:33.649 --> 00:05:35.509
time from the same place that's a bit of

97
00:05:35.509 --> 00:05:35.990
a risk

98
00:05:40.730 --> 00:05:43.129
a good chance that the other ones do too

99
00:05:43.129 --> 00:05:44.389
you know one of them's prone to

100
00:05:44.389 --> 00:05:47.810
overheating because the manufacturer you

101
00:05:47.810 --> 00:05:49.220
know didn't provide enough airflow well

102
00:05:49.220 --> 00:05:51.500
it probably all had that problem and so

103
00:05:51.500 --> 00:05:53.990
one of them overheats and dies it's a

104
00:05:53.990 --> 00:05:56.350
good chance that the other ones will too

105
00:06:02.569 --> 00:06:03.889
earthquake and the city where our

106
00:06:03.889 --> 00:06:05.509
datacenter is probably gonna take out

107
00:06:05.509 --> 00:06:07.310
the whole data center you know we can

108
00:06:07.310 --> 00:06:08.629
have all the replication we like inside

109
00:06:15.949 --> 00:06:17.720
is like it's correlated failure between

110
00:06:17.720 --> 00:06:19.490
our replicas if they're on that building

111
00:06:19.490 --> 00:06:21.290
so if we care about dealing with

112
00:06:29.720 --> 00:06:31.759
unlikely to be affected by the same

113
00:06:31.759 --> 00:06:34.750
natural disaster

114
00:06:35.139 --> 00:06:37.790
okay but that's all sort of hovering in

115
00:06:37.790 --> 00:06:39.170
the background for this discussion where

116
00:06:39.170 --> 00:06:41.509
we're talking about the technology you

117
00:06:41.509 --> 00:06:44.660
might use another question about

118
00:06:44.660 --> 00:06:46.639
replication is whether it's worthwhile

119
00:06:46.639 --> 00:06:49.519
you may ask yourself gosh you know this

120
00:06:49.519 --> 00:06:51.759
literally uses these replication schemes

121
00:06:51.759 --> 00:06:55.189
use twice as much or three times as much

122
00:06:55.189 --> 00:06:57.740
computer resources right we need to have

123
00:06:57.740 --> 00:06:59.480
you know GFS had three copies of every

124
00:06:59.480 --> 00:07:01.129
blocks we have to buy three times as much

125
00:07:01.129 --> 00:07:03.589
disk space the paper for today

126
00:07:03.589 --> 00:07:05.870
you know replicates just once but that

127
00:07:05.870 --> 00:07:07.759
means we have twice as many computers

128
00:07:07.759 --> 00:07:10.519
and CPUs and RAM it's all for expensive

129
00:07:10.519 --> 00:07:11.990
like is that really worth it that

130
00:07:21.139 --> 00:07:22.939
available service you know if you're

131
00:07:27.740 --> 00:07:29.300
customer you can't serve your customers

132
00:07:29.300 --> 00:07:31.220
and you can't generate revenue and your

133
00:07:31.220 --> 00:07:33.439
customers all hate you then it may well

134
00:07:33.439 --> 00:07:35.540
be worth it to blow you know an extra

135
00:07:35.540 --> 00:07:37.370
ten or twenty thousand bucks on a second

136
00:07:37.370 --> 00:07:40.220
computer so you can have a replica on

137
00:07:40.220 --> 00:07:41.899
the other hand if you're me and you're

138
00:07:41.899 --> 00:07:46.220
running the 6.824 web server I don't

139
00:07:46.220 --> 00:07:48.680
consider it worthwhile to have a hot

140
00:07:48.680 --> 00:07:50.959
backup of the 84 web server because the

141
00:07:50.959 --> 00:07:55.339
consequences of failure are very low so

142
00:07:55.339 --> 00:07:58.459
the whether the replication is

143
00:07:58.459 --> 00:08:00.230
worthwhile on how many replicas you

144
00:08:04.220 --> 00:08:08.329
much cost and inconvenience failure

145
00:08:08.329 --> 00:08:11.839
would call it cause you all right this

146
00:08:11.839 --> 00:08:14.810
paper sort of in the beginning mentions

147
00:08:14.810 --> 00:08:16.269
as there's a couple of different

148
00:08:16.269 --> 00:08:19.819
approaches to replication really

149
00:08:19.819 --> 00:08:21.740
mentions two one two calls state

150
00:08:21.740 --> 00:08:30.350
transfer and the other calls replicated

151
00:08:30.350 --> 00:08:35.149
state machine most of the schemes we're

152
00:08:35.149 --> 00:08:36.230
going to talk about in this class are

153
00:08:36.230 --> 00:08:39.279
replicated state machines

154
00:08:39.789 --> 00:08:42.799
it'll talk about both anyway the idea

155
00:08:42.799 --> 00:08:44.179
behind state transferor's that if we

156
00:08:44.179 --> 00:08:49.100
have two replicas of a server the way

157
00:08:49.100 --> 00:08:51.470
you cause them to be to stay in sync

158
00:08:57.529 --> 00:08:59.629
to take over if the primary fails in a

159
00:08:59.629 --> 00:09:02.389
state transfer scheme the way that works

160
00:09:02.389 --> 00:09:04.490
is that the primary sends a copy of its

161
00:09:04.490 --> 00:09:06.320
entire state that is for example the

162
00:09:06.320 --> 00:09:09.139
contents of its RAM to the backup and

163
00:09:09.139 --> 00:09:11.210
the backup just sort of stores the

164
00:09:11.210 --> 00:09:13.279
latest state and so it's all there

165
00:09:13.279 --> 00:09:15.470
the primary fails in the backup can

166
00:09:15.470 --> 00:09:18.679
start executing with this last state it

167
00:09:18.679 --> 00:09:20.899
got if the primary fails so this is all

168
00:09:20.899 --> 00:09:23.750
about sending the state of the of the

169
00:09:23.750 --> 00:09:26.450
primary and for today's if today's paper

170
00:09:26.450 --> 00:09:28.250
worked as a state transfer system which

171
00:09:28.250 --> 00:09:29.899
it doesn't then the state we'd be

172
00:09:29.899 --> 00:09:31.340
talking about would be the contents of

173
00:09:31.340 --> 00:09:33.320
the RAM the contents of the memory of

174
00:09:33.320 --> 00:09:35.960
the primary so maybe every once while

175
00:09:35.960 --> 00:09:38.389
the primary would just you know make a

176
00:09:38.389 --> 00:09:39.889
big copy of its memory and send it

177
00:09:39.889 --> 00:09:41.600
across the network to the backup you can

178
00:09:41.600 --> 00:09:42.860
imagine if you wanted to be efficient

179
00:09:51.710 --> 00:09:52.940
machine

180
00:09:52.940 --> 00:09:55.850
this approach observes that most

181
00:09:55.850 --> 00:09:57.559
services are most computer things we

182
00:09:57.559 --> 00:10:00.590
want to replicate have some internal

183
00:10:00.590 --> 00:10:05.330
operation that's deterministic except

184
00:10:05.330 --> 00:10:08.840
when external input comes in right you

185
00:10:08.840 --> 00:10:10.879
know ordinarily if there's no external

186
00:10:10.879 --> 00:10:12.769
influences on a computer it just

187
00:10:12.769 --> 00:10:14.330
executes one instruction after another

188
00:10:18.769 --> 00:10:20.389
memory and the registers of the computer

189
00:10:20.389 --> 00:10:22.399
and it's only when external events

190
00:10:22.399 --> 00:10:25.190
intervene that something unexpected may

191
00:10:25.190 --> 00:10:27.440
happen like a packet arrives of a some

192
00:10:27.440 --> 00:10:31.549
random time and that causes the server

193
00:10:31.549 --> 00:10:33.799
to start doing something differently I'm

194
00:10:33.799 --> 00:10:36.409
so replicated state machine schemes

195
00:10:36.409 --> 00:10:39.259
don't send the state between the

196
00:10:45.500 --> 00:10:47.840
from a primary to a backup again just

197
00:10:47.840 --> 00:10:50.419
send things like arriving input from the

198
00:10:50.419 --> 00:10:52.549
outside world that the backup needs to

199
00:10:52.549 --> 00:10:52.909
know

200
00:10:52.909 --> 00:10:55.370
and the observation is that you know if

201
00:11:00.110 --> 00:11:03.740
same inputs that that in the same order

202
00:11:03.740 --> 00:11:05.809
or at the same time the two computers

203
00:11:05.809 --> 00:11:08.149
will continue to be replicas of each

204
00:11:08.149 --> 00:11:10.490
other and sort of execute identically as

205
00:11:17.360 --> 00:11:21.379
memory and this transfer some primary

206
00:11:21.379 --> 00:11:25.669
backup just operations from clients or

207
00:11:25.669 --> 00:11:27.889
external external inputs or external

208
00:11:27.889 --> 00:11:33.230
events and you know the reason why

209
00:11:33.230 --> 00:11:35.809
people tend to favor a replicated state

210
00:11:35.809 --> 00:11:39.350
machine is that usually operations are

211
00:11:39.350 --> 00:11:41.629
smaller than the state but this you know

212
00:11:41.629 --> 00:11:43.129
the state of a server if it's a database

213
00:11:43.129 --> 00:11:44.629
server might be the entire database

214
00:11:48.679 --> 00:11:51.110
and you know please read or write key 27

215
00:11:51.110 --> 00:11:53.690
operations are usually small the states

216
00:11:53.690 --> 00:11:55.190
usually large so replicate a state

217
00:11:55.190 --> 00:11:57.470
machine usually looks attractive and

218
00:12:01.490 --> 00:12:05.899
rely on sort of more assumptions about

219
00:12:05.899 --> 00:12:08.929
how the computers operate whereas this

220
00:12:08.929 --> 00:12:10.639
is a really heavy-handed I'm just gonna

221
00:12:10.639 --> 00:12:12.379
send you my whole state sort of a

222
00:12:12.379 --> 00:12:14.440
nothing to worry about

223
00:12:14.440 --> 00:12:22.179
any questions about these strategies yes

224
00:12:27.649 --> 00:12:30.929
well the did ok so the question is

225
00:12:30.929 --> 00:12:32.759
suppose something went wrong with our

226
00:12:32.759 --> 00:12:34.409
scheme and the backup was not actually

227
00:12:34.409 --> 00:12:40.580
identical to the primary so you know

228
00:12:40.580 --> 00:12:44.789
you're suppose we were running GFS

229
00:12:44.789 --> 00:12:47.220
master and it's the primary it just

230
00:12:47.220 --> 00:12:49.950
handed out at least two chunks server

231
00:12:56.909 --> 00:12:59.909
back to drift out of sync the backup did

232
00:12:59.909 --> 00:13:01.470
not issue at least to anybody it wasn't

233
00:13:01.470 --> 00:13:02.850
even away or anybody had asked for these

234
00:13:02.850 --> 00:13:04.379
so now the primary thinks you know

235
00:13:04.379 --> 00:13:05.879
chunks everyone has lease for some chunk

236
00:13:05.879 --> 00:13:08.600
in the backup doesn't the primary fails

237
00:13:08.600 --> 00:13:11.250
backup takes over right now chunks over

238
00:13:11.250 --> 00:13:13.620
one thinks it has a lease for some chunk

239
00:13:13.620 --> 00:13:17.850
but then the current master doesn't and

240
00:13:17.850 --> 00:13:19.440
is happy to hand out the lease to some

241
00:13:19.440 --> 00:13:20.879
other trunk server now we have to chunk

242
00:13:20.879 --> 00:13:23.250
servers serving the same lease okay so

243
00:13:23.250 --> 00:13:25.230
that's just a close to home example but

244
00:13:30.230 --> 00:13:32.879
scenario by just imagining some service

245
00:13:32.879 --> 00:13:35.580
that confuse the wrong answer because

246
00:13:35.580 --> 00:13:38.480
the state's leverage

247
00:13:42.740 --> 00:13:46.610
so you're asking about randomization

248
00:13:50.600 --> 00:13:53.850
yeah oh y'all talk about this I'll talk

249
00:13:53.850 --> 00:13:55.950
about this a bit later on but it is good

250
00:13:55.950 --> 00:13:58.320
that the replicated state scheme

251
00:13:58.320 --> 00:14:02.879
definitely makes the most sense when the

252
00:14:02.879 --> 00:14:04.320
instructions that the primary in the

253
00:14:04.320 --> 00:14:06.570
back of our executing do the same thing

254
00:14:06.570 --> 00:14:08.370
as long as there's no external events

255
00:14:08.370 --> 00:14:10.740
right and that's almost true right you

256
00:14:10.740 --> 00:14:12.480
know for an add instruction or something

257
00:14:12.480 --> 00:14:14.879
yeah you know if the starting if the

258
00:14:14.879 --> 00:14:16.350
registers and memory of the same and they

259
00:14:16.350 --> 00:14:17.789
both execute an add instruction add instruction

260
00:14:20.730 --> 00:14:22.200
instructions as you point out that don't

261
00:14:22.200 --> 00:14:23.879
like maybe there's an instruction that

262
00:14:23.879 --> 00:14:26.399
gets the current time of day now

263
00:14:26.399 --> 00:14:27.690
probably be executed at slightly

264
00:14:27.690 --> 00:14:29.789
different times or an instruction that

265
00:14:29.789 --> 00:14:32.250
gets the current processors unique ID

266
00:14:32.250 --> 00:14:34.830
and a serial number it's going to yield

267
00:14:34.830 --> 00:14:38.399
the different answers and the the the

268
00:14:38.399 --> 00:14:39.929
uniform answered the questions that

269
00:14:39.929 --> 00:14:42.360
sound like this is that the primary does

270
00:14:42.360 --> 00:14:44.730
it and sends the answer to the backup

271
00:14:44.730 --> 00:14:46.830
and the backup does not execute that

272
00:14:46.830 --> 00:14:48.899
instruction but instead at the point

273
00:14:48.899 --> 00:14:50.120
where it would execute that instruction

274
00:14:50.120 --> 00:14:52.740
it listens for the primary to tell it

275
00:14:56.669 --> 00:15:00.809
software I'll talk about you know how

276
00:15:00.809 --> 00:15:04.549
the VMware scheme does that okay

277
00:15:04.549 --> 00:15:06.690
interestingly enough though today's

278
00:15:06.690 --> 00:15:09.809
paper is all about a replicated state

279
00:15:09.809 --> 00:15:12.149
machine you may have noticed that

280
00:15:12.149 --> 00:15:13.679
today's paper only deals with you know

281
00:15:13.679 --> 00:15:15.330
processors and it's not that clear how

282
00:15:15.330 --> 00:15:18.679
it could be extended to a multi-core and

283
00:15:18.679 --> 00:15:21.809
a multi-core machine where the

284
00:15:21.809 --> 00:15:23.549
interleavings of the instructions from

285
00:15:23.549 --> 00:15:24.750
the two cores organ are

286
00:15:24.750 --> 00:15:26.610
non-deterministic all right so we no

287
00:15:26.610 --> 00:15:27.720
longer have this situation on a

288
00:15:27.720 --> 00:15:29.669
multi-core machine where if we just let

289
00:15:29.669 --> 00:15:31.200
the primary and backup execute they're

290
00:15:31.200 --> 00:15:32.970
you know all else being equal they're

291
00:15:32.970 --> 00:15:34.669
going to be the same because they won't

292
00:15:34.669 --> 00:15:37.529
execute on multiple cores VMware has

293
00:15:37.529 --> 00:15:39.600
since come out with a new possibly

294
00:15:39.600 --> 00:15:42.240
completely different replication system

295
00:15:46.889 --> 00:15:49.529
transfer instead of replicated state

296
00:15:49.529 --> 00:15:50.940
machine because state transferred is

297
00:15:50.940 --> 00:15:53.190
more robust in the face

298
00:15:53.190 --> 00:15:56.340
multi-core and parallelism if you use

299
00:15:56.340 --> 00:15:58.379
the machine and send the memory over you

300
00:15:58.379 --> 00:16:00.690
know that the memory image is just that

301
00:16:00.690 --> 00:16:02.250
just is the state of the machine and

302
00:16:02.250 --> 00:16:04.470
sort of it doesn't matter that there was

303
00:16:04.470 --> 00:16:06.600
parallelism whereas the replicated state

304
00:16:06.600 --> 00:16:08.279
machine scheme really has a problem with

305
00:16:08.279 --> 00:16:12.779
the parallelism you know on the other

306
00:16:21.200 --> 00:16:24.659
all right so if we want to build a

307
00:16:24.659 --> 00:16:26.250
replicated state machine scheme we got a

308
00:16:26.250 --> 00:16:31.200
number of questions to answer so we need

309
00:16:31.200 --> 00:16:32.429
to decide at what level we're gonna

310
00:16:32.429 --> 00:16:36.360
replicate state right so what state what

311
00:16:36.360 --> 00:16:44.429
do we mean by state we have to worry

312
00:16:44.429 --> 00:16:47.669
about how how closely synchronized the

313
00:16:47.669 --> 00:16:49.710
primary and backup have to be right

314
00:16:49.710 --> 00:16:51.809
because it's likely the primary will

315
00:16:51.809 --> 00:16:53.399
execute a little bit ahead of the backup

316
00:16:53.399 --> 00:16:55.110
after all it it's the primary that sees

317
00:16:55.110 --> 00:16:57.570
the inputs so the backup almost

318
00:16:57.570 --> 00:17:00.360
necessarily must lag over that gives

319
00:17:00.360 --> 00:17:01.950
that means there's an opportunity if the

320
00:17:01.950 --> 00:17:04.500
primary fails for the prime for the

321
00:17:04.500 --> 00:17:08.849
backup not to be fully caught up having

322
00:17:08.849 --> 00:17:11.759
the backup actually executes really in

323
00:17:11.759 --> 00:17:12.960
lockstep with the primaries for

324
00:17:12.960 --> 00:17:14.549
expensive because it requires a lot of

325
00:17:14.549 --> 00:17:16.319
chitchat so a lot of designs a lot of

326
00:17:16.319 --> 00:17:19.470
what people sweat about is how close the

327
00:17:19.470 --> 00:17:27.809
synchronization is if the primary fails

328
00:17:27.809 --> 00:17:29.759
or you know actually if the backup fails too

329
00:17:29.960 --> 00:17:31.589
but it's more exciting if the primary

330
00:17:31.589 --> 00:17:33.210
fails there has to be some scheme for

331
00:17:33.210 --> 00:17:34.650
switching over and the clients have to

332
00:17:34.650 --> 00:17:37.829
know oh gosh I instead of talking to the

333
00:17:37.829 --> 00:17:39.779
old primary on server one I should now

334
00:17:39.779 --> 00:17:44.519
be talking to the

335
00:17:44.519 --> 00:17:47.970
the backup on server to all the clients

336
00:17:47.970 --> 00:17:50.279
have to somehow figure this out the

337
00:17:50.279 --> 00:17:53.339
switch over almost certainly it's almost

338
00:17:53.339 --> 00:17:55.859
impossible maybe impossible to design a

339
00:17:55.859 --> 00:17:58.559
cut over system in which no anomalies

340
00:17:58.559 --> 00:18:00.960
are every are ever visible you know in

341
00:18:10.920 --> 00:18:15.119
going to be anomalies during the cut

342
00:18:15.119 --> 00:18:16.500
over and we've gotta figure out a way to

343
00:18:16.500 --> 00:18:19.559
cope with them and finally if the one of

344
00:18:19.559 --> 00:18:21.750
the two if one of our replicas fails we

345
00:18:21.750 --> 00:18:23.789
really need to have a new replica right

346
00:18:23.789 --> 00:18:26.819
if we have a two replicas and one fails

347
00:18:31.710 --> 00:18:33.990
some point so we absolutely need to get

348
00:18:33.990 --> 00:18:36.240
a new replica back online as fast as

349
00:18:36.240 --> 00:18:41.250
possible so and that can be very

350
00:18:41.250 --> 00:18:44.609
expensive the state is big you know you

351
00:18:44.609 --> 00:18:45.690
know but the reason we like to replicate

352
00:18:45.690 --> 00:18:47.190
a state machine was because we thought

353
00:18:47.190 --> 00:18:49.319
state transfer would be expensive but

354
00:18:49.319 --> 00:18:51.450
the two replicas in a replicated state

355
00:18:55.230 --> 00:18:57.210
them both in sync if we need to create a

356
00:18:57.210 --> 00:18:59.700
new replica we actually have no choice

357
00:18:59.700 --> 00:19:01.410
but state transfer to create the new

358
00:19:15.299 --> 00:19:16.529
actually people spend a lot of time

359
00:19:16.529 --> 00:19:18.750
worrying about all these questions and

360
00:19:18.750 --> 00:19:20.490
you know we'll see them again as we look

361
00:19:20.490 --> 00:19:22.980
at other replicated state machine

362
00:19:22.980 --> 00:19:29.460
schemes so on the topic of what state to

363
00:19:29.460 --> 00:19:33.720
replicate the today's paper has a very

364
00:19:33.720 --> 00:19:35.880
interesting answer to this question it

365
00:19:35.880 --> 00:19:38.160
replicates the full state of the machine

366
00:19:48.779 --> 00:19:51.119
difference at the even of the lowest

367
00:19:51.119 --> 00:19:52.619
levels between the primary in the backup

368
00:19:52.619 --> 00:19:55.559
that's quite rare for replication

369
00:19:55.559 --> 00:19:56.670
schemes

370
00:19:56.670 --> 00:19:58.680
almost always you see something that's

371
00:19:58.680 --> 00:20:01.200
more like GFS where GFS absolutely did

372
00:20:01.200 --> 00:20:03.630
not replicate you know they had

373
00:20:03.630 --> 00:20:05.700
replication but it wasn't replicating

374
00:20:05.700 --> 00:20:08.220
every single you know bit of memory

375
00:20:08.220 --> 00:20:10.170
between the primaries and the backups

376
00:20:10.170 --> 00:20:12.180
it was replicating much more application

377
00:20:12.180 --> 00:20:14.910
level table of chunks

378
00:20:14.910 --> 00:20:16.950
I had this abstraction of you know

379
00:20:16.950 --> 00:20:18.630
chunks and chunk identifiers and that's

380
00:20:18.630 --> 00:20:20.369
what it was replicating it wasn't

381
00:20:20.369 --> 00:20:22.289
replicating sort of everything else

382
00:20:22.289 --> 00:20:24.569
wasn't going to the expense of

383
00:20:24.569 --> 00:20:26.430
replicating every single other thing

384
00:20:26.430 --> 00:20:28.440
that machines we're doing okay as long

385
00:20:28.440 --> 00:20:31.410
as they had the same sort of application

386
00:20:31.410 --> 00:20:37.410
visible set of of chunks so most

387
00:20:37.410 --> 00:20:40.529
replication schemes out there go the GFS

388
00:20:40.529 --> 00:20:42.750
route in fact almost everything except

389
00:20:42.750 --> 00:20:46.799
pretty much this paper and a few handful

390
00:20:46.799 --> 00:20:48.750
of similar systems almost everything

391
00:20:48.750 --> 00:20:50.220
uses application at some level

392
00:20:50.220 --> 00:20:53.730
application level of replication because

393
00:20:53.730 --> 00:20:56.940
it can be much more efficient because we

394
00:20:56.940 --> 00:20:58.559
don't have to go to the we don't have to

395
00:20:58.559 --> 00:21:00.960
go to the trouble of for example making

396
00:21:00.960 --> 00:21:02.789
sure that interrupts occur at exactly

397
00:21:02.789 --> 00:21:04.980
the same point in the execution of the

398
00:21:04.980 --> 00:21:07.259
primary and backup GFS does not sweat

399
00:21:07.259 --> 00:21:09.420
that at all but this paper has to do

400
00:21:09.420 --> 00:21:11.339
because it replicates at such a low

401
00:21:11.339 --> 00:21:14.519
level so most people build efficient

402
00:21:14.519 --> 00:21:16.559
systems with applications specific

403
00:21:16.559 --> 00:21:18.839
replication the consequence of that

404
00:21:18.839 --> 00:21:20.880
though is that the replication has to be

405
00:21:20.880 --> 00:21:21.900
built into the right into the

406
00:21:21.900 --> 00:21:23.579
application right if you're getting a

407
00:21:23.579 --> 00:21:26.789
feed of application level operations for

408
00:21:26.789 --> 00:21:28.950
example you really need to have the

409
00:21:33.720 --> 00:21:34.319
today's paper

410
00:21:34.319 --> 00:21:37.440
doesn't really can't understand the

411
00:21:37.440 --> 00:21:41.119
semantics of what needs to be replicated

412
00:21:41.240 --> 00:21:44.519
so anyways so most teams are application

413
00:21:44.519 --> 00:21:47.339
specific like GFS and every other paper

414
00:21:47.339 --> 00:21:49.309
we're going to read on this topic

415
00:21:49.309 --> 00:21:52.319
today's paper is unique in that it

416
00:21:52.319 --> 00:21:54.420
replicates at the level of the machine

417
00:21:54.420 --> 00:21:55.890
and therefore does not care what

418
00:21:55.890 --> 00:21:57.869
software you run on it right it

419
00:21:57.869 --> 00:22:00.450
replicates the low-level memory and

420
00:22:00.450 --> 00:22:01.920
machine registers you can run any

421
00:22:01.920 --> 00:22:03.599
software you like on it as long as it

422
00:22:03.599 --> 00:22:05.250
runs on that kind of microprocessor

423
00:22:05.250 --> 00:22:06.869
that's being represented this

424
00:22:06.869 --> 00:22:08.730
replication scheme applies to the

425
00:22:08.730 --> 00:22:10.400
software can be anything

426
00:22:16.400 --> 00:22:18.559
upside is that you can take any existing

427
00:22:27.440 --> 00:22:29.299
under VMware this replication scheme and

428
00:22:29.299 --> 00:22:33.940
it'll just work which is sort of magic

429
00:22:33.940 --> 00:22:36.890
fault-tolerance wand for arbitrary

430
00:22:36.890 --> 00:22:44.259
software all right now let me talk about

431
00:22:44.259 --> 00:22:51.230
how this is VMware FT first of all

432
00:22:56.960 --> 00:22:58.339
their business is selling virtual

433
00:22:58.339 --> 00:23:00.319
machine technology and what virtual

434
00:23:00.319 --> 00:23:04.279
machines refer to is the idea of you

435
00:23:04.279 --> 00:23:07.269
know you buy a single computer and

436
00:23:07.269 --> 00:23:09.289
instead of booting an operating system

437
00:23:09.289 --> 00:23:12.289
like Linux on the hardware you boot

438
00:23:12.289 --> 00:23:16.190
we'll call a virtual machine monitor or

439
00:23:16.190 --> 00:23:18.170
hypervisor on the hardware and the

440
00:23:18.170 --> 00:23:19.670
hypervisor is job is actually to

441
00:23:19.670 --> 00:23:24.430
simulate multiple multiple computers

442
00:23:24.430 --> 00:23:27.109
multiple virtual computers on this piece

443
00:23:27.109 --> 00:23:28.819
of hardware so the virtual machine

444
00:23:28.819 --> 00:23:31.220
monitor may boot up you know one

445
00:23:31.220 --> 00:23:34.579
instance of Linux may be multiple

446
00:23:34.579 --> 00:23:37.150
instances of Linux may be a Windows

447
00:23:37.150 --> 00:23:40.400
machine you can the virtual machine

448
00:23:40.400 --> 00:23:42.259
monitor on this one computer can run a

449
00:23:42.259 --> 00:23:45.470
bunch of different operating systems you

450
00:23:45.470 --> 00:23:49.400
know each of these as is itself some

451
00:23:49.400 --> 00:23:51.549
sort of operating system kernel and then

452
00:23:51.549 --> 00:23:55.910
applications so this is the technology

453
00:23:55.910 --> 00:23:58.700
they're starting with and you know the

454
00:23:58.700 --> 00:24:00.410
reason for this is that if you know you

455
00:24:04.759 --> 00:24:06.319
kind of interpose this level of

456
00:24:06.319 --> 00:24:08.420
indirection between the hardware and the

457
00:24:16.130 --> 00:24:18.140
little services instead of having to

458
00:24:18.140 --> 00:24:19.730
have lots and lots of computers one per

459
00:24:19.730 --> 00:24:21.680
service you can just buy one computer

460
00:24:21.680 --> 00:24:23.660
and run each service in the operating

461
00:24:23.660 --> 00:24:25.849
system that it needs I'm using this

462
00:24:25.849 --> 00:24:28.250
virtual machines so this was their

463
00:24:28.250 --> 00:24:29.299
starting point they already had this

464
00:24:29.299 --> 00:24:31.430
stuff and a lot of sophisticated things

465
00:24:46.910 --> 00:24:51.619
machine or they did requires two

466
00:24:51.619 --> 00:24:54.940
physical machines because there's no

467
00:24:54.940 --> 00:24:57.680
point in running the primary and backup

468
00:24:57.680 --> 00:24:59.720
software in different virtual machines

469
00:24:59.720 --> 00:25:01.400
on the same physical machine because

470
00:25:01.400 --> 00:25:03.500
we're trying to guard against hardware

471
00:25:03.500 --> 00:25:06.710
failures so you're gonna to at least you

472
00:25:06.710 --> 00:25:08.900
know you have two machines running their

473
00:25:08.900 --> 00:25:15.589
virtual machine monitors and the primary

474
00:25:15.589 --> 00:25:16.970
it's going to run on one the backups and

475
00:25:16.970 --> 00:25:18.950
the other so on one of these machines we

476
00:25:18.950 --> 00:25:23.750
have a guest you know we only it might

477
00:25:26.930 --> 00:25:28.670
be running some guest operating system

478
00:25:28.670 --> 00:25:32.329
and some sort of server application

479
00:25:32.329 --> 00:25:35.299
maybe a database server MapReduce master

480
00:25:35.299 --> 00:25:37.789
or something so I'll call this the

481
00:25:37.789 --> 00:25:40.250
primary and there'll be a second machine

482
00:25:40.250 --> 00:25:43.490
that you know runs the same virtual

483
00:25:43.490 --> 00:25:47.599
machine monitor and an identical virtual

484
00:25:47.599 --> 00:25:49.579
machine holding the backup so we have

485
00:25:49.579 --> 00:25:50.960
the same whatever the operating system

486
00:25:50.960 --> 00:25:55.250
is exactly the same and the virtual

487
00:25:55.250 --> 00:25:58.250
machine is you know giving these guest

488
00:25:58.250 --> 00:26:00.170
operating systems the primary and backup

489
00:26:00.170 --> 00:26:02.269
a each range of memory and this memory

490
00:26:02.269 --> 00:26:04.759
images will be identical or the goal is

491
00:26:04.759 --> 00:26:07.190
to make them identical in the primary in

492
00:26:07.190 --> 00:26:09.740
the backup we have two physical machines

493
00:26:15.680 --> 00:26:17.630
service we care about we're assuming

494
00:26:17.630 --> 00:26:22.640
that there's a network connecting these

495
00:26:22.640 --> 00:26:25.240
two machines and in addition on this

496
00:26:25.240 --> 00:26:27.529
local area network in addition on this

497
00:26:27.529 --> 00:26:29.480
network there's some set of clients

498
00:26:29.480 --> 00:26:30.950
really they don't have to be clients

499
00:26:30.950 --> 00:26:33.160
they're just maybe other computers that

500
00:26:33.160 --> 00:26:35.750
our replicated service needs to talk

501
00:26:35.750 --> 00:26:37.470
with some of them our clients

502
00:26:37.470 --> 00:26:39.269
sending requests it turns out in this

503
00:26:39.269 --> 00:26:44.819
paper there the replicated service

504
00:26:49.529 --> 00:26:53.369
of disk server that it talks to him

505
00:26:53.369 --> 00:26:55.309
although it's a little bit hard to

506
00:26:55.309 --> 00:26:59.759
realize this from the paper the scheme

507
00:26:59.759 --> 00:27:01.710
actually does not really treat the de

508
00:27:01.710 --> 00:27:04.140
server particularly especially it's just

509
00:27:04.140 --> 00:27:07.289
another external source of packets and

510
00:27:07.289 --> 00:27:09.930
place that the replicated state machine

511
00:27:17.369 --> 00:27:20.369
scheme is that the we assume that these

512
00:27:20.369 --> 00:27:24.119
two replicas the two virtual machines

513
00:27:24.119 --> 00:27:27.869
primary and backup are our exact

514
00:27:27.869 --> 00:27:30.150
replicas some client you know database

515
00:27:30.150 --> 00:27:31.559
client who knows who has some client of

516
00:27:31.559 --> 00:27:33.599
our replicated server sends a request to

517
00:27:38.910 --> 00:27:40.589
we're talking about that generates an

518
00:27:40.589 --> 00:27:41.220
interrupt

519
00:27:41.220 --> 00:27:43.140
and this interrupts actually goes to the

520
00:27:43.140 --> 00:27:45.269
virtual machine monitor at least in the

521
00:27:45.269 --> 00:27:47.789
first instance the virtual machine

522
00:27:55.680 --> 00:27:58.430
one is it sort of simulates a network

523
00:27:58.430 --> 00:28:01.799
packet arrival interrupt into the

524
00:28:01.799 --> 00:28:04.109
primary guest operating system to

525
00:28:04.109 --> 00:28:07.470
deliver it to the primary copy of the

526
00:28:07.470 --> 00:28:09.599
application and in addition the virtual

527
00:28:09.599 --> 00:28:11.759
machine monitor you know knows that this

528
00:28:11.759 --> 00:28:13.680
is an input to a replicated virtual

529
00:28:13.680 --> 00:28:15.779
machine and it's so it sends back out on

530
00:28:15.779 --> 00:28:19.710
the network a copy of that packet to the

531
00:28:26.279 --> 00:28:28.470
monitor knows ha it is a packet for this

532
00:28:34.529 --> 00:28:36.150
arrival interrupt at the backup and

533
00:28:40.799 --> 00:28:42.779
packet they looks at the same input you

534
00:29:02.329 --> 00:29:06.230
machine monitor is emulating and then

535
00:29:06.230 --> 00:29:07.549
the virtual machine monitor or will

536
00:29:11.269 --> 00:29:13.930
back out on the network to the client

537
00:29:13.930 --> 00:29:16.339
because the backup is running exactly

538
00:29:16.339 --> 00:29:17.809
the same sequence of instructions it

539
00:29:17.809 --> 00:29:20.359
also generates a reply packet back to

540
00:29:20.359 --> 00:29:23.269
the client and sends that reply packet

541
00:29:23.269 --> 00:29:27.230
on its emulated NIC it's the virtual

542
00:29:27.230 --> 00:29:28.549
machine monitor that's emulating that

543
00:29:32.480 --> 00:29:34.430
says I know this was the backup only the

544
00:29:34.430 --> 00:29:35.990
primary is allowed to generate output

545
00:29:42.140 --> 00:29:44.240
inputs and only the primary generates

546
00:29:44.240 --> 00:29:53.509
outputs as far as terminology goes the

547
00:29:53.509 --> 00:29:59.690
paper calls this stream of input events

548
00:29:59.690 --> 00:30:01.400
and other things other events we'll talk

549
00:30:01.400 --> 00:30:04.309
about from the stream is called the

550
00:30:04.309 --> 00:30:06.890
logging Channel it all goes over the

551
00:30:06.890 --> 00:30:10.549
same network presumably but these events

552
00:30:22.240 --> 00:30:24.740
where the fault tolerance comes in is

553
00:30:37.309 --> 00:30:42.109
entries on the logging channel and we

554
00:30:42.109 --> 00:30:45.500
know it it turns out that the backup can

555
00:30:45.500 --> 00:30:47.210
expect to get many per second because

556
00:30:47.210 --> 00:30:49.759
one of the things that generates log

557
00:30:49.759 --> 00:30:52.369
entries is periodic timer interrupts in

558
00:30:52.369 --> 00:30:55.309
the in the primary each one of which

559
00:30:55.309 --> 00:30:57.289
turns out every interrupt generates a

560
00:30:57.289 --> 00:30:59.509
log entries into the backup these timer

561
00:30:59.509 --> 00:31:01.130
interrupts are going to happen like 100

562
00:31:01.130 --> 00:31:02.420
times a second so the backups can

563
00:31:02.420 --> 00:31:04.279
certainly expect to see

564
00:31:04.279 --> 00:31:07.400
a lot of chitchat on the logging Channel

565
00:31:07.400 --> 00:31:09.109
if the primaries up if the primary

566
00:31:09.109 --> 00:31:11.509
crashes then the virtual machine

567
00:31:11.509 --> 00:31:12.980
monitored over here will say gosh you

568
00:31:12.980 --> 00:31:14.329
know I haven't received anything on the

569
00:31:14.329 --> 00:31:15.890
logging channel for like a second or

570
00:31:15.890 --> 00:31:19.480
however long the primary must be dead or

571
00:31:19.480 --> 00:31:25.309
or something and in that case when the

572
00:31:25.309 --> 00:31:28.700
backup stop seeing log entries from the

573
00:31:28.700 --> 00:31:31.279
primary the paper the way the paper

574
00:31:31.279 --> 00:31:33.319
freezes it is that the backup goes live

575
00:31:33.319 --> 00:31:35.779
and what that means is that it stops

576
00:31:35.779 --> 00:31:42.920
waiting for these input events on the

577
00:31:42.920 --> 00:31:46.849
logging Channel from the primary and

578
00:31:46.849 --> 00:31:49.160
instead this virtual machine monitor

579
00:31:49.160 --> 00:31:51.789
just lets this backup execute freely

580
00:31:51.789 --> 00:31:54.589
without waiting for without being driven

581
00:32:00.680 --> 00:32:02.509
future client requests to go to the

582
00:32:09.769 --> 00:32:11.150
personnel it's the primary not the

583
00:32:11.150 --> 00:32:13.940
backup stops discarding output from this

584
00:32:13.940 --> 00:32:15.769
virtual machine so now this or machine

585
00:32:15.769 --> 00:32:18.170
directly gets the inputs and there's a

586
00:32:18.170 --> 00:32:20.269
lot of produce output and now our backup

587
00:32:20.269 --> 00:32:22.519
is taken over and similarly you know

588
00:32:22.519 --> 00:32:25.279
that this is less interesting but has to

589
00:32:25.279 --> 00:32:26.329
work correctly

590
00:32:26.329 --> 00:32:29.390
if the backup fails a similar primary

591
00:32:29.390 --> 00:32:31.130
has to use a similar process to abandon

592
00:32:31.130 --> 00:32:34.549
the backup stop sending it events and

593
00:32:43.460 --> 00:32:46.390
generating network traffic

594
00:32:51.220 --> 00:32:57.230
magic now it depends you know depends on

595
00:32:57.230 --> 00:33:01.549
what the networking technology is I

596
00:33:01.549 --> 00:33:04.940
think with the paper one possibility is

597
00:33:04.940 --> 00:33:07.910
that this is sitting on Ethernet every

598
00:33:07.910 --> 00:33:09.529
physical computer on the Internet or

599
00:33:09.529 --> 00:33:15.430
really every NIC has a 48 bit unique ID

600
00:33:16.720 --> 00:33:21.319
I'm making this up now the it could be

601
00:33:21.319 --> 00:33:22.910
that in fact instead of each physical

602
00:33:22.910 --> 00:33:25.400
computer having a unique ID each virtual

603
00:33:25.400 --> 00:33:30.710
machine does and when the backup takes

604
00:33:30.710 --> 00:33:36.430
over it essentially claims the primary's

605
00:33:36.430 --> 00:33:39.319
Ethernet ID as its own and it starts

606
00:34:02.690 --> 00:34:04.369
they had identified all such sources and

607
00:34:04.369 --> 00:34:07.700
for each one of them the primary does

608
00:34:07.700 --> 00:34:10.159
whatever it is you know executes the

609
00:34:10.159 --> 00:34:12.139
random number generator instruction or

610
00:34:12.139 --> 00:34:14.360
takes an interrupt at some time the

611
00:34:14.360 --> 00:34:17.360
backup does not and the back of virtual

612
00:34:17.360 --> 00:34:19.639
machine monitor sort of detects any such

613
00:34:19.639 --> 00:34:22.429
instruction and and intercepts that and

614
00:34:22.429 --> 00:34:24.559
doesn't do it and he said the backup

615
00:34:24.559 --> 00:34:26.269
waits for an event on the logging

616
00:34:26.269 --> 00:34:28.610
Channel saying this instruction number

617
00:34:28.610 --> 00:34:30.980
you know the random number was whatever

618
00:34:30.980 --> 00:34:33.699
it was on the primary

619
00:34:37.420 --> 00:34:42.130
yes yes

620
00:34:42.670 --> 00:34:46.639
yeah the paper hints that they got Intel

621
00:34:46.639 --> 00:34:50.840
to add features to the microprocessor to

622
00:34:50.840 --> 00:34:54.650
support exactly this but they don't say

623
00:34:54.650 --> 00:35:03.369
what it was okay

624
00:35:31.190 --> 00:35:33.710
there are some things that are

625
00:35:37.429 --> 00:35:39.440
the computer is a deterministic function

626
00:35:39.440 --> 00:35:41.329
of the contents of the memory of the

627
00:35:41.329 --> 00:35:44.420
computer it is for a sort of straight

628
00:35:44.420 --> 00:35:46.280
line code execution often but certainly

629
00:35:46.280 --> 00:35:49.429
not always so worried about is things

630
00:35:49.429 --> 00:35:51.289
that may happen that are not a strict

631
00:35:51.289 --> 00:35:53.269
function of the current state that is

632
00:35:53.269 --> 00:35:54.920
that might be different if we're not

633
00:35:54.920 --> 00:35:56.960
careful on the primary and backup so

634
00:35:56.960 --> 00:35:58.760
these are sort of non-deterministic

635
00:36:05.539 --> 00:36:10.570
they all work and here are the ones

636
00:36:10.570 --> 00:36:12.349
here's the kind of stuff they talked

637
00:36:12.349 --> 00:36:16.519
about so one is inputs from external

638
00:36:16.519 --> 00:36:18.860
sources like clients which arrive just

639
00:36:18.860 --> 00:36:20.420
whenever they arrive right they're not

640
00:36:20.420 --> 00:36:21.889
predictable there are no sense in which

641
00:36:21.889 --> 00:36:24.170
the time at which a client request

642
00:36:24.170 --> 00:36:25.519
arrives or its content is a

643
00:36:34.550 --> 00:36:37.550
world in which services only talk over

644
00:36:37.550 --> 00:36:39.829
the network and so the only really

645
00:36:39.829 --> 00:36:41.630
basically the only form of input or

646
00:36:46.239 --> 00:36:48.619
coming and going so we didn't put

647
00:36:50.539 --> 00:36:53.809
arrives and what a packet really

648
00:36:53.809 --> 00:36:56.989
consists of for us is the data in the

649
00:36:56.989 --> 00:37:01.820
packet plus the interrupt

650
00:37:01.820 --> 00:37:05.570
that's signaled that the packet had

651
00:37:16.250 --> 00:37:20.719
contents into memory and then raises an

652
00:37:23.420 --> 00:37:26.210
point in the instruction stream and so

653
00:37:40.190 --> 00:37:42.500
to occur and better be the same on the

654
00:37:42.500 --> 00:37:44.420
primary in the backup otherwise their

655
00:37:44.420 --> 00:37:46.400
execution is different and their states

656
00:37:50.900 --> 00:37:54.289
of the interrupt and then as a couple of

657
00:37:54.289 --> 00:37:56.829
people have mentioned there's a few

658
00:37:56.829 --> 00:38:04.579
instructions that that behave

659
00:38:04.579 --> 00:38:06.920
differently on different computers or

660
00:38:06.920 --> 00:38:09.590
differently depending on something like

661
00:38:09.590 --> 00:38:11.300
there's maybe a random number generator

662
00:38:11.300 --> 00:38:13.250
instruction there's I get time-of-day

663
00:38:13.250 --> 00:38:15.260
instructions that will yield different

664
00:38:15.260 --> 00:38:16.639
answers have called at different times

665
00:38:16.639 --> 00:38:21.409
and unique ID instructions another huge

666
00:38:21.409 --> 00:38:22.849
source of non determinism which the

667
00:38:22.849 --> 00:38:27.440
paper basically rules out is multi-core

668
00:38:27.440 --> 00:38:33.320
parallelism this is a uni-process only

669
00:38:33.320 --> 00:38:34.909
system there's no multi-core in this

670
00:38:34.909 --> 00:38:36.920
world the reason for this is that if it

671
00:38:36.920 --> 00:38:40.340
allowed multi-core then then the service

672
00:38:40.340 --> 00:38:41.780
would be running on multiple cores and

673
00:38:45.889 --> 00:38:48.139
interleaved in some way which is not

674
00:38:48.139 --> 00:38:50.809
predictable and so really if we run the

675
00:38:50.809 --> 00:38:52.909
same code on the on the backup in the

676
00:38:52.909 --> 00:38:54.889
server if it's parallel code running on

677
00:38:54.889 --> 00:38:56.900
a multi-core the tubo interleave the

678
00:38:56.900 --> 00:38:58.519
instructions in the two cores in

679
00:38:58.519 --> 00:39:00.789
different ways the hardware will and

680
00:39:00.789 --> 00:39:03.449
that can just cause

681
00:39:03.449 --> 00:39:05.909
different results because you know

682
00:39:05.909 --> 00:39:08.849
supposing the code and the two cores you

683
00:39:08.849 --> 00:39:10.500
know they both asked for a lock on some

684
00:39:17.159 --> 00:39:19.139
timing difference core two may got the

685
00:39:19.139 --> 00:39:21.480
lock first and the you know execution

686
00:39:21.480 --> 00:39:23.610
results are totally different likely to

687
00:39:23.610 --> 00:39:25.230
be totally different if different

688
00:39:25.230 --> 00:39:26.960
threads get the lock

689
00:39:32.400 --> 00:39:36.750
outlawed in this papers world and indeed

690
00:39:36.750 --> 00:39:39.210
like as far as I can tell the techniques

691
00:40:01.980 --> 00:40:04.829
parallelism the hardware is almost

692
00:40:04.829 --> 00:40:06.960
certainly multi-core parallel but that's

693
00:40:06.960 --> 00:40:09.239
the hardware sitting underneath the

694
00:40:09.239 --> 00:40:11.639
virtual machine monitor the machine that

695
00:40:11.639 --> 00:40:13.829
the virtual machine monitor exposes to

696
00:40:13.829 --> 00:40:15.480
one of the guest operating systems that

697
00:40:15.480 --> 00:40:18.480
runs the primary backup that emulated

698
00:40:26.789 --> 00:40:31.550
them to adapt this design to multi-core

699
00:40:31.550 --> 00:40:34.880
virtual machines

700
00:40:39.960 --> 00:40:43.690
okay so so these are really it's it's

701
00:40:43.690 --> 00:40:44.949
it's these events that go over the

702
00:40:44.949 --> 00:40:49.780
logging channel and so the format of a

703
00:40:49.780 --> 00:40:55.659
log record a log log entry they don't

704
00:40:55.659 --> 00:40:57.159
quite say but I'm guessing that there's

705
00:40:57.159 --> 00:40:58.269
really three things in a log entry

706
00:40:58.269 --> 00:41:01.239
there's the instruction number at which

707
00:41:01.239 --> 00:41:02.710
the event occurred because if you're

708
00:41:02.710 --> 00:41:04.420
delivering an interrupt or you know

709
00:41:04.420 --> 00:41:06.250
input or whatever it better be delivered

710
00:41:06.250 --> 00:41:09.159
at exactly the same place in the primary

711
00:41:09.159 --> 00:41:10.570
backup so we need to know the

712
00:41:10.570 --> 00:41:11.800
instruction number and by instruction

713
00:41:11.800 --> 00:41:14.170
number I mean you know the number of

714
00:41:14.170 --> 00:41:15.909
instructions since the Machine booted

715
00:41:15.909 --> 00:41:18.280
why not the instruction address but like

716
00:41:18.280 --> 00:41:20.650
oh or executing the four billion and

717
00:41:20.650 --> 00:41:23.500
79th instructions since boot so log

718
00:41:23.500 --> 00:41:24.610
entry is going to have instruction

719
00:41:24.610 --> 00:41:31.210
number four an interrupt for input it's

720
00:41:35.769 --> 00:41:39.369
and for a weird instruction like get at

721
00:41:39.369 --> 00:41:41.139
time of day it's going to be the

722
00:41:41.139 --> 00:41:43.329
instruction number of the instruction of

723
00:41:43.329 --> 00:41:44.980
the get time of day or whatever

724
00:41:44.980 --> 00:41:46.960
instruction that was executed on the

725
00:41:46.960 --> 00:41:49.269
primary so that you know the backup

726
00:41:49.269 --> 00:41:52.449
knows where to where to call this event

727
00:41:52.449 --> 00:41:54.820
to occur okay so there's gonna be a type

728
00:42:00.219 --> 00:42:03.369
be data for a packet arrival it's gonna

729
00:42:03.369 --> 00:42:05.170
be the packet data for one of these

730
00:42:05.170 --> 00:42:06.429
weird instructions it's going to be the

731
00:42:06.429 --> 00:42:08.139
result of the instruction when it was

732
00:42:08.139 --> 00:42:10.449
executed on the primary so that the

733
00:42:10.449 --> 00:42:13.300
backup virtual machine can sort of fake

734
00:42:13.300 --> 00:42:15.550
the instruction and supply that same

735
00:42:15.550 --> 00:42:17.909
result

736
00:42:22.110 --> 00:42:27.519
okay so so as an example the both of

737
00:42:27.519 --> 00:42:34.960
these operating systems guest operating

738
00:42:34.960 --> 00:42:38.679
system assumes requires that the

739
00:42:38.679 --> 00:42:40.239
hardware in this case emulated hardware

740
00:42:40.239 --> 00:42:42.309
virtual machine has a timer that ticks

741
00:42:42.309 --> 00:42:44.679
say a hundred times a second and causes

742
00:42:44.679 --> 00:42:47.860
interrupts to the operating system and

743
00:42:47.860 --> 00:42:49.539
that's how the operating system keeps

744
00:42:49.539 --> 00:42:51.219
track of time it's by counting these

745
00:42:51.219 --> 00:42:54.699
timer interrupts so the way that plays

746
00:42:54.699 --> 00:42:56.500
out those timer notice why they have to

747
00:42:56.500 --> 00:42:58.269
happen at exactly the same place in the

748
00:42:58.269 --> 00:43:00.610
primary and backup otherwise they don't

749
00:43:06.809 --> 00:43:10.719
there's a timer on the physical machine

750
00:43:10.719 --> 00:43:14.139
that's running the Ft virtual machine

751
00:43:18.250 --> 00:43:19.780
a timer and up to the virtual machine

752
00:43:19.780 --> 00:43:23.559
monitor on the primary the virtual

753
00:43:23.559 --> 00:43:24.820
machine monitor at you know the

754
00:43:24.820 --> 00:43:29.860
appropriate moment stops the execution

755
00:43:29.860 --> 00:43:31.929
of the primary writes down the

756
00:43:31.929 --> 00:43:34.179
instruction number that it was at you

757
00:43:34.179 --> 00:43:37.320
know instruction since boot and then

758
00:43:37.320 --> 00:43:39.789
delivers sort of fake simulates and

759
00:43:39.789 --> 00:43:41.829
interrupts into the guest operating

760
00:43:41.829 --> 00:43:43.239
system in the primary at that

761
00:43:43.239 --> 00:43:44.530
instruction number saying oh you know

762
00:43:44.530 --> 00:43:46.570
you're emulating the timer Hardware just

763
00:43:49.300 --> 00:43:51.400
primary virtual machine monitor sends

764
00:43:51.400 --> 00:43:52.599
that instruction number which the

765
00:43:52.599 --> 00:43:54.809
interrupt happened you know to the

766
00:43:54.809 --> 00:43:59.260
backup the backup of course it's virtual

767
00:43:59.260 --> 00:44:00.519
machine monitor is also taking timer

768
00:44:00.519 --> 00:44:02.440
interrupts from its physical timer and

769
00:44:02.440 --> 00:44:04.659
it's not giving them it's not giving

770
00:44:04.659 --> 00:44:06.909
it's a real physical timer interrupts to

771
00:44:13.449 --> 00:44:15.699
log entry for the primaries timer

772
00:44:15.699 --> 00:44:18.730
interrupts arrives here then the backup

773
00:44:18.730 --> 00:44:20.500
virtual machine monitor will arrange

774
00:44:20.500 --> 00:44:22.210
with the CPU and this requires special

775
00:44:22.210 --> 00:44:28.119
CPU support to cause the physical

776
00:44:28.119 --> 00:44:30.699
machine to interrupt at the same

777
00:44:30.699 --> 00:44:32.630
instruction number

778
00:44:32.630 --> 00:44:34.130
at the timer interrupts tapped into the

779
00:44:34.130 --> 00:44:36.949
primary at that point the virtual

780
00:44:36.949 --> 00:44:38.539
machine monitor gets control again from

781
00:44:38.539 --> 00:44:41.510
the guest and then fakes the timer

782
00:44:41.510 --> 00:44:43.969
interrupts into the backup operating

783
00:44:43.969 --> 00:44:46.190
system now exact exactly the same

784
00:44:46.190 --> 00:44:47.929
instruction number as it occurred on the

785
00:45:18.739 --> 00:45:20.929
having some special hardware in it where

786
00:45:20.929 --> 00:45:24.440
the vmm can tell the hardware CPU please

787
00:45:24.440 --> 00:45:26.929
interrupt a thousand instructions from

788
00:45:26.929 --> 00:45:29.929
now and then the vmm you know where so

789
00:45:29.929 --> 00:45:32.989
that you know it'll interrupt at the

790
00:45:35.719 --> 00:45:38.570
the vmm just tells the cpu to start X

791
00:45:38.570 --> 00:45:40.699
resume executing again in the backup and

792
00:45:40.699 --> 00:45:42.559
exactly a thousand instructions later

793
00:45:42.559 --> 00:45:44.719
the CPU will force an interrupt into the

794
00:45:44.719 --> 00:45:46.460
virtual machine monitor and that that's

795
00:45:46.460 --> 00:45:48.530
special hardware but it turns out it's

796
00:45:48.530 --> 00:45:51.739
you know on all Intel chips so it's not

797
00:45:51.739 --> 00:45:53.929
it's not that special anymore you know

798
00:45:53.929 --> 00:45:56.960
15 years ago it was exotic now it's

799
00:45:56.960 --> 00:45:59.510
totally normal and it turns out there's

800
00:45:59.510 --> 00:46:01.550
a lot of other uses for it like um if

801
00:46:01.550 --> 00:46:02.929
you want to do profiling you wanna do

802
00:46:02.929 --> 00:46:04.940
CPU time profiling what you'd really

803
00:46:04.940 --> 00:46:07.550
like or one way to do CPU time profiling

804
00:46:07.550 --> 00:46:09.289
is to have the microprocessor interrupt

805
00:46:09.289 --> 00:46:11.420
every thousand instructions right and

806
00:46:11.420 --> 00:46:13.190
this is the hardware that's this

807
00:46:13.190 --> 00:46:15.469
Hardware also this is the same hardware

808
00:46:15.469 --> 00:46:17.179
that would cause the microprocessor to

809
00:46:17.179 --> 00:46:18.860
generate an interrupt every thousand

810
00:46:18.860 --> 00:46:21.920
instructions so it's a very natural sort

811
00:46:21.920 --> 00:46:25.630
of gadget to want in your CPU

812
00:46:31.429 --> 00:46:39.170
all right yes

813
00:46:59.760 --> 00:47:02.820
know that oh you know the primary is

814
00:47:02.820 --> 00:47:04.679
about to take an interrupt at the

815
00:47:04.679 --> 00:47:08.969
millionth instruction but the backup is

816
00:47:08.969 --> 00:47:11.760
already you know executed the millionth

817
00:47:16.530 --> 00:47:19.440
late to deliver the interrupts if we let

818
00:47:19.440 --> 00:47:21.239
the backup execute ahead of the primary

819
00:47:21.239 --> 00:47:23.730
it's going to be too late to deliver the

820
00:47:27.510 --> 00:47:29.309
backup of the instruction stream so we

821
00:47:29.309 --> 00:47:31.559
cannot let that happen we cannot let the

822
00:47:31.559 --> 00:47:33.659
backup get ahead of the primary in

823
00:47:33.659 --> 00:47:37.860
execution and the way VMware ft does

824
00:47:37.860 --> 00:47:45.449
that is that the the backup virtual

825
00:47:45.449 --> 00:47:46.679
machine monitor it actually keeps a

826
00:47:46.679 --> 00:47:49.679
buffer of waiting events that have

827
00:47:49.679 --> 00:47:53.400
arrived from the primary and it will not

828
00:47:53.400 --> 00:47:56.460
let to the backup execute unless there's

829
00:47:56.460 --> 00:47:58.920
at least one event in that buffer and if

830
00:47:58.920 --> 00:48:01.500
there's one event in that buffer then it

831
00:48:01.500 --> 00:48:02.909
will know from the instruction number

832
00:48:02.909 --> 00:48:07.409
the place at which it's got a force the

833
00:48:07.409 --> 00:48:10.889
backup to stop executing so always

834
00:48:10.889 --> 00:48:14.760
always the backup is executing with the

835
00:48:14.760 --> 00:48:17.420
CPU being told exactly where the next

836
00:48:17.420 --> 00:48:19.710
stopping point the next instruction

837
00:48:19.710 --> 00:48:21.719
number of a stopping point is because

838
00:48:21.719 --> 00:48:24.320
the backup only executes if it has a an

839
00:48:24.320 --> 00:48:26.699
event here that tells it where to stop

840
00:48:26.699 --> 00:48:30.449
next so that means it starts up after

841
00:48:30.449 --> 00:48:31.800
the primary because the backup can't

842
00:48:31.800 --> 00:48:33.570
even start executing until the primary

843
00:48:33.570 --> 00:48:35.789
has generated the first event and that

844
00:48:35.789 --> 00:48:37.469
event has arrived at the backup so the

845
00:48:37.469 --> 00:48:39.179
backup sort of always one event

846
00:48:39.179 --> 00:48:41.699
basically behind the at least one event

847
00:48:41.699 --> 00:48:43.139
behind the primary and if it's slower

848
00:48:43.139 --> 00:48:44.730
for some other whatever reason maybe

849
00:48:44.730 --> 00:48:45.780
there's other stuff running on that

850
00:48:45.780 --> 00:48:47.760
physical machine then the backup might

851
00:48:47.760 --> 00:48:50.880
get you know multiple events behind at

852
00:48:50.880 --> 00:48:53.360
the primary

853
00:49:05.519 --> 00:49:16.539
arriving packets ordinarily when a

854
00:49:16.539 --> 00:49:17.949
packet arrives from a network interface

855
00:49:17.949 --> 00:49:19.300
card if we weren't running a virtual

856
00:49:19.300 --> 00:49:22.210
machine the network interface card would

857
00:49:22.210 --> 00:49:24.670
DMA the packet content into the memory

858
00:49:24.670 --> 00:49:27.730
of the computer that it's attached to

859
00:49:27.730 --> 00:49:30.489
sort of as the data arrives from the

860
00:49:34.840 --> 00:49:38.199
like this but it could be that the

861
00:49:38.199 --> 00:49:39.489
operating system that's running on a

862
00:49:39.489 --> 00:49:41.800
computer might actually see the data of

863
00:49:41.800 --> 00:49:44.230
a packet as its DMA or copied from the

864
00:49:44.230 --> 00:49:46.300
network interface card into memory right

865
00:49:46.300 --> 00:49:49.780
you know this is and you know we don't

866
00:49:52.150 --> 00:49:53.949
operating system and cost maybe there is

867
00:49:58.780 --> 00:50:01.869
copied into memory so we can't let that

868
00:50:01.869 --> 00:50:04.780
happen because if the primary happens to

869
00:50:04.780 --> 00:50:08.860
be playing that trick it's gonna see you

870
00:50:08.860 --> 00:50:10.780
know if we allowed the network interface

871
00:50:15.550 --> 00:50:17.559
primary we don't have any control over

872
00:50:17.559 --> 00:50:20.199
the exact timing of when the network

873
00:50:20.199 --> 00:50:22.210
interface card copies data into memory

874
00:50:22.210 --> 00:50:24.340
and so we're not going to know sort of

875
00:50:24.340 --> 00:50:28.840
at what times the primary did or didn't

876
00:50:34.719 --> 00:50:39.489
the NIC copies incoming packets into

877
00:50:39.489 --> 00:50:41.110
private memory of the virtual machine

878
00:50:41.110 --> 00:50:43.210
monitor and then the network interface

879
00:50:43.210 --> 00:50:45.280
card interrupts the virtual machine

880
00:50:45.280 --> 00:50:46.570
monitor and says oh a packet has arrived

881
00:50:46.570 --> 00:50:48.429
at that point the virtual machine

882
00:50:48.429 --> 00:50:51.190
monitor will suspend the primary and

883
00:50:51.190 --> 00:50:52.929
remember what instruction number had

884
00:50:52.929 --> 00:50:56.500
suspended at copy the entire packet into

885
00:50:56.500 --> 00:50:57.940
the primaries memory while the primary

886
00:50:57.940 --> 00:51:00.820
suspended and not looking at this copy

887
00:51:00.820 --> 00:51:03.639
and then emulate a network interface

888
00:51:03.639 --> 00:51:05.789
card interrupt into the primary

889
00:51:05.789 --> 00:51:10.400
and then send the packet and the

890
00:51:16.409 --> 00:51:17.579
you know virtual machine monitor will

891
00:51:17.579 --> 00:51:18.989
spend the backup at that instruction

892
00:51:23.219 --> 00:51:25.650
watching the data arrive and then fakin

893
00:51:25.650 --> 00:51:27.329
interrupts at the same instruction

894
00:51:27.329 --> 00:51:30.710
numbers of the primary and this is the

895
00:51:59.789 --> 00:52:03.239
logging channel traffic or are weird

896
00:52:03.239 --> 00:52:06.449
instructions which are rare no its

897
00:52:06.449 --> 00:52:09.300
instructions that might yield a

898
00:52:09.300 --> 00:52:10.679
different result if executed on the

899
00:52:10.679 --> 00:52:12.539
primary and backup like instruction to

900
00:52:12.539 --> 00:52:14.130
get the current time of day or current

901
00:52:14.130 --> 00:52:15.929
processor number or ask how many

902
00:52:15.929 --> 00:52:18.510
instructions have been executed or and

903
00:52:18.510 --> 00:52:19.769
those actually turn out to be relatively

904
00:52:24.269 --> 00:52:25.889
hardware generated random number for

905
00:52:25.889 --> 00:52:28.500
cryptography or something and but those

906
00:52:28.500 --> 00:52:30.179
are not everyday instructions most

907
00:52:30.179 --> 00:52:31.500
instructions like add instructions

908
00:52:31.500 --> 00:52:33.659
they're gonna get the same result on

909
00:52:33.659 --> 00:52:36.380
primary and that go

910
00:52:44.699 --> 00:52:47.730
yeah so the way those get replicated on

911
00:52:57.840 --> 00:53:02.269
by the tcp/ip stack on both you know so

912
00:53:02.269 --> 00:53:07.139
I'm expecting 99.99% of the logging

913
00:53:07.139 --> 00:53:09.360
channel traffic to be incoming packets

914
00:53:09.360 --> 00:53:12.210
and only a tiny fraction to be results

915
00:53:22.650 --> 00:53:24.570
basically it's a copy of every client

916
00:53:24.570 --> 00:53:27.840
packet and then we'll sort of know what

917
00:53:27.840 --> 00:53:29.880
the logging channel how fast the logging

918
00:53:29.880 --> 00:53:40.980
channel has to be all right so um so

919
00:53:40.980 --> 00:53:42.150
it's worth talking a little bit about

920
00:53:42.150 --> 00:53:44.849
how output works and in this system

921
00:53:44.849 --> 00:53:46.409
really the only what output basically

922
00:53:46.409 --> 00:53:49.829
means only is sending packets that

923
00:53:49.829 --> 00:53:51.300
client send requests in as network

924
00:53:51.300 --> 00:53:54.929
packets the response goes back out as

925
00:53:54.929 --> 00:53:56.760
network packets and there's really no

926
00:53:56.760 --> 00:54:00.150
other form of output as I mentioned the

927
00:54:00.150 --> 00:54:02.579
you know both primary and backup compute

928
00:54:02.579 --> 00:54:04.769
the output packet they want to send and

929
00:54:04.769 --> 00:54:06.570
that sort of asks that simulated mix to

930
00:54:06.570 --> 00:54:08.309
send the packet it's really sent on the

931
00:54:08.309 --> 00:54:10.409
primary and simply discard it the output

932
00:54:10.409 --> 00:54:15.929
packet discarded on the backup okay but

933
00:54:21.150 --> 00:54:24.630
what we're running is a some sort of

934
00:54:24.630 --> 00:54:27.449
simple database server and the operation

935
00:54:27.449 --> 00:54:28.650
the client operation that our database

936
00:54:28.650 --> 00:54:31.380
server supports is increment and ideas

937
00:54:36.389 --> 00:54:39.960
and sends back the new value so maybe on

938
00:54:39.960 --> 00:54:41.579
the primary well let's say everything's

939
00:54:41.579 --> 00:54:43.409
fine so far and the primary backup both

940
00:54:43.409 --> 00:54:47.159
have value 10 in memory and that's the

941
00:54:47.159 --> 00:54:51.389
current value at the counter and some

942
00:54:51.389 --> 00:54:53.489
client on the local area network sends a

943
00:54:53.489 --> 00:54:58.610
you know an increment request to

944
00:55:04.789 --> 00:55:07.309
it's executed the primary server

945
00:55:07.309 --> 00:55:08.659
software and the primary says oh you

946
00:55:08.659 --> 00:55:10.309
know current values 10 I'm gonna change

947
00:55:16.610 --> 00:55:20.570
11 as their reply the same request as I

948
00:55:20.570 --> 00:55:22.159
mentioned gonna supposed to be sent to

949
00:55:26.710 --> 00:55:28.730
generate a reply and we'll throw it away

950
00:55:28.730 --> 00:55:30.469
that's what's supposed to happen the

951
00:55:30.469 --> 00:55:33.619
output however you also need to ask

952
00:55:44.539 --> 00:55:46.190
have a failure and what would happen you

953
00:55:46.190 --> 00:55:54.559
to failure occurred then so suppose the

954
00:55:54.559 --> 00:55:58.130
primary does indeed generate the reply

955
00:55:58.130 --> 00:56:01.190
here back to the client but the client

956
00:56:01.190 --> 00:56:03.199
the primary crashes just after sending

957
00:56:03.199 --> 00:56:05.329
the report its reply to the client and

958
00:56:05.329 --> 00:56:08.360
furthermore and much worse it turns out

959
00:56:08.360 --> 00:56:10.179
that you know this is just a network it

960
00:56:10.179 --> 00:56:12.440
doesn't guarantee to deliver packets

961
00:56:12.440 --> 00:56:16.250
let's suppose this log entry on the

962
00:56:16.250 --> 00:56:18.860
logging channel got dropped also when

963
00:56:18.860 --> 00:56:21.170
the when the primary died so now the

964
00:56:21.170 --> 00:56:23.960
state of play is the client received a

965
00:56:29.989 --> 00:56:34.940
still 10 no now the backup takes over

966
00:56:34.940 --> 00:56:37.610
because it's seized the primary is dead

967
00:56:37.610 --> 00:56:39.650
and this client or maybe some other

968
00:56:39.650 --> 00:56:41.780
client sends an increment request a new

969
00:56:41.780 --> 00:56:43.789
backup and now it's really processing

970
00:56:43.789 --> 00:56:45.829
these requests and so the new backup

971
00:56:45.829 --> 00:56:47.420
when it gets the next increment requests

972
00:56:47.420 --> 00:56:49.219
you know it's now going to change its

973
00:56:49.219 --> 00:56:55.639
state to 11 and generate a second 11

974
00:56:55.639 --> 00:56:58.309
response maybe the same client maybe to

975
00:56:58.309 --> 00:57:00.469
a different client which if the clients

976
00:57:00.469 --> 00:57:01.760
compare notes or if it's the same client

977
00:57:01.760 --> 00:57:04.610
it's just obviously cannot have happened

978
00:57:04.610 --> 00:57:07.789
I didn't so you know because we have to

979
00:57:07.789 --> 00:57:10.670
support unmodified software that does

980
00:57:10.670 --> 00:57:11.389
not

981
00:57:11.389 --> 00:57:13.219
damn that there's any funny business of

982
00:57:13.219 --> 00:57:15.289
replication going on that means we do

983
00:57:15.289 --> 00:57:17.480
not have the opportunity to you know you

984
00:57:20.869 --> 00:57:22.639
something funny it happened with the

985
00:57:22.639 --> 00:57:24.559
fault tolerance and do I don't know what

986
00:57:24.559 --> 00:57:25.789
but we don't have that option here

987
00:57:25.789 --> 00:57:27.559
because this whole system really only

988
00:57:27.559 --> 00:57:29.929
makes sense if we're running unmodified

989
00:57:29.929 --> 00:57:33.800
software so so this was a big this is a

990
00:57:33.800 --> 00:57:38.769
disaster we can't have let this happen

991
00:57:38.769 --> 00:57:43.130
does anybody remember from the paper how

992
00:57:43.130 --> 00:57:45.949
they prevent this from happening the

993
00:57:45.949 --> 00:57:48.860
output rule yeah so you want to do you

994
00:57:48.860 --> 00:57:57.260
know yeah so the output rules is the

995
00:57:57.260 --> 00:58:03.260
their solution to this problem and the

996
00:58:03.260 --> 00:58:05.690
idea is that the client he's not allowed

997
00:58:05.690 --> 00:58:08.539
to generate you know and generate any

998
00:58:08.539 --> 00:58:10.159
output the primary's not allowed to

999
00:58:10.159 --> 00:58:11.389
generate any output and what we're

1000
00:58:11.389 --> 00:58:13.239
talking about now is this output here

1001
00:58:21.889 --> 00:58:24.409
point so the real sequence at the

1002
00:58:24.409 --> 00:58:27.349
primary then let's now undone crash the

1003
00:58:27.349 --> 00:58:32.510
primary go back to them starting at 10

1004
00:58:32.510 --> 00:58:34.579
the real sequence now when the output

1005
00:58:34.579 --> 00:58:40.670
rule is that the input arrives at the

1006
00:58:40.670 --> 00:58:42.679
time the input arrives that's when the

1007
00:58:42.679 --> 00:58:46.400
virtual machine monitor sends a copy of

1008
00:58:53.150 --> 00:58:55.670
the input is sent is before strictly

1009
00:58:55.670 --> 00:58:58.239
before the primary generates the output

1010
00:58:58.239 --> 00:59:03.440
sort of obvious then after firing this

1011
00:59:03.440 --> 00:59:05.150
log entry off across a network and now

1012
00:59:05.150 --> 00:59:08.510
it's heading towards the backup but I'd

1013
00:59:14.480 --> 00:59:16.610
the primary server software it generates

1014
00:59:16.610 --> 00:59:19.869
the output so now the

1015
00:59:20.690 --> 00:59:22.550
replicated you know the primary has

1016
00:59:22.550 --> 00:59:24.710
actually generated change the state 211

1017
00:59:24.710 --> 00:59:26.840
and generated an output packet that says

1018
00:59:26.840 --> 00:59:28.610
eleven but the virtual machine monitor

1019
00:59:28.610 --> 00:59:29.690
says oh wait a minute we're not allowed

1020
00:59:29.690 --> 00:59:31.159
to generate that output until all

1021
00:59:31.159 --> 00:59:32.480
previous log records have been

1022
00:59:32.480 --> 00:59:34.699
acknowledged by the backup so you know

1023
00:59:34.699 --> 00:59:37.130
this is the most recent previous log

1024
00:59:37.130 --> 00:59:39.139
message so this output is held by the

1025
00:59:39.139 --> 00:59:42.829
virtual machine monitor until the this

1026
00:59:42.829 --> 00:59:44.570
log entry containing the input packet

1027
00:59:52.429 --> 00:59:54.409
waiting for the backup to get to that

1028
00:59:54.409 --> 00:59:56.869
point in the instruction stream and then

1029
01:00:00.530 --> 01:00:02.239
did get that input and when the

1030
01:00:02.239 --> 01:00:05.690
acknowledgment comes back only then will

1031
01:00:11.269 --> 01:00:12.980
the idea is that if the client could

1032
01:00:12.980 --> 01:00:16.190
have seen the reply then necessarily the

1033
01:00:16.190 --> 01:00:18.530
backup must have seen the request and at

1034
01:00:18.530 --> 01:00:22.579
least buffered it and so we no longer

1035
01:00:22.579 --> 01:00:25.219
get this weird situation in which a

1036
01:00:25.219 --> 01:00:27.469
client can see a reply but then there's

1037
01:00:27.469 --> 01:00:29.780
a failure and a cut over and the replica

1038
01:00:29.780 --> 01:00:33.949
didn't know anything about that reply if

1039
01:00:33.949 --> 01:00:36.139
the you know there's also a situation

1040
01:00:36.139 --> 01:00:40.309
maybe this message was lost and if this

1041
01:00:40.309 --> 01:00:43.219
log entry was lost and then the primary

1042
01:00:43.219 --> 01:00:45.650
crashes well since it hadn't been

1043
01:00:45.650 --> 01:00:47.750
delivered so the backup hadn't sent the

1044
01:00:47.750 --> 01:00:49.670
act that means if the primary crashed

1045
01:00:49.670 --> 01:00:52.219
you know this log entry was brought in

1046
01:00:52.219 --> 01:00:53.809
the primary crashed it must have crashed

1047
01:00:53.809 --> 01:00:56.210
before the virtual machine monitor or at

1048
01:01:00.349 --> 01:01:03.500
reply and so it's not in a position to

1049
01:01:03.500 --> 01:01:09.650
spot any irregularities they're really

1050
01:01:09.650 --> 01:01:12.550
happy with the output rule

1051
01:01:31.599 --> 01:01:34.159
paper doesn't mention how the virtual

1052
01:01:34.159 --> 01:01:35.719
machine monitor is implemented I mean

1053
01:01:39.530 --> 01:01:41.570
memory and figuring page tables and

1054
01:01:44.719 --> 01:01:46.969
understanding what instructions the

1055
01:01:51.829 --> 01:01:53.480
written in you know traditionally C or

1056
01:01:53.480 --> 01:01:59.150
C++ but I don't actually know okay this

1057
01:01:59.150 --> 01:02:02.449
of the primary has to delay at this

1058
01:02:02.449 --> 01:02:07.400
point waiting for the backup to say that

1059
01:02:07.400 --> 01:02:09.409
it's up to date this is a real

1060
01:02:09.409 --> 01:02:12.440
performance thorn in the side of just

1061
01:02:12.440 --> 01:02:15.440
about every replication scheme this sort

1062
01:02:15.440 --> 01:02:18.289
of synchronous wait where the we can't

1063
01:02:24.739 --> 01:02:27.679
backup lagging lagging behind clients

1064
01:02:27.679 --> 01:02:30.440
right so just about every replication

1065
01:02:30.440 --> 01:02:31.820
system has this problem that at some

1066
01:02:31.820 --> 01:02:34.460
point the primary has to stall waiting

1067
01:02:34.460 --> 01:02:36.679
for the backup and it's a real limit on

1068
01:02:36.679 --> 01:02:38.329
performance even if the machines are

1069
01:02:45.980 --> 01:02:49.190
primary stalled and if we wanna like

1070
01:02:49.190 --> 01:02:51.320
withstand earthquakes or citywide power

1071
01:02:54.320 --> 01:02:56.590
that's probably five milliseconds apart

1072
01:02:56.590 --> 01:02:59.510
every time we produce output if we

1073
01:02:59.510 --> 01:03:01.489
replicate in the two replicas in

1074
01:03:01.489 --> 01:03:03.349
different city every packet that it

1075
01:03:03.349 --> 01:03:05.510
produces this output has to first wait

1076
01:03:05.510 --> 01:03:08.449
the five milliseconds or whatever to

1077
01:03:08.449 --> 01:03:09.949
have the last log entry get to the

1078
01:03:09.949 --> 01:03:11.449
backup and how the acknowledgment come

1079
01:03:11.449 --> 01:03:12.619
back and then we can release a path

1080
01:03:12.619 --> 01:03:15.289
packet and you know for sort of low

1081
01:03:15.289 --> 01:03:18.440
intensity services that's not a problem

1082
01:03:18.440 --> 01:03:19.940
but if we're building a you know

1083
01:03:19.940 --> 01:03:21.769
database server that we would like to

1084
01:03:21.769 --> 01:03:22.940
you know that if it weren't for this

1085
01:03:22.940 --> 01:03:25.190
could process millions of requests per

1086
01:03:25.190 --> 01:03:25.960
second then

1087
01:03:25.960 --> 01:03:28.119
that's just unbelievably damaging for

1088
01:03:28.119 --> 01:03:31.659
performance and this is a big reason why

1089
01:03:31.659 --> 01:03:34.570
people you know you know if they

1090
01:03:39.699 --> 01:03:41.230
kind of understands the semantics of

1091
01:03:41.230 --> 01:03:42.969
operations and so it doesn't have to

1092
01:03:42.969 --> 01:03:45.219
stall on every packet you know it could

1093
01:03:45.219 --> 01:03:47.739
stall on every high level operation or

1094
01:03:47.739 --> 01:03:49.750
even notice that well you know read-only

1095
01:03:49.750 --> 01:03:51.519
operations don't have to stall at all

1096
01:03:51.519 --> 01:03:52.989
it's only right so that just all or

1097
01:03:52.989 --> 01:03:54.760
something but you have to there has to

1098
01:03:54.760 --> 01:03:55.840
be an application level replication

1099
01:03:55.840 --> 01:04:04.570
scheme to to realize that you're

1100
01:04:04.570 --> 01:04:06.280
absolutely right so the observation is

1101
01:04:06.280 --> 01:04:07.360
that you don't have to stall the

1102
01:04:07.360 --> 01:04:08.920
execution of the primary you only have

1103
01:04:08.920 --> 01:04:11.590
to hold the output and so maybe that's

1104
01:04:11.590 --> 01:04:13.989
not as bad as it could be but

1105
01:04:13.989 --> 01:04:16.150
nevertheless it means that every you

1106
01:04:16.150 --> 01:04:17.800
know in a service that could otherwise

1107
01:04:17.800 --> 01:04:19.510
have responded in a couple of

1108
01:04:19.510 --> 01:04:22.389
microseconds to the client you know if

1109
01:04:22.389 --> 01:04:24.940
we have to first update the replicas in

1110
01:04:24.940 --> 01:04:27.280
the next city we turn to you know 10

1111
01:04:36.159 --> 01:04:39.119
have vast numbers of clients submitting

1112
01:04:39.119 --> 01:04:41.829
concurrent requests then you may may be

1113
01:04:41.829 --> 01:04:43.690
able to maintain high throughput even

1114
01:04:43.690 --> 01:04:46.179
with high latency but you have to be

1115
01:05:01.269 --> 01:05:04.280
that's a great idea but if you log in

1116
01:05:04.280 --> 01:05:06.679
the memory of the primary that log will

1117
01:05:06.679 --> 01:05:08.630
disappear when the primary crashes or

1118
01:05:08.630 --> 01:05:10.670
that's usual semantics of a server

1119
01:05:10.670 --> 01:05:13.969
failing is that you lose everything

1120
01:05:13.969 --> 01:05:16.280
inside the box like the contents of

1121
01:05:16.280 --> 01:05:19.789
memory or you know if even if you didn't

1122
01:05:19.789 --> 01:05:21.679
if the failure is that somebody

1123
01:05:21.679 --> 01:05:23.239
unplugged the power cable accidentally

1124
01:05:23.239 --> 01:05:25.570
from the primary even if the primary

1125
01:05:25.570 --> 01:05:27.920
just has battery backed up RAM or I

1126
01:05:27.920 --> 01:05:30.710
don't know what you can't get at it

1127
01:05:30.710 --> 01:05:32.739
all right the backup can't get at it so

1128
01:05:37.909 --> 01:05:39.980
memory of the backup and in order to

1129
01:05:39.980 --> 01:05:42.320
reliably log it there you have to

1130
01:05:42.320 --> 01:05:43.639
observe the output rule and wait for the

1131
01:05:43.639 --> 01:05:46.130
acknowledgment so it's entirely correct

1132
01:05:46.130 --> 01:05:48.500
idea just can't use the primary's memory

1133
01:05:58.300 --> 01:06:06.320
say it again that's a clever idea I'd

1134
01:06:06.320 --> 01:06:08.449
and so the question is maybe input

1135
01:06:08.449 --> 01:06:11.570
should go to the primary but output

1136
01:06:11.570 --> 01:06:12.769
should come from the backup

1137
01:06:12.769 --> 01:06:14.599
I completely haven't thought this

1138
01:06:14.599 --> 01:06:17.210
through that might work that

1139
01:06:17.210 --> 01:06:21.940
I don't know that's interesting

1140
01:06:42.199 --> 01:06:48.179
okay one possibility this does expose

1141
01:06:58.409 --> 01:07:00.329
output is released so the client does

1142
01:07:00.329 --> 01:07:02.760
receive the reply then the primary

1143
01:07:02.760 --> 01:07:07.590
crashes the backups input is still in

1144
01:07:07.590 --> 01:07:09.750
this event buffer in the virtual machine

1145
01:07:09.750 --> 01:07:13.590
monitor of the backup it hasn't been

1146
01:07:13.590 --> 01:07:15.119
delivered to the actual replicated

1147
01:07:15.119 --> 01:07:18.809
service when the backup goes live after

1148
01:07:25.650 --> 01:07:27.539
log records that are lying around that

1149
01:07:27.539 --> 01:07:29.130
it hasn't consumed yet has to catch up

1150
01:07:29.130 --> 01:07:30.960
to the primary otherwise it won't take

1151
01:07:30.960 --> 01:07:33.239
over with the same state so before the

1152
01:07:33.239 --> 01:07:34.650
backup can go live it actually has to

1153
01:07:34.650 --> 01:07:37.530
consume all these entries the last entry

1154
01:07:45.800 --> 01:07:49.260
after it after the interrupt that

1155
01:07:49.260 --> 01:07:51.510
delivers the request from the client and

1156
01:07:51.510 --> 01:07:54.840
that means that the backup well you know

1157
01:07:54.840 --> 01:07:56.820
increment its counter to eleven and then

1158
01:07:56.820 --> 01:07:58.530
generate an output packet and since it's

1159
01:07:58.530 --> 01:08:01.860
live at this point it will generate the

1160
01:08:01.860 --> 01:08:04.650
output packet and the client will get to

1161
01:08:04.650 --> 01:08:10.739
eleven replies which is also if it if

1162
01:08:10.739 --> 01:08:15.659
that really happened would be anomalous

1163
01:08:15.659 --> 01:08:18.689
like possibly not something that could

1164
01:08:18.689 --> 01:08:22.140
happen if there was only one server the

1165
01:08:22.140 --> 01:08:25.710
good news is that almost certainly or

1166
01:08:25.710 --> 01:08:27.479
the almost certainly the client is

1167
01:08:27.479 --> 01:08:29.670
talking to this service using TCP and

1168
01:08:29.670 --> 01:08:30.930
that this is the request and the

1169
01:08:30.930 --> 01:08:32.279
response go back and forth on a TCP

1170
01:08:32.279 --> 01:08:35.130
Channel the when the backup takes over

1171
01:08:35.130 --> 01:08:37.560
the backup since the state is identical

1172
01:08:37.560 --> 01:08:39.210
to the primaries it knows all about that

1173
01:08:39.210 --> 01:08:40.890
TCP connection and whether all the

1174
01:08:40.890 --> 01:08:43.260
sequence numbers are and whatnot and

1175
01:08:43.260 --> 01:08:46.680
when it generates this packet it will

1176
01:08:46.680 --> 01:08:49.590
generate it with the same TCP sequence

1177
01:08:49.590 --> 01:08:52.199
number as an original packet and the TCP

1178
01:08:52.199 --> 01:08:53.880
stack on the client will say oh wait a

1179
01:08:53.880 --> 01:08:55.560
minute that's a duplicate packet

1180
01:08:55.560 --> 01:08:57.210
we'll discard the duplicate packet at

1181
01:08:57.210 --> 01:08:59.100
the TCP level and the user level

1182
01:08:59.100 --> 01:09:00.449
software will just never see this

1183
01:09:00.449 --> 01:09:04.470
duplicate and so this system really you

1184
01:09:11.579 --> 01:09:14.100
is for any replication system where

1185
01:09:14.100 --> 01:09:16.289
cutover can happen which is to say

1186
01:09:16.289 --> 01:09:20.390
pretty much any replication system it's

1187
01:09:20.390 --> 01:09:22.649
essentially impossible to design them in

1188
01:09:22.649 --> 01:09:24.930
a way that they are guaranteed not to

1189
01:09:24.930 --> 01:09:29.430
generate duplicate output basically you

1190
01:09:29.430 --> 01:09:31.470
know you well you can err on either side

1191
01:09:31.470 --> 01:09:33.300
I'm not even either not generate the

1192
01:09:33.300 --> 01:09:36.300
output at all which would be bad which

1193
01:09:36.300 --> 01:09:37.979
would be terrible or you can generate

1194
01:09:42.930 --> 01:09:44.880
guaranteed generated only once everybody

1195
01:09:44.880 --> 01:09:46.770
errors on the side of possibly

1196
01:09:46.770 --> 01:09:49.770
generating duplicate output and that

1197
01:09:49.770 --> 01:09:51.810
means that at some level you know the

1198
01:09:51.810 --> 01:09:53.520
client side of all replication schemes

1199
01:09:53.520 --> 01:09:55.560
need some sort of duplicate detection

1200
01:09:55.560 --> 01:09:57.989
scheme here we get to use TCP s that we

1201
01:09:57.989 --> 01:09:59.250
didn't have TCP that would have to be

1202
01:09:59.250 --> 01:10:01.140
something else maybe application level

1203
01:10:01.140 --> 01:10:03.229
sequence numbers or I don't know what

1204
01:10:03.229 --> 01:10:06.899
and you'll see all of this and actually

1205
01:10:06.899 --> 01:10:09.119
you'll see versions of essentially

1206
01:10:09.119 --> 01:10:10.590
everything I've talked about like the

1207
01:10:10.590 --> 01:10:14.569
output rule for example in labs 2 & 3

1208
01:10:14.569 --> 01:10:17.819
you'll design your own replicated state

1209
01:10:17.819 --> 01:10:20.689
machine yes

1210
01:10:58.920 --> 01:11:00.960
connection on the client side but there

1211
01:11:00.960 --> 01:11:02.760
is a connection on the backup side and

1212
01:11:02.760 --> 01:11:06.210
so now the backup so the backup consumes

1213
01:11:06.210 --> 01:11:07.739
the very last log entry that as the

1214
01:11:07.739 --> 01:11:10.199
input is now live so we're not

1215
01:11:10.199 --> 01:11:12.359
responsible for replicating anything at

1216
01:11:12.359 --> 01:11:14.760
this point right because the backup now

1217
01:11:14.760 --> 01:11:16.979
live there's no other replica as the

1218
01:11:16.979 --> 01:11:20.399
primary died so there's no like if if we

1219
01:11:20.399 --> 01:11:23.460
don't if the backup fails to execute in

1220
01:11:23.460 --> 01:11:24.930
log step with the primary that's fine

1221
01:11:24.930 --> 01:11:26.550
actually because the primary is is dead

1222
01:11:26.550 --> 01:11:28.380
and we do not want to execute in

1223
01:11:28.380 --> 01:11:30.510
log step with it okay so the primer is

1224
01:11:30.510 --> 01:11:33.689
now not it's live it generates an output

1225
01:11:33.689 --> 01:11:37.500
on this TCP connection that isn't closed

1226
01:11:37.500 --> 01:11:39.899
yet from the backup point of view this

1227
01:11:39.899 --> 01:11:41.789
packet arrives with the client on a TCP

1228
01:11:41.789 --> 01:11:43.140
connection that doesn't exist anymore

1229
01:11:43.140 --> 01:11:45.569
from the clients point of view like no

1230
01:11:45.569 --> 01:11:46.710
big whoopee on the client right he's

1231
01:11:46.710 --> 01:11:48.510
just going to throw away the packet as

1232
01:11:52.319 --> 01:11:54.569
something like a TCP error or whatever

1233
01:11:54.569 --> 01:11:57.479
packet back to the backup and the backup

1234
01:11:57.479 --> 01:11:58.619
does something or other with it but it

1235
01:11:58.619 --> 01:12:00.659
doesn't matter because we're not

1236
01:12:00.659 --> 01:12:02.189
diverging from anything because there's

1237
01:12:02.189 --> 01:12:04.229
no primary to diverge from you can just

1238
01:12:04.229 --> 01:12:08.100
handle a stray we said however it likes

1239
01:12:08.100 --> 01:12:10.470
and what it'll in fact do is basically

1240
01:12:10.470 --> 01:12:14.729
ignore but there's no now the backup has

1241
01:12:14.729 --> 01:12:17.310
gone live there's just no we don't owe

1242
01:12:17.310 --> 01:12:19.640
anybody anything as far as replication

1243
01:12:19.640 --> 01:12:22.640
yeah

1244
01:12:36.270 --> 01:12:39.100
well you can bet since the backups

1245
01:12:39.100 --> 01:12:40.869
memory image is identical to the

1246
01:12:40.869 --> 01:12:42.520
primaries image that they're sending

1247
01:12:42.520 --> 01:12:45.130
packets with the very same source TCP

1248
01:12:45.130 --> 01:12:48.970
number and they're very same everything

1249
01:13:00.699 --> 01:13:03.640
server's don't have IP addresses or for

1250
01:13:03.640 --> 01:13:06.970
our purposes the virtual machines you

1251
01:13:06.970 --> 01:13:08.229
know the primary in the back up virtual

1252
01:13:08.229 --> 01:13:12.930
machines have IP addresses but the the

1253
01:13:12.930 --> 01:13:15.340
physical computer and the vmm are

1254
01:13:15.340 --> 01:13:17.949
transparent to the network it's not

1255
01:13:17.949 --> 01:13:19.479
entirely true but it's basically the

1256
01:13:19.479 --> 01:13:21.970
case that the virtual machine monitor in

1257
01:13:21.970 --> 01:13:23.850
the physical machine don't really have

1258
01:13:23.850 --> 01:13:26.939
identity of their own on the network

1259
01:13:26.939 --> 01:13:29.380
because you can configure that then that

1260
01:13:29.380 --> 01:13:31.659
way instead these they're not you know

1261
01:13:35.170 --> 01:13:36.550
doesn't IP address underneath there an

1262
01:13:36.550 --> 01:13:37.689
address and all this other stuff which

1263
01:13:37.689 --> 01:13:39.250
is identical between the primary in the

1264
01:13:42.970 --> 01:13:44.529
address and Ethernet address and those

1265
01:13:51.760 --> 01:13:54.130
area network it's exactly what we want

1266
01:13:54.130 --> 01:13:55.840
and so I think he doesn't generate

1267
01:13:55.840 --> 01:13:57.489
exactly the same packets that the

1268
01:13:57.489 --> 01:13:59.710
primary would have generated there's

1269
01:13:59.710 --> 01:14:00.760
maybe a little bit of trickery

1270
01:14:00.760 --> 01:14:03.340
you know what the we if this is these

1271
01:14:03.340 --> 01:14:04.630
are actually plugged into an Ethernet

1272
01:14:04.630 --> 01:14:06.729
switch into the physical machines maybe

1273
01:14:06.729 --> 01:14:08.859
it wasn't in two different ports of an

1274
01:14:08.859 --> 01:14:09.970
Ethernet switch and we'd like the

1275
01:14:09.970 --> 01:14:12.479
Ethernet switch to change its mind about

1276
01:14:12.479 --> 01:14:14.529
which of these two machines that

1277
01:14:14.529 --> 01:14:18.789
delivers packets with replicated

1278
01:14:18.789 --> 01:14:20.949
services Ethernet address and so there's

1279
01:14:20.949 --> 01:14:23.710
a little bit of funny business there for

1280
01:14:23.710 --> 01:14:24.909
the most part they're just generating

1281
01:14:24.909 --> 01:14:26.260
identical packets so let me just send

1282
01:14:26.260 --> 01:14:28.500
them out

1283
01:14:29.550 --> 01:14:33.649
okay so another little detail I've been

1284
01:14:33.649 --> 01:14:36.810
glossing over is that I've been assuming

1285
01:14:36.810 --> 01:14:38.970
that the primary just fails or the

1286
01:14:38.970 --> 01:14:41.789
backup just fails that is fail stop

1287
01:14:41.789 --> 01:14:43.319
right but that's not the only option

1288
01:14:43.319 --> 01:14:46.350
another very common situation that has

1289
01:14:46.350 --> 01:14:49.770
to be dealt with is if the two machines

1290
01:14:49.770 --> 01:14:51.390
are still up and running and executing

1291
01:14:51.390 --> 01:14:53.189
but there's something funny happen on

1292
01:14:53.189 --> 01:14:56.640
the network that causes them not to be

1293
01:14:56.640 --> 01:14:58.109
able to talk to each other but to still

1294
01:14:58.109 --> 01:15:01.739
be able to talk to some clients so if

1295
01:15:01.739 --> 01:15:03.510
that happened if the primary backup

1296
01:15:03.510 --> 01:15:05.100
couldn't talk to each other but they

1297
01:15:05.100 --> 01:15:06.329
could still talk to the clients they

1298
01:15:06.329 --> 01:15:07.920
would both think oh the other replicas

1299
01:15:07.920 --> 01:15:10.140
dead I better take over and go live and

1300
01:15:10.140 --> 01:15:12.449
so now we have two machines going live

1301
01:15:12.449 --> 01:15:14.220
with this service and now you know

1302
01:15:14.220 --> 01:15:16.470
they're no longer sending each other log

1303
01:15:16.470 --> 01:15:17.430
events or anything they're just

1304
01:15:17.430 --> 01:15:19.350
diverging maybe they're accepting

1305
01:15:19.350 --> 01:15:21.329
different client inputs and changes are

1306
01:15:21.329 --> 01:15:22.590
stayed in different ways so now we have

1307
01:15:22.590 --> 01:15:24.930
a split brain disaster if we let the

1308
01:15:30.359 --> 01:15:34.229
failure instead of these machines and

1309
01:15:34.229 --> 01:15:36.380
the way that this paper solves it I mean

1310
01:15:36.380 --> 01:15:41.909
is by appealing to an outside authority

1311
01:15:41.909 --> 01:15:44.250
to make the decision about which of the

1312
01:15:44.250 --> 01:15:46.140
primary of the backup is allowed to be

1313
01:15:46.140 --> 01:15:53.340
live and so it they're you know it turns

1314
01:15:53.340 --> 01:15:54.600
out that their storage is actually not

1315
01:15:54.600 --> 01:15:56.699
on local disk this almost doesn't matter

1316
01:15:56.699 --> 01:15:58.979
but their storage is on some external

1317
01:15:58.979 --> 01:16:01.920
disk server and as well as being in this

1318
01:16:01.920 --> 01:16:03.569
server as a like totally separate

1319
01:16:03.569 --> 01:16:05.159
service there's nothing to do with disks

1320
01:16:17.279 --> 01:16:19.859
test and set request to it and there's

1321
01:16:19.859 --> 01:16:21.930
some flag it's keeping in memory and

1322
01:16:21.930 --> 01:16:23.250
it'll set the flag and return what the

1323
01:16:23.250 --> 01:16:25.590
old value was so both primary and backup

1324
01:16:25.590 --> 01:16:28.890
have to sort of acquire this test and

1325
01:16:28.890 --> 01:16:30.449
set flag it's a little bit like a lock

1326
01:16:30.449 --> 01:16:32.640
in order to go live they both may be

1327
01:16:32.640 --> 01:16:34.920
send test and set requests at the same

1328
01:16:34.920 --> 01:16:37.319
time to this test and set server the

1329
01:16:37.319 --> 01:16:39.359
first one gets back a reply that says oh

1330
01:16:39.359 --> 01:16:41.550
the flag used to be zero now it's one

1331
01:16:41.550 --> 01:16:42.310
this

1332
01:16:42.310 --> 01:16:44.739
second request to arrive the response

1333
01:16:47.680 --> 01:16:50.199
your request arrived so so basically

1334
01:16:50.199 --> 01:16:52.720
you're not allowed to be primary and so

1335
01:16:52.720 --> 01:16:55.659
this this test and set server and we can

1336
01:16:55.659 --> 01:16:58.810
think of it as a single machine is the

1337
01:16:58.810 --> 01:17:00.699
arbitrator that decides which of the two

1338
01:17:00.699 --> 01:17:02.739
should go live if they both think the

1339
01:17:02.739 --> 01:17:04.869
other ones dead due to a network

1340
01:17:04.869 --> 01:17:08.920
partition any questions about this

1341
01:17:08.920 --> 01:17:17.829
mechanism you're busted yeah if the test

1342
01:17:17.829 --> 01:17:19.750
and set server should be dead at the

1343
01:17:19.750 --> 01:17:22.960
critical moment when and so actually

1344
01:17:22.960 --> 01:17:24.640
even if there's not a network partition

1345
01:17:24.640 --> 01:17:27.369
under all circumstances in which one or

1346
01:17:27.369 --> 01:17:28.479
the other of these wants to go live

1347
01:17:28.479 --> 01:17:30.279
because it thinks the others dead even

1348
01:17:30.279 --> 01:17:32.500
when the other one really is dead the

1349
01:17:32.500 --> 01:17:33.850
one that wants to collide still has to

1350
01:17:33.850 --> 01:17:35.350
acquire the test and set lock because

1351
01:17:35.350 --> 01:17:39.100
one of like the deep rules of 6.824

1352
01:17:39.100 --> 01:17:43.630
game is that you cannot tell whether or

1353
01:17:43.630 --> 01:17:45.850
another computer is dead or not all you

1354
01:17:45.850 --> 01:17:47.109
know is that you stopped receiving

1355
01:17:47.109 --> 01:17:49.359
packets from it and you don't know

1356
01:17:49.359 --> 01:17:50.500
whether it's because the other computer

1357
01:17:50.500 --> 01:17:53.920
is dead or because something has gone

1358
01:17:53.920 --> 01:17:55.420
wrong with the network between you and

1359
01:17:55.420 --> 01:17:57.340
the other computer so all the backup

1360
01:17:57.340 --> 01:17:59.229
ceases well I've stuck in packets maybe

1361
01:17:59.229 --> 01:18:00.720
the primary is dead maybe it's live

1362
01:18:00.720 --> 01:18:03.670
primary probably sees the same thing so

1363
01:18:03.670 --> 01:18:04.659
if there's a network partition they

1364
01:18:04.659 --> 01:18:05.920
certainly have to ask the Test-and-Set

1365
01:18:05.920 --> 01:18:07.210
server but since they don't know if it's

1366
01:18:07.210 --> 01:18:08.949
a network partition they have to ask the

1367
01:18:08.949 --> 01:18:11.829
test and set server regardless of whether

1368
01:18:11.829 --> 01:18:13.869
it's a partition or not so anytime

1369
01:18:13.869 --> 01:18:15.970
either wants to collide the test and set

1370
01:18:15.970 --> 01:18:17.649
server also has to be alive because they

1371
01:18:17.649 --> 01:18:19.779
always have to acquire this test and set

1372
01:18:19.779 --> 01:18:22.899
lock so the test and set server

1373
01:18:22.899 --> 01:18:24.220
sounds like a single point of failure

1374
01:18:24.220 --> 01:18:26.319
they were trying to build a replicated

1375
01:18:26.319 --> 01:18:29.260
fault tolerant whatever thing but in the

1376
01:18:29.260 --> 01:18:30.819
end you know we can't failover unless

1377
01:18:30.819 --> 01:18:35.739
unless this is alive so that's a bit of

1378
01:18:35.739 --> 01:18:36.270
a bummer

1379
01:18:36.270 --> 01:18:39.520
I'm guessing though I'm making a strong

1380
01:18:39.520 --> 01:18:41.409
guess that the test and set server is

1381
01:18:41.409 --> 01:18:44.590
actually itself a replicated service and

1382
01:18:44.590 --> 01:18:46.840
is fault tolerant right it's almost

1383
01:18:50.770 --> 01:18:53.560
million dollar highly available storage

1384
01:18:53.560 --> 01:18:54.840
system that

1385
01:18:54.840 --> 01:18:56.760
uses enormous amounts of replication

1386
01:18:56.760 --> 01:18:59.250
internally um since the test and set

1387
01:18:59.250 --> 01:19:00.869
thing is on there dis server I'm I'm

1388
01:19:00.869 --> 01:19:03.390
guessing it's replicated too and the

1389
01:19:03.390 --> 01:19:05.220
stuff you'll be doing in lab 2 in lab 3

1390
01:19:05.220 --> 01:19:07.770
is more than powerful enough for you to

1391
01:19:13.100 --> 01:19:13.210
eliminated

