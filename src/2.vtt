WEBVTT

1
00:00:02.500 --> 00:00:07.370
今天我想谈谈 Go 语言
today I'd like to talk about Go which

2
00:00:07.370 --> 00:00:08.990
它真的相当有趣
is interesting especially interesting

3
00:00:08.990 --> 00:00:10.849
在这门课中
for us in this course because course Go

4
00:00:10.849 --> 00:00:12.710
未来的 labs
is the language at the labs you're all

5
00:00:12.710 --> 00:00:14.449
将使用 Go 语言来完成，所以今天我想
going to do the labs in and so I want to

6
00:00:19.280 --> 00:00:22.940
特别是在
the labs and in most particular to

7
00:00:22.940 --> 00:00:26.170
分布式程序中，嗯，首先
distributed programming um first of all

8
00:00:26.170 --> 00:00:29.600
为什么在这门课里我们要使用 Go 语言？
you know it's worth asking why we use go

9
00:00:29.600 --> 00:00:32.179
事实上，我们已经使用过
in this class in fact we could have used

10
00:00:32.179 --> 00:00:33.890
其它风格的编程语言
any one of a number of other system

11
00:00:33.890 --> 00:00:35.899
非常多，比如
style languages plenty languages like

12
00:00:35.899 --> 00:00:38.210
Java, C#, 甚至是 Python
Java or C sharp or even Python that

13
00:00:38.210 --> 00:00:40.729
这些语言提供了我们需要的工具
provide the kind of facilities we need

14
00:00:40.729 --> 00:00:42.859
我们也在这门课用使用过 C++
and indeed we used to use C++ in this

15
00:00:50.719 --> 00:00:51.649
供你使用
particularly convenient

16
00:00:51.649 --> 00:00:53.409
尤其是在多线程
that's good support for threads and

17
00:00:53.409 --> 00:00:56.659
锁，以及线程间同步上，Go 都做的相当的棒！
locking and synchronization between

18
00:00:56.659 --> 00:00:59.240
未来我们会大量使用这些特性
threads which we use a lot it is a

19
00:00:59.240 --> 00:01:01.789
另外 RPC package(RPC 包)也相当的方便
convenient remote procedure call package

20
00:01:01.789 --> 00:01:04.879
它听起来好像没什么大不了的
which doesn't sound like much but it

21
00:01:04.879 --> 00:01:06.379
但是这在其它诸如 C++ 这样的语言中
actually turns out to be a significant

22
00:01:06.379 --> 00:01:09.950
真的是个很大的包袱，用起来不尽人意
constraint from many languages like C++

23
00:01:09.950 --> 00:01:11.209
比如说，你很难找到一个
for example it's actually a bit hard to

24
00:01:11.209 --> 00:01:13.579
方便好用的 RPC 包
find a convenient easy to use remote

25
00:01:13.579 --> 00:01:14.930
当然了
procedure call package and of course we

26
00:01:14.930 --> 00:01:16.569
在这门课里或是
use it all the time in this course or

27
00:01:16.569 --> 00:01:18.409
程序中，并且在不同的机器上，我们会用它做比较
programs and different machines to talk

28
00:01:18.409 --> 00:01:22.609
不像 C++, Go 是类型安全
to each other unlike C++ go is type safe

29
00:01:27.620 --> 00:01:29.180
它总是或多或少存在和内存相关的 bug
scribbles over some random piece of

30
00:01:29.180 --> 00:01:31.340
然后导致程序产生一些奇奇怪怪的事情
memory and then causes the program to do

31
00:01:31.340 --> 00:01:34.790
然而，Go 的垃圾回收机制
mysterious things and that just

32
00:01:34.790 --> 00:01:36.319
能尽可能的帮我们消灭大量类似的 bug
eliminates a big class of bugs similarly

33
00:01:36.319 --> 00:01:39.680
这意味着
it's garbage collected which means you

34
00:01:39.680 --> 00:01:41.870
你再也不用身处 double free 的危险之中
never in danger of priam the same memory

35
00:01:41.870 --> 00:01:44.510
也不用再为释放正在被使用的内存而担忧
twice or free memory that's still in use

36
00:01:44.510 --> 00:01:46.340
还有一些不用的 vector
or something the garbage vector just

37
00:01:46.340 --> 00:01:48.859
当它不被使用时，也应该要被释放掉
frees things when they stop being used

38
00:01:48.859 --> 00:01:51.920
还有一些看起来不太明显的问题
and one thing it's maybe not obvious

39
00:01:51.920 --> 00:01:54.829
直到你接触
until you played around with just this

40
00:01:54.829 --> 00:01:56.719
这样的程序之前
kind of programming before but the

41
00:01:56.719 --> 00:01:58.640
多线程协同，垃圾回收
combination of threads and garbage

42
00:01:58.640 --> 00:02:01.879
也是相当重要的事情之一
collection is particularly important one

43
00:02:01.879 --> 00:02:03.200
在非垃圾回收型语言中
of the things that goes wrong in a non

44
00:02:03.200 --> 00:02:06.109
这些都很容易出错，比如 C++
garbage collected language like C++ if

45
00:02:06.109 --> 00:02:08.900
如果你使用它(C++)编写多线程程序
you use threads is that it's always a

46
00:02:08.900 --> 00:02:10.689
它总会出现一些让人迷惑的的问题
bit of a puzzle and requires a bunch of

47
00:02:10.689 --> 00:02:13.430
这要求你需要一大本草稿本帮助你去理解
bookkeeping to figure out when the last

48
00:02:13.430 --> 00:02:14.189
什么时候最后一个线程
thread

49
00:02:14.189 --> 00:02:15.659
不在使用共享对象
that's using a shared object has

50
00:02:15.659 --> 00:02:17.340
因为只有
finished using that object because only

51
00:02:17.340 --> 00:02:19.530
在这个时候，你才能释放对象
then can you free the object and so you end

52
00:02:19.530 --> 00:02:20.909
所以最终你会写很多代码
up writing quite a bit of code just like

53
00:02:20.909 --> 00:02:22.620
就像许多程序员会
many of the programmer writes about a

54
00:02:22.620 --> 00:02:24.479
自己动手写一堆代码那样
bunch of code manually. you know do

55
00:02:24.479 --> 00:02:26.580
你知道可以实现类似引用计数这样的功能
reference counting or something in order

56
00:02:26.580 --> 00:02:28.469
来解决它，你也知道
to figure out you know when the last

57
00:02:32.460 --> 00:02:34.710
如果有垃圾回收，这些问题都将不复存在
completely goes away if you use garbage

58
00:02:34.710 --> 00:02:36.560
比如在 Go 语言中
collection like we have in go

59
00:02:36.560 --> 00:02:39.389
最后一点，这门语言比 C++ 要简单的多。
and finally the language is simple much

60
00:02:39.389 --> 00:02:41.460
使用 C++ 的麻烦的问题之一，比如
simpler than C++ one of the problems

61
00:02:41.460 --> 00:02:44.639
你可能只是一个拼写错误
with using C++ is that often if you made

62
00:02:44.639 --> 00:02:47.250
它就可能导致编译器
an error you know maybe even just a typo

63
00:02:47.250 --> 00:02:51.419
报出非常复杂的错误信息
the the error message you get back from

64
00:02:51.419 --> 00:02:53.729
在 C++ 里
the compiler is so complicated that in

65
00:02:53.729 --> 00:02:56.159
尝试去理解这些
C++ it's usually not worth trying to

66
00:02:56.159 --> 00:02:57.509
错误信息不太值得了
figure out what the error message meant

67
00:02:57.509 --> 00:02:59.520
我觉得更好、更快的方法
and I find it's always just much quicker

68
00:02:59.520 --> 00:03:01.469
就是去看看出错的那一行代码
to go look at the line number and try to

69
00:03:01.469 --> 00:03:02.669
尝试去猜测它到底是什么错误
guess what the error must have been

70
00:03:02.669 --> 00:03:04.800
因为这门语言真是太复杂了
because the language is far too complicated

71
00:03:04.800 --> 00:03:07.139
然而 Go，你懂的
whereas go is you know probably doesn't

72
00:03:07.139 --> 00:03:09.710
它没有许多让人热衷的特性
have a lot of people's favorite features

73
00:03:09.710 --> 00:03:11.580
相对而言它是一门“直接了当”的语言
but it's relatively straightforward

74
00:03:11.580 --> 00:03:14.939
Okay, 所以现在你们
language okay so at this point you're

75
00:03:14.939 --> 00:03:17.250
都应该看看 Go 语言教程
both on the tutorial if you're looking

76
00:03:17.250 --> 00:03:19.289
如果你正在纠结关于这门语言
for sort of you know what to look at

77
00:03:19.289 --> 00:03:21.629
你下一步应该学习什么的时候
next to learn about the language a good

78
00:03:21.629 --> 00:03:23.189
有一个好东西你可以看看
place to look is the document titled

79
00:03:23.189 --> 00:03:25.590
名为《Effective Go》
effective go which you know you can find

80
00:03:25.590 --> 00:03:30.389
你可以通过互联网搜索到这本书
by searching the web

81
00:03:30.389 --> 00:03:33.110
好吧，现在我们谈谈多线程
all right the first thing I want to talk about is threads

82
00:03:33.110 --> 00:03:35.939
在这门课里
the reason why we care a lot about

83
00:03:41.460 --> 00:03:44.370
实现并发的重要工具
be using to manage concurrency in

84
00:03:44.370 --> 00:03:47.340
在分布式程序中
programs and concurrency is a particular

85
00:03:47.340 --> 00:03:49.919
并发相当有意思
interest in distributed programming

86
00:03:49.919 --> 00:03:52.439
比较常见的情况是
because it's often the case that one

87
00:03:52.439 --> 00:03:53.819
一个程序需要同时
program actually needs to talk to a

88
00:03:53.819 --> 00:03:55.889
和多台计算机通信
bunch of other computers you know client

89
00:03:55.889 --> 00:03:58.229
客户端可能会同时和多台服务器通信
may talk to many servers or a server may

90
00:03:58.229 --> 00:04:00.300
一台服务器可能会同时响应
be serving requests at the same time on

91
00:04:00.300 --> 00:04:02.430
来自不同客户端的多条请求
behalf of many different clients and so

92
00:04:02.430 --> 00:04:04.830
我们需要一种方式来解释
we need a way to say oh you know I'm my

93
00:04:07.409 --> 00:04:10.110
客户端在通信
seven different clients and I want a

94
00:04:10.110 --> 00:04:12.449
我想要一种简单的方式
simple way to allow it to do these seven

95
00:04:12.449 --> 00:04:14.460
实现它能同时做 7 件不同的事情
different things you know without too

96
00:04:14.460 --> 00:04:16.860
我不需要做太复杂的编程
much complex programming I mean sort of

97
00:04:16.860 --> 00:04:19.589
线程就能很好的解决它
thrust threads are the answer so these

98
00:04:19.589 --> 00:04:21.629
在 Go 的文档中
are the things that the go documentation

99
00:04:21.629 --> 00:04:24.420
它把线程称为 goroutine
calls go routines which I call threads

100
00:04:24.420 --> 00:04:26.790
goroutine 真的很像
the go routines are really this same

101
00:04:26.790 --> 00:04:27.879
大家所说的线程
as what everybody else calls threads

102
00:04:27.879 --> 00:04:32.560
你可以这样来思考线程
so the way to think of threads is

103
00:04:32.560 --> 00:04:36.600
你有一个程序
that you have a program，one program

104
00:04:36.600 --> 00:04:43.120
有一个地址空间，让我来画个小盒子
and one address space I'm gonna draw a

105
00:04:48.250 --> 00:04:51.519
串行执行的程序是没有多个线程的
serial program without threads you just

106
00:04:51.519 --> 00:04:54.550
你只有一个线程
have one thread of execution executing

107
00:05:04.180 --> 00:05:06.160
在一个多线程程序中，比方说 Go 程序
in a threaded program like a go program you could have

108
00:05:06.160 --> 00:05:09.189
你可以拥有多个线程，
multiple threads and you know I got raw

109
00:05:09.189 --> 00:05:10.870
我来画些弯弯的线条来表示它
it as multiple squiggly lines and when

110
00:05:10.870 --> 00:05:13.480
每条线之间都是分开的
each line represents really is a

111
00:05:13.480 --> 00:05:16.120
尤其是
separate if the especially if the

112
00:05:16.120 --> 00:05:17.439
如果这些线程同时执行
threads are executing at the same time

113
00:05:17.439 --> 00:05:19.629
那它们就分别有一个属于自己的程序计数器
but a separate program counter a

114
00:05:19.629 --> 00:05:21.550
一套寄存器和一个栈
separate set of registers and a separate

115
00:05:21.550 --> 00:05:24.220
是的，每个线程都有自己的一套东西
stack for each of the threads so that

116
00:05:24.220 --> 00:05:26.230
自己的一套线程控制
they can have a sort of their own thread

117
00:05:26.230 --> 00:05:28.329
他们可以在程序中不同的部分
of control and be executing each thread

118
00:05:28.329 --> 00:05:31.810
执行每个线程
in a different part of the program and

119
00:05:31.810 --> 00:05:33.310
有一个不太让人注意的细节
so hidden here is that for every stack

120
00:05:33.310 --> 00:05:35.529
每一个独立的线程都有一个栈
there's a seprate thread there's a

121
00:05:35.529 --> 00:05:41.170
线程会在这些栈上执行
stack that it's executing on

122
00:05:41.170 --> 00:05:44.529
这些栈都在程序中的同一个地址空间里
the stacks are actually in in the one address space

123
00:05:44.529 --> 00:05:46.720
所以，即使
of the program so even though each stack

124
00:05:46.720 --> 00:05:47.860
每个线程都有它自己的栈
each thread has its own stack

125
00:05:47.860 --> 00:05:51.220
严格来讲他们都在同一地址空间中
technically the they're all in the same

126
00:05:51.220 --> 00:05:52.240
如果知道正确的地址的话
address space and different threads

127
00:05:52.240 --> 00:05:53.800
不同的线程之间
could refer to each other stacks if they

128
00:05:53.800 --> 00:05:55.959
是可以互相访问的他们的栈的
knew the right addresses

129
00:06:01.509 --> 00:06:02.889
当你首次启动程序时
you first start up the program and it

130
00:06:02.889 --> 00:06:05.110
它会在 main 函数中运行
runs in main that's also it's just a go

131
00:06:05.110 --> 00:06:06.490
它就是一个 goroutine，然后做完所有的事情
routine and can do all the things that goroutine can do

132
00:06:06.490 --> 00:06:14.439
好啦
all right so as I

133
00:06:14.439 --> 00:06:17.850
我想说的最重要的原因
mentioned one of the big reasons is

134
00:06:17.850 --> 00:06:21.730
就是允许程序中不同的部分
to allow different parts of the program to

135
00:06:27.550 --> 00:06:31.509
我常常说 IO 并发是出于历史原因
that as IO concurrency for historical

136
00:06:31.509 --> 00:06:36.579
称之为 IO 并发
reasons and the reason I call it IO

137
00:06:39.579 --> 00:06:41.259
你可能有一个线程
oh you might have one thread that's waiting to

138
00:06:41.259 --> 00:06:43.240
正在等待从磁盘上读数据
read from the disk and while it's waiting to

139
00:06:43.240 --> 00:06:44.410
当它在等待的时候，你又想要
reach from the disk you'd like to have a

140
00:06:44.410 --> 00:06:46.329
另一个线程，可能用来做计算或是
second thread that maybe can compute or

141
00:06:50.560 --> 00:06:54.490
所以 IO 并发
and so I/O concurrency is one of

142
00:06:54.490 --> 00:06:57.250
也是你使用多线程的地方之一
the things that threads by you for us it

143
00:06:57.250 --> 00:07:00.189
比如说
would usually mean I can I/O concurrency

144
00:07:00.189 --> 00:07:01.689
我们有一个程序
we usually mean I can have one program

145
00:07:08.139 --> 00:07:10.569
这就是我们要解决的问题
that's how it'll come up for us

146
00:07:18.790 --> 00:07:21.189
每个线程
you wanted to launch that thread would have code

147
00:07:21.189 --> 00:07:26.379
都会通过 RPC 发送 request 消息
that you know sent the remote procedure call request message

148
00:07:26.379 --> 00:07:27.819
然后在这个位置等待
and sort of waited at this point in the thread

149
00:07:27.819 --> 00:07:29.319
当响应回复时
and then finally when the reply came

150
00:07:29.319 --> 00:07:31.329
这个线程将会继续执行
back the thread would continue executing

151
00:07:31.329 --> 00:07:33.220
使用多线程
and using threads allows us to have

152
00:07:33.220 --> 00:07:36.250
可以让我们同时发起多个网络请求
multiple threads that all launch requests into the network at the same time

153
00:07:36.250 --> 00:07:38.439
所有线程都会等待回复
they all wait or they don't have to

154
00:07:38.439 --> 00:07:40.689
也不是非得在同一时间去发请求
do it at the same time they can you know

155
00:08:00.329 --> 00:08:08.680
我就写并行化吧
which I'll just call parallelism

156
00:08:08.680 --> 00:08:10.269
我们想通过线程来达到并行化的目的
and here the thing where we'd be trying to achieve with threads

157
00:08:10.269 --> 00:08:11.889
并行化就是如果你有个多核机器
is if you have a multi-core

158
00:08:11.889 --> 00:08:13.540
我确定你们每个人都能用你自己的电脑做到
machine like I'm sure all of you do in

159
00:08:13.540 --> 00:08:15.759
如果你有一个计算繁重的工作
your laptops if you have a sort of

160
00:08:15.759 --> 00:08:17.470
它需要消耗许多 CPU 时钟
compute heavy job that needs a lot of

161
00:08:17.470 --> 00:08:19.149
这不是太好
CPU cycles wouldn't it be nice if you

162
00:08:23.860 --> 00:08:27.579
比方说它是用 Go 写的多线程程序
machine and indeed if you write a multi-threaded go

163
00:08:31.569 --> 00:08:33.940
比如一直在那执行一个循环，计算 pi（圆周率)的值
loop and you know compute digits of pi

164
00:08:33.940 --> 00:08:38.519
直到达到机器上 cpu 核的极限
or something then up to the limit of the number of cores in the physical machine

165
00:08:38.519 --> 00:08:41.259
你的线程将会真正的以并行的方式运行
your threads will run truly in parallel

166
00:08:41.259 --> 00:08:43.690
如果你启动 2 个线程代替 1 个线程
and if you launch you know two threads

167
00:08:43.690 --> 00:08:45.750
你就能获得 2 倍的性能
instead of one you'll get twice as many

168
00:08:45.750 --> 00:08:48.370
就能使用 2 倍数量的 CPU 核时钟
you'll be able to use twice as many CPU cycles per second

169
00:08:53.169 --> 00:08:54.740
这其实没什么大不了的
deal on this course

170
00:08:54.740 --> 00:08:57.440
我们并不会把多过精力
be... it's rare that we'll sort of think

171
00:08:57.440 --> 00:08:59.480
放在这一类并行化上
specifically about this kind of parallelism

172
00:08:59.480 --> 00:09:01.639
在现实世界中
in the real world though of

173
00:09:01.639 --> 00:09:05.389
我们开发像服务器这样的程序
building things like servers to form

174
00:09:05.389 --> 00:09:06.889
来组成分布式系统的一部分
parts of the distributed systems it can

175
00:09:06.889 --> 00:09:09.769
有时让服务器
sometimes be extremely important to be

176
00:09:09.769 --> 00:09:11.779
能使用多线程
able to have the server be able to run

177
00:09:11.779 --> 00:09:13.549
能使用多核还是非常重要的
threads and harness the CPU power of a

178
00:09:13.549 --> 00:09:15.139
因为往往客户端
lot of cores just because the load from

179
00:09:15.139 --> 00:09:18.740
带给服务器的负载非常高
clients can often be pretty high

180
00:09:18.740 --> 00:09:22.850
okay, 所以并行化是第二个原因
okay so parallelism is a second reason

181
00:09:22.850 --> 00:09:25.309
那么为什么咱们会在分布式系统中
why threads are quite a bit interested in

182
00:09:25.309 --> 00:09:27.169
如此关注多线程呢
distributed systems and a third reason

183
00:09:27.169 --> 00:09:29.539
第三个原因，但也可能不那么重要
which is maybe a little bit less

184
00:09:29.539 --> 00:09:32.779
就是有时候
important is there's some there's times

185
00:09:32.779 --> 00:09:38.629
你只是想在后台做一些事情
when you really just want to be able to do something in the background

186
00:09:38.629 --> 00:09:42.769
比如你就想周期性的去执行它
or you know there's just something you need to do periodically

187
00:09:42.769 --> 00:09:45.259
但你又不愿意在主线程
and you don't want to have to sort of in the main part of your

188
00:09:45.259 --> 00:09:47.419
插入一些检查
program sort of insert checks to say

189
00:09:47.419 --> 00:09:49.190
比如我要做的那个动作
well should I be doing this things that

190
00:09:52.370 --> 00:09:54.379
每秒都能做
up that every second does whatever the

191
00:10:00.500 --> 00:10:03.379
这里有个例子
and an example which will come up for you

192
00:10:03.379 --> 00:10:05.210
也是经常会遇到的情况
is it's often the case

193
00:10:05.210 --> 00:10:07.250
比如有一个 master 服务需要
that some you know a master server may want to

194
00:10:07.250 --> 00:10:09.350
周期性的检查它的 worker 服务是否一直存活
check periodically whether its workers are still alive because one

195
00:10:09.350 --> 00:10:10.580
因为这些 worker 之一宕机的话
of them is died you know you want to

196
00:10:10.580 --> 00:10:12.169
就需要把工作扔到另一台机器上去执行
launch that work on another machine like

197
00:10:12.169 --> 00:10:14.539
就像 MapReduce 那样
MapReduce might do that and one way to

198
00:10:14.539 --> 00:10:17.419
你可以每秒、每分钟
arrange sort of oh do this check every

199
00:10:17.419 --> 00:10:21.679
通过发送一条“你还活着吗？”这样的消息到 worker 服务上
second every minute you know send a message to the worker are you alive is

200
00:10:21.679 --> 00:10:24.169
你能启动一个 goroutine
to fire off a go routine that just sits

201
00:10:24.169 --> 00:10:25.700
然后执行一个死循环，sleep 1 秒后
in a loop that sleeps for a second and

202
00:10:25.700 --> 00:10:26.990
然后做需要周期执行的动作
then does the periodic thing and then

203
00:10:26.990 --> 00:10:28.700
然后又 sleep 1 秒
sleeps for a second again and so in the

204
00:10:28.700 --> 00:10:31.399
在后面的 lab 里，你最后将会创建这样的线程
labs you'll end up firing off these kind of threads quite a bit

205
00:10:31.399 --> 00:10:36.559
（提问...猜测是开启 goroutine 开销的问题）
yes is the

206
00:10:36.559 --> 00:10:42.470
这个开销是值得的，是的，这个开销
overhead worth it yes the overhead is

207
00:10:42.470 --> 00:10:44.840
真的非常少
really pretty small for this stuff I

208
00:10:44.840 --> 00:10:46.700
这依赖于你创建多少线程
mean you know it depends on how many you

209
00:10:46.700 --> 00:10:50.149
但是如果你创建了 100 万个线程
create a million threads that he sit in

210
00:10:53.960 --> 00:10:56.330
这可能会给你的机器带来巨大的负载
probably a huge load on your machine but

211
00:10:56.330 --> 00:10:59.200
如果你就创建了 10 个线程的话
if you create you know ten threads that

212
00:10:59.200 --> 00:11:01.399
sleep 1 秒，然后做一点点工作
sleep for a second and do a little bit

213
00:11:01.399 --> 00:11:04.850
这真的没什么大不了的
of work it's probably not a big deal at all

214
00:11:13.980 --> 00:11:16.200
功能搞到一起
together they're different different

215
00:11:16.200 --> 00:11:19.320
放在一行代码里
activities into one line of code it's

216
00:11:19.320 --> 00:11:21.450
它只会消耗一点点 CPU
it's worth the small amount of CPU cost almost always

217
00:11:21.450 --> 00:11:26.159
如果很不幸
still you know you will if

218
00:11:26.159 --> 00:11:27.600
你在 Labs 发现
you're unlucky you'll discover in the

219
00:11:27.600 --> 00:11:30.450
有些循环 sleep 的时间不够长
labs that some loop of yours is not

220
00:11:30.450 --> 00:11:32.519
或者是创建了大量的 goroutine
sleeping long enough or are you fired

221
00:11:32.519 --> 00:11:35.730
也从未让他们退出
off a bunch of these and never made them

222
00:11:35.730 --> 00:11:37.590
这样 goroutine 就会越来越多
exit for example and they just

223
00:11:37.590 --> 00:11:41.330
甚至是你做的更过火
accumulate so you can push it too far

224
00:11:41.330 --> 00:11:43.679
okay，所以这些原因
okay so these are the reasons that the

225
00:11:43.679 --> 00:11:46.409
是人们喜欢线程的主要原因
main reasons that people like threads a

226
00:11:46.409 --> 00:11:47.730
也是我们在这门课里使用多线程的原因
lot and that will use threads in this

227
00:11:47.730 --> 00:11:50.370
关于线程大家还有什么问题吗？
class any other questions about threads

228
00:11:50.370 --> 00:12:01.860
（提问：...）通过异步编程
in general by asynchronous program you

229
00:12:01.860 --> 00:12:03.570
你的意思是通过单线程
mean like a single thread of control

230
00:12:03.570 --> 00:12:06.779
来追踪不同活动的状态是吗？
that keeps state about many different

231
00:12:06.779 --> 00:12:09.509
yeah，这真的是个好问题
activities yeah so this is a good question actually

232
00:12:09.509 --> 00:12:13.440
如果不使用多线程会怎样？
there is you know what would happen if we didn't have threads

233
00:12:16.799 --> 00:12:21.210
你知道服务器
that could you know a server

234
00:12:21.210 --> 00:12:23.340
能够同时与不同客户端通信
that could talk to many different clients at the same time

235
00:12:23.340 --> 00:12:24.509
或是客户端能同时与多个服务器通信
or a client that could talk to many servers right

236
00:12:24.509 --> 00:12:26.100
这时候应该使用什么样的工具？
what what tools could be used and it

237
00:12:42.529 --> 00:12:45.899
你可以使用事件驱动编程
so sort of or you could use event-driven

238
00:12:45.899 --> 00:12:52.710
事件驱动编程的一般结构
programming and the the general structure of an event-driven program is

239
00:12:52.710 --> 00:12:54.419
通常它有一个线程
usually that it has a single thread and

240
00:12:54.419 --> 00:12:57.379
同时有一个循环
a single loop and what that loop does is

241
00:12:57.379 --> 00:13:01.379
这个循环等待输入
sits there and waits for any input or

242
00:13:01.379 --> 00:13:03.779
或者是其它任何事件
sort of any event that might trigger

243
00:13:03.779 --> 00:13:05.700
这些事件能触发程序继续进行
processing so an event might be the

244
00:13:05.700 --> 00:13:07.799
事件可能是一个来自客户端的请求
arrival of a request from a client or a

245
00:13:07.799 --> 00:13:10.889
可能是定时器到期，如果你在编写
timer going off or if you're building a

246
00:13:10.889 --> 00:13:12.629
windows 系统程序
Windows System, many Windows

247
00:13:12.629 --> 00:13:14.190
你电脑上的许多 windows 系统程序
systems on your laptops I've driven

248
00:13:17.639 --> 00:13:18.340
或者是鼠标移动这样的事件
or Mouse move

249
00:13:18.340 --> 00:13:20.259
因此你可能会有一个单一的
or something so you might have a single

250
00:13:20.259 --> 00:13:21.549
只有一个控制线程的程序
an event-driven programing of a

251
00:13:21.549 --> 00:13:23.350
这个线程有一个循环一直等待输入
single thread of control sits a loop

252
00:13:23.350 --> 00:13:25.269
无论何时有输入进来
waits for input and whenever it gets an

253
00:13:25.269 --> 00:13:27.159
比如收到报文，它能够找出来
input like a packet it figures out oh

254
00:13:27.159 --> 00:13:28.750
是哪个客户端发送的这个报文
you know which client did this packet

255
00:13:28.750 --> 00:13:31.539
它有一张表格
come from and then it'll have a table of

256
00:13:31.539 --> 00:13:38.200
记录这个客户端到底处于什么样的活动状态
sort of what the state is of whatever activity its managing for that client

257
00:13:38.200 --> 00:13:40.509
比如说，oh 上帝，
and it'll say oh gosh I was in the

258
00:13:40.509 --> 00:13:42.220
我现在处于“读”某个文件的状态
middle of reading such-and-such a file

259
00:13:42.220 --> 00:13:44.110
那么它就会要求我去读下一个数据块
you know now it's asked me to read the

260
00:13:44.110 --> 00:13:45.850
然后我就会去读取下一个数据块然后返回
next block I'll go and be the next block

261
00:13:45.850 --> 00:13:55.480
使用线程的话
and return it and threads are generally

262
00:13:55.480 --> 00:13:57.250
通常会变的更加方便
more convenient because they allow you

263
00:14:03.610 --> 00:14:05.649
计算，然后发送消息，然后等待响应
computes sends a message waits for

264
00:14:23.379 --> 00:14:29.110
这种编程模式的问题在于
that said they are and so one problem with

265
00:14:29.110 --> 00:14:32.889
它实现起来有点痛苦
the scheme is that it's it's a little bit of a pain to program

266
00:14:32.889 --> 00:14:34.659
另一个潜在的缺陷
another potential defect is that while you get

267
00:14:34.659 --> 00:14:36.639
当你用这种方法获取了 IO 并发后
io concurrency from this approach you

268
00:14:36.639 --> 00:14:38.769
你就没法利用 CPU 的并行化机制
don't get CPU parallelism so if you're

269
00:14:38.769 --> 00:14:39.909
所以当你写一个负载很高的服务
writing a busy server that would really

270
00:14:39.909 --> 00:14:42.730
你得相方设法把一台大型机器的 32 核都用上
like to keep you know 32 cores busy on a big server machine

271
00:14:42.730 --> 00:14:49.149
使用一个单一循环的话，你知道，它相当的不自然
you know a single loop is you know it's it's not a very

272
00:14:49.149 --> 00:14:50.620
也很难获得多核的性能
natural way to harness more than one core

273
00:14:56.620 --> 00:14:59.259
通常换来的性能提升相比多线程来说并不会太多
quite a bit less than threads you know

274
00:14:59.259 --> 00:15:01.659
而且线程相对来说也很廉价
threads are pretty cheap but each one of

275
00:15:01.659 --> 00:15:05.379
但是每个线程都有一个栈
these threads is sitting on a stack you

276
00:15:05.379 --> 00:15:07.330
栈通常是 1kb 或数千字节
know stack is a kilobyte or a kilobytes

277
00:15:07.330 --> 00:15:09.460
如果你有 20 个线程
or something you know if you have 20 of

278
00:15:09.460 --> 00:15:10.960
这些消耗根本不用在意
these threads who cares if you have a

279
00:15:10.960 --> 00:15:12.970
但是你若有 100 万个线程
million of these threads then it's

280
00:15:17.769 --> 00:15:20.980
它是指下一步应该选择哪个线程运行
bookkeeping for deciding what the thread to run next might also start you know

281
00:15:20.980 --> 00:15:25.899
通常有一个调度列表，上面记录了 1000 个线程
you now have list scheduling lists with a thousand threads in them

282
00:15:25.899 --> 00:15:28.419
这时候切换线程执行将付出相当昂贵的代价
the threads can start to get quite expensive so if

283
00:15:28.419 --> 00:15:30.519
所以，当你只有一个服务器的时候
you are in a position where you need to

284
00:15:30.519 --> 00:15:33.519
你的服务器需要为 100 万个客户端提供服务
have a single server that serves you know a million clients

285
00:15:33.519 --> 00:15:37.919
你需要为这 100 万个客户端记录一些状态
and has to sort of keep a little bit of state for each of a million clients

286
00:15:37.919 --> 00:15:39.370
这个代价还是挺高的
this could be expensive

287
00:15:47.440 --> 00:15:50.559
一个简单的而又五脏俱全高性能的服务
efficient low overhead service in event-driven programming

288
00:15:50.559 --> 00:15:51.940
就是你需要多做点工作
just a lot more work

289
00:15:51.940 --> 00:16:15.389
你是问我 JavaScript 吗？
are you asking my JavaScript I

290
00:16:20.950 --> 00:16:25.870
有人知道吗? 这得取决于具体实现
your does anybody know depends on the implementation

291
00:16:25.870 --> 00:16:27.250
yeah，不过我确实不太清楚这个
yeah so I don't know

292
00:16:27.250 --> 00:16:29.230
有个很自然的想法
I mean it's a natural thought though even

293
00:16:29.230 --> 00:16:31.570
即使是在 Go 中
in you know even in Go you might well

294
00:16:31.570 --> 00:16:33.399
假设你知道你的机器有 8 个核
want to have if you knew your machine

295
00:16:33.399 --> 00:16:35.169
你想写一个世界上最高效的 server
had eight cores if you wanted to write

296
00:16:35.169 --> 00:16:39.490
你可能就会启动 8 个线程
the world's most efficient whatever server you could fire up eight threads

297
00:16:39.490 --> 00:16:47.350
每个线程上运行一个精简的事件驱动循环
and on each of the threads run sort of stripped-down event-driven loop

298
00:16:47.350 --> 00:16:49.659
一个循环一个核
just you know sort of one event loop per core and

299
00:16:49.659 --> 00:16:54.700
对于 IO 并发来说，这是一种获得并行化的方式
that you know that would be a way to get both parallelism and to the I/O concurrency concurrency

300
00:16:54.700 --> 00:16:59.159
(提问)
yes

301
00:17:07.950 --> 00:17:11.190
通常，对于类 UNIX 系统的机器来说
so usually on a like a UNIX machine a

302
00:17:11.190 --> 00:17:14.880
一个进程就是一个单独运行的程序
process is a single program that you're

303
00:17:14.880 --> 00:17:16.650
只有一个地址空间
running and a sort of single address

304
00:17:16.650 --> 00:17:18.690
一大片可供进程使用的内存
space a single bunch of memory for the

305
00:17:18.690 --> 00:17:22.109
在这个进程里你可能同时会有好多个线程
process and inside a process you might have multiple threads

306
00:17:22.109 --> 00:17:25.289
当你准备好一个 go 程序并运行
and when you ready a go program and you run the go program

307
00:17:25.289 --> 00:17:31.890
将会创建一个 unix 进程和一块内存区
running the go program creates one unix process and one sort of memory area

308
00:17:31.890 --> 00:17:35.880
当你的 Go 进程创建 goroutine 时
and then when your go process creates go

309
00:17:35.880 --> 00:17:37.380
它们实际上都是在同一个进程里的
routines those are so sitting inside that one process

310
00:17:37.380 --> 00:17:42.990
我不太确定真实的答案是不是这样
so I'm not sure that's really an answer but just historically

311
00:17:42.990 --> 00:17:45.359
但历史上，操作系统都提供了像这样的大盒子
the operating systems have provided like

312
00:17:45.359 --> 00:17:47.490
它就是个进程
this big box is the process that's

313
00:17:47.490 --> 00:17:49.579
实际上这也取决于操作系统的实现
implemented by the operating system and

314
00:17:53.940 --> 00:17:56.549
也不关心你使用什么语言
your process what language you use none

315
00:17:56.549 --> 00:17:59.130
不关心操作系统内部的业务逻辑
of the operating systems business but

316
00:17:59.130 --> 00:18:00.809
在进程内部能运行多个线程就行了
inside that process you can run lots of

317
00:18:00.809 --> 00:18:06.630
好，如果在你的机器上运行了不止一个进程
threads now you know if you run more than one process in your machine you know you run more than one program

318
00:18:06.630 --> 00:18:09.569
比如一个编辑器或是编译器
like an editor or compiler

319
00:18:09.569 --> 00:18:12.359
操作系统需要让它们彼此分开
the operating system keep quite separate

320
00:18:12.359 --> 00:18:13.619
你的编辑器和你的编译器
right you're your editor and your compiler each have

321
00:18:13.619 --> 00:18:15.690
都有自己的内存空间
memory but it's not the same memory that

322
00:18:15.690 --> 00:18:16.829
他们之间无法看到彼此的内存
are not allowed to look at each other

323
00:18:27.480 --> 00:18:29.190
但是在同一个进程中，线程与线程之间可以共享内存
one program the threads can share memory

324
00:18:29.190 --> 00:18:31.890
可以使用 channel(Go语言中的概念) 进行同步
and can synchronize with channels and

325
00:18:31.890 --> 00:18:33.720
也可以使用 mutex 等
use mutexes etc. but between

326
00:18:33.720 --> 00:18:38.240
但进程之间是没有交集的
processes there's just no no interaction

327
00:18:38.240 --> 00:18:45.509
这类软件的传统结构就是这样
that's just a traditional structure of these this kind of software

328
00:18:45.509 --> 00:18:48.509
(提问)
yeah

329
00:19:10.420 --> 00:19:12.579
你只有一个单核机器
single core machine that's really only

330
00:19:12.579 --> 00:19:14.529
这意味着在同一个时刻你只能做一件事情
running and as just doing one thing at a

331
00:19:14.529 --> 00:19:19.900
你这样想
time maybe the right way to think about

332
00:19:19.900 --> 00:19:22.960
你打算在你的机器上运行多进程
it is that you're going to be you're running multiple processes on your machine

333
00:19:22.960 --> 00:19:27.519
操作系统把 CPU 时间片
the operating system will give

334
00:19:27.519 --> 00:19:33.430
反复的分配给这两个程序
the CPU sort of time slicing back and forth between these two programs

335
00:19:33.430 --> 00:19:35.950
当硬件时钟到期时
so when the hardware timer ticks and the

336
00:19:35.950 --> 00:19:38.950
操作系统就判断是时候把 CPU 从当前正在运行的进程剥夺
operating systems decides it's time to take away the CPU from the currently running process

337
00:19:38.950 --> 00:19:40.480
然后把 CPU 分配给另一个进程
and give it to another

338
00:19:40.480 --> 00:19:44.700
这件事件是在进程级别上做的
process that's done at a process level

339
00:19:48.599 --> 00:19:52.329
这有点复杂，好
it's complicated all right let me let me

340
00:19:52.329 --> 00:19:55.240
让我们重新再思考这个问题
let me restart this these the threads

341
00:20:03.910 --> 00:20:06.519
操作系统是知道这一切的
the threads that it knows about so in a

342
00:20:06.519 --> 00:20:08.619
所以操作系统可能会清楚
situation like this the operating system

343
00:20:08.619 --> 00:20:11.559
这儿有两个线程在这个进程中，有三个线程在那个进程
might know that there are two threads here in this process and three threads in this process

344
00:20:11.559 --> 00:20:13.599
当时钟到期时
and when the timer ticks

345
00:20:13.599 --> 00:20:16.869
操作系统会基于一些调度算法选择一个不同的线程来运行
the operating system will based on some scheduling algorithm pick a different thread thread to run

346
00:20:16.869 --> 00:20:18.730
在这个进程中的线程和另一进程中的线程可能是不同的
it might be a different thread in this process or one of the threads in this process

347
00:20:22.269 --> 00:20:25.690
另外，Go 会聪明复用一个操作系统线程
in addition go cleverly multiplex as

348
00:20:25.690 --> 00:20:29.859
在上面运行尽可能多的 goroutine 以节省开支
many go routines on top of single operating system threads to reduce overhead

349
00:20:29.859 --> 00:20:32.589
所以这可能需要两个阶段去调度
so it's really probably a two

350
00:20:32.589 --> 00:20:34.480
首先操作系统选择一个线程去运行
stages of scheduling the operating system picks which big thread to run

351
00:20:34.480 --> 00:20:45.819
然后在这个进程中，Go 会再去选择哪个 goroutine 去运行
and then within that process go may have a choice of go routines to run

352
00:20:45.819 --> 00:20:53.410
好啦，线程真的很方便
all right okay so threads are convenient

353
00:20:53.410 --> 00:20:55.920
大多数时候，使用它
because a lot of times they allow you to write the code for each thread

354
00:20:59.920 --> 00:21:15.150
然而，事实上写多线程程序是有些挑战的
however there are in fact some challenges with writing threaded code

355
00:21:15.150 --> 00:21:17.680
其中一个是共享数据
one is what to do about shared data one

356
00:21:22.359 --> 00:21:24.309
如果某个线程在内存中创建了一个对象
if one thread creates an object

357
00:21:24.309 --> 00:21:26.920
在其它线程中你也能使用它
in memory you can let other threads use

358
00:21:26.920 --> 00:21:29.140
你可以创建个数组或是别的什么东西
it right you can have a array or

359
00:21:29.140 --> 00:21:31.420
所有不同的线程都能读写
something that all the different threads are reading and writing and that

360
00:21:31.420 --> 00:21:33.880
这就存在一些临界情况
sometimes critical right if you you know

361
00:21:40.839 --> 00:21:42.309
首先它会先查一下缓存中的数据
client request it's gonna first look in

362
00:21:42.309 --> 00:21:43.809
但是这个共享缓存，每个线程都能读
that cache but the shared cache and each

363
00:21:43.809 --> 00:21:45.809
当线程里有新的信息时
thread reads it and the threads may write the cache to update it

364
00:21:45.809 --> 00:21:49.180
线程可能会向缓存里写入数据进行更新
when they have new information to stick in the cache

365
00:21:49.180 --> 00:21:51.220
所以这真的很厉害
so it's really cool you can share

366
00:21:51.220 --> 00:21:55.210
你可以共享内存
that memory but it turns out that it's

367
00:21:55.210 --> 00:21:57.970
但是事实也表明这也非常容易出现 bug
very very easy to get bugs if you're not

368
00:21:57.970 --> 00:21:59.740
如果你不关心多线程之间共享内存的话
careful and you're sharing memory between threads

369
00:21:59.740 --> 00:22:05.529
有个经典的例子
so a totally classic example is you know supposing your

370
00:22:05.529 --> 00:22:07.630
假设你有一个全局变量 N
thread so you have a global variable N

371
00:22:07.630 --> 00:22:09.670
在不同的线程之间共享
and that's shared among the different

372
00:22:09.670 --> 00:22:11.440
其中一个线程只是对 N 做自增
threads and a thread just wants to

373
00:22:11.440 --> 00:22:20.710
这可能就是造成 bug 的原因
increment n right but itself this is likely to be an invitation to bugs right

374
00:22:20.710 --> 00:22:22.240
如果你不做一些特殊处理的话
if you don't do anything special around this code

375
00:22:22.240 --> 00:22:25.119
为什么？
and the reason is that you

376
00:22:25.119 --> 00:22:31.900
无论何时你在多线程中读写共享数据
know whenever you write code in a thread that you you know is accessing reading or writing data that's shared with other

377
00:22:31.900 --> 00:22:33.670
总是存在一种可能性
threads you know there's always the

378
00:22:33.670 --> 00:22:35.259
你得牢记
possibility and you got to keep in mind

379
00:22:35.259 --> 00:22:37.549
在同一时刻，总有其它的线程可能也正在查看
that some other thread may be looking at the data

380
00:22:39.549 --> 00:22:41.740
所以这里有个很明显的问题
so the obvious problem with

381
00:22:41.740 --> 00:22:43.900
看这里，线程 1 正在执行
this is that maybe thread 1 is executing this code and thread 2 is actually

382
00:22:43.900 --> 00:22:50.799
但是另一个不同的线程 2 也在执行相同的代码
in the same function in a different thread executing the very same code

383
00:22:58.269 --> 00:23:01.750
而是由编译器吐出来的机器码
code you're running machine code the compiler produced and

384
00:23:01.750 --> 00:23:03.880
机器码长啥样呢
what that machine code does is it you

385
00:23:03.880 --> 00:23:06.720
首先把 X 载入到一个寄存器里
know it loads X into a register

386
00:23:06.720 --> 00:23:13.210
然后给寄存器的加 1
you know adds one to the register and

387
00:23:13.210 --> 00:23:18.130
接着再把寄存器的值保存到 X
then stores that register into X with

388
00:23:24.339 --> 00:23:25.930
都在执行这行代码
they're both executing this line of code

389
00:23:25.930 --> 00:23:28.720
他们都会执行 load x 到寄存器
you know they both load the variable X

390
00:23:32.470 --> 00:23:33.970
然后他们都给寄存器加 1
they both increment that register so

391
00:23:33.970 --> 00:23:35.619
这样所有线程各有自的寄存器的值是 1
they get one and they both store one

392
00:23:35.619 --> 00:23:37.809
最后再把寄存器的值 1 重新保存到内存里
back to memory and now two threads of

393
00:23:45.490 --> 00:23:47.289
但是碰巧这样写并不正确
the programmer wanted but chances are

394
00:23:47.289 --> 00:23:49.150
碰巧程序想要的结果不是 1
not right chances are the programmer wanted to not 1

395
00:23:49.150 --> 00:24:02.710
(提问...) 有一些指令是原子的
no, some some instructions

396
00:24:02.710 --> 00:24:04.240
这个问题不错
are atomic so the question is a very

397
00:24:04.240 --> 00:24:11.259
这些独立的指令是不是原子的
good question which it's whether individual instructions are atomic

398
00:24:11.259 --> 00:24:13.269
答案是有些是，有些不是
so the answer is some are and some aren't

399
00:24:13.269 --> 00:24:23.440
对于 32 位的 store 指令它极有可能是原子的
so a store a 32-bit store is likely the extremely likely to be atomic

400
00:24:23.440 --> 00:24:25.960
从某种意义上来说，如果有两个处理器
in the sense that if 2 processors store

401
00:24:27.960 --> 00:24:30.170
最终要么是其中一个处理器上的 32 位值
well you'll end up with is either the 32 bits

402
00:24:30.170 --> 00:24:35.170
要么是另一个处理器上的 32 位值
from one processor or the 32 bits from the other processor

403
00:24:35.170 --> 00:24:38.200
而不是一个混合的值
but not a mixture

404
00:24:38.200 --> 00:24:40.450
其它尺寸大小的未必就这么简单
other sizes it's not so clear like one byte stores it depends on

405
00:24:40.450 --> 00:24:41.980
比如一个字节的存储这依赖于你所使用的 CPU
the CPU you using because a one byte

406
00:24:41.980 --> 00:24:44.440
因为 1 字节的存储几乎和 32 字节的 load 差不多
store is really almost certainly a 32

407
00:24:44.440 --> 00:24:47.920
就是 8 bit 的修改，和一个 32 字节的存储
byte load and then a modification of 8 bits and a 32 byte store

408
00:24:47.920 --> 00:24:51.819
这依赖于处理器和更复杂的指令
but it depends on the processor and more complicated instructions

409
00:24:51.819 --> 00:24:55.900
比如微处理器上的自增指令
like increment your microprocessor may well have an increment instruction

410
00:24:55.900 --> 00:25:00.220
它能直接给内存上某个地址的值加 1
that can directly increment some memory location like

411
00:25:00.220 --> 00:25:04.240
未必就是原子的
pretty unlikely to be atomic although

412
00:25:04.240 --> 00:25:07.890
尽管这些指令存在原子版本的
there's atomic versions of some of these instructions

413
00:25:07.890 --> 00:25:16.680
好，咱们继续。所以这是一个非常经典的错误
so there's no. any way all right so this is this is a just classic danger

414
00:25:16.680 --> 00:25:20.490
通常我们叫他“竞争”(注：后面不译，直接使用 race)，后面我打算会多次提起它
and it's usually called a race I'm gonna come up a lot

415
00:25:20.490 --> 00:25:22.680
因为你将会做大量的多线程编程
cause you're gonna do a lot of

416
00:25:22.680 --> 00:25:25.279
且存在共享状态
threaded programming with shared state

417
00:25:25.279 --> 00:25:27.569
这里 race 这个词
race I think refers to as some ancient

418
00:25:27.569 --> 00:25:30.569
我认为来源于电子电路中的一类古老的 bug
class of bugs involving electronic circuits

419
00:25:30.569 --> 00:25:33.769
但是对我们来说
but for us that you know the reason

420
00:25:33.769 --> 00:25:37.769
称为 race 是因为如果一个 CPU 已经开始执行这段代码
why it's called a race is because if one of the CPUs have started

421
00:25:37.769 --> 00:25:44.789
另一些线程正在结束这段代码
executing this code and the other one the others thread is sort of getting close to this code

422
00:25:44.789 --> 00:25:46.319
这就是 race
it's sort of a race

423
00:25:53.369 --> 00:25:54.809
如果第一个处理器的 store
if the first processor actually

424
00:26:00.750 --> 00:26:07.369
第二个处理器将 load 值 1，然后再加 1，再把 2 存入
value and the second processor will load one and add one to it in store two

425
00:26:07.369 --> 00:26:10.200
好了，你可以通过上面这种方式理解这个术语
that's how you can justify this terminology

426
00:26:10.200 --> 00:26:15.269
okay, 解决这个问题的方式很简单
okay and so the way you solve this certainly something this simple

427
00:26:15.269 --> 00:26:16.890
加个锁就行了
is you insert locks

428
00:26:16.890 --> 00:26:19.470
你知道，作为一个程序员
you know you as a programmer you have

429
00:26:19.470 --> 00:26:23.910
你心中应该有一些办法如何给数据加锁
some strategy in mind for locking the

430
00:26:23.910 --> 00:26:31.500
只有在持有锁的时候，这个共享数据才能被使用
data you can say well you know this piece of shared data can only be used when such-and-such a lock is held and

431
00:26:36.660 --> 00:26:39.799
Go 调用 lock 来锁住 mutex，你能看到 mu.Lock()
mutexes so what you'll see is a mu dot lock

432
00:26:39.799 --> 00:26:44.130
加在这一段使用共享数据的代码前面
before a sequence of code that uses

433
00:26:44.130 --> 00:26:48.319
然后在结束的地方调用  mu.Unlock()
shared data and you unlock afterwards

434
00:26:53.339 --> 00:26:56.220
然后执行所有这些代码
gets to do all this stuff

435
00:26:56.220 --> 00:26:57.599
在结束之前，另一个线程都不能继续
and finish before the other one is allowed to proceed

436
00:26:57.599 --> 00:27:02.339
你可以考虑把这些在锁中间的代码封装起来
and so you can think of wrapping a some code in a lock

437
00:27:02.339 --> 00:27:05.460
就像这一堆东西
as making a bunch of you know remember

438
00:27:18.240 --> 00:27:21.319
(提问)
yes

439
00:27:26.369 --> 00:27:30.970
你是……胆子小吗，能不能再说一遍？
should you sissy can you repeat the question

440
00:27:45.910 --> 00:27:47.440
实际上三个不同变量
different variables and the answer is

441
00:27:47.440 --> 00:27:52.890
所以答案是 go 并不知道
that go has no idea it's not there's no

442
00:28:00.640 --> 00:28:04.599
它是个 mutex
mutex there's just there's no

443
00:28:04.599 --> 00:28:07.630
在 lock 和任何变量之间
association in the language between the

444
00:28:07.630 --> 00:28:10.720
他们并没有什么关联
lock and any variables the associations

445
00:28:10.720 --> 00:28:12.339
在程序员脑袋中
in the programmers head so as a

446
00:28:12.339 --> 00:28:14.470
你只需要说
programmer you need to say oh here's a

447
00:28:14.470 --> 00:28:18.670
oh, 这里有一堆共享数据
bunch of shared data and any time you

448
00:28:18.670 --> 00:28:20.769
在任意时刻，你修改其中任意一个
modify any of it you know here's a

449
00:28:20.769 --> 00:28:22.809
有些复杂的数据结构
complex data structure say a tree or an

450
00:28:22.809 --> 00:28:24.279
比如是树或是可扩展的 hash 表或是别的什么
expandable hash table or something

451
00:28:24.279 --> 00:28:26.559
任何时候你若打算修改它
anytime you're going to modify it and of

452
00:28:26.559 --> 00:28:27.819
当然，树是有许多对象组合而成的
course a tree is composed many many

453
00:28:27.819 --> 00:28:29.710
任何时候，你打算修改任何
objects anytime you got to modify

454
00:28:29.710 --> 00:28:30.880
和这个数据结构关联的东西
anything that's associated with this

455
00:28:30.880 --> 00:28:32.289
你都得先拿到这样的锁
data structure you have to hold such and

456
00:28:32.289 --> 00:28:34.539
当然，包含许多对象
such a lock. and of course, many

457
00:28:34.539 --> 00:28:36.579
以及对象的集合的修改
objects and the set of objects changes

458
00:28:36.579 --> 00:28:37.630
因为你可能会分配一个新的树节点
because you might allocate new tree

459
00:28:37.630 --> 00:28:40.119
但是程序员必须想出一个策略
nodes but it's really the programmer who

460
00:28:40.119 --> 00:28:41.980
保证在同一时刻
sort of works out a strategy for

461
00:28:41.980 --> 00:28:44.710
数据结构只在一个核上被使用
ensuring that the data structure is used

462
00:28:44.710 --> 00:28:47.470
所以
by only one core at a time and so it

463
00:28:47.470 --> 00:28:50.259
需要创建一个甚至是多个锁
creates the one or maybe more locks and

464
00:28:50.259 --> 00:28:51.670
有许多许多加锁的方案
there's many many locking strategies you

465
00:28:57.579 --> 00:28:58.779
程序员可以制定一些策略来分配锁
programmer works out the strategy

466
00:28:58.779 --> 00:29:02.230
在脑子里记住数据之间关系
allocates the locks and keeps in the programmers head the relationship to the data

467
00:29:02.230 --> 00:29:04.960
但是对 Go 来说
but go for go it's this is this

468
00:29:04.960 --> 00:29:07.690
这里的这个锁其实非常简单
lock it's just like a very simple thing

469
00:29:07.690 --> 00:29:10.930
它是一个锁对象
there's a lock object the first thread

470
00:29:10.930 --> 00:29:12.970
第一个线程调用 lock 方法拿到锁
that calls lock gets the lock other

471
00:29:12.970 --> 00:29:14.769
其它所有线程等待直接 unlock 被执行
threads have to wait until unlocks

472
00:29:14.769 --> 00:29:18.539
所有这些事情 Go 都清楚
and that's all go knows

473
00:29:18.799 --> 00:29:21.160
(提问)
yeah

474
00:29:23.990 --> 00:29:26.730
不用给一个对象中
does it not lock all variables that are

475
00:29:30.690 --> 00:29:33.720
当你请求锁的时候
variables and locks so when you acquire

476
00:29:33.720 --> 00:29:37.710
当你的代码调用 lock 方法时
that lock when you have code that calls

477
00:29:37.710 --> 00:29:41.279
它在做什么
lock exactly what it is doing it is

478
00:29:41.279 --> 00:29:44.220
它就是想拿到这个锁，这就是它的作用
acquiring this lock and that's all this

479
00:29:44.220 --> 00:29:47.279
其它任何人想尝试获得锁对象
does and anybody else who tries to lock

480
00:29:47.279 --> 00:29:49.259
所以在某个地方
objects so somewhere else who would have

481
00:29:49.259 --> 00:29:55.170
需要声明一个 mutex mu;
declared you know mutex mu all right

482
00:29:55.170 --> 00:29:56.579
这个 mu 指向了某些特别的 lock 对象
and this mu refers to some particular

483
00:29:56.579 --> 00:29:58.410
有许多（听不懂。。。）
lock object and there are many many

484
00:29:58.410 --> 00:30:01.349
所有这些动作都是获取这把锁
locks right all this does is acquires

485
00:30:01.349 --> 00:30:04.619
其它任何人想获得它
this lock and anybody else who wants to

486
00:30:09.119 --> 00:30:11.970
完全由我们自己决定
programmers what we were protecting with

487
00:30:11.970 --> 00:30:33.569
(提问) 所以问题是
that lock so the question is is it

488
00:30:39.660 --> 00:30:42.890
我们假设有个城市的分区图
like supposing it a zoning map yeah and

489
00:30:42.890 --> 00:30:44.819
你可能希望，尽管这不是真的
you know you would hope although it's

490
00:30:44.819 --> 00:30:46.859
地图内部需要有一把锁来保护它
not true that map internally would have

491
00:30:46.859 --> 00:30:52.859
这是个合理的策略
a lock protecting it and that's a reasonable strategy

492
00:30:52.859 --> 00:30:56.339
有了这些会怎样？
would be to have them, I mean what would be to have them if you

493
00:30:56.339 --> 00:30:58.349
如果你定义了一个
define a data structure that needs to be

494
00:30:58.349 --> 00:30:59.819
需要加锁使用的数据结构
locked to have the lock be sort of

495
00:30:59.819 --> 00:31:01.650
这个锁是内部私有的
interior that have each of the data

496
00:31:01.650 --> 00:31:03.210
数据结构的每个方法都有责任
structures methods be responsible for

497
00:31:03.210 --> 00:31:04.859
请求这把锁
acquiring that lock and the user the

498
00:31:04.859 --> 00:31:06.839
用户，数据结构可能永远都不知道有这把锁的存在
data structure may never know that

499
00:31:06.839 --> 00:31:09.210
这个相当合理
that's pretty reasonable and the only

500
00:31:09.210 --> 00:31:10.829
但是唯一点需要打破
point at which that breaks down is that

501
00:31:10.829 --> 00:31:15.930
好吧，有几件事，其中之一是
um well it's a couple things one is if

502
00:31:20.910 --> 00:31:22.200
因为他们得多付出锁的开销
they were paying the lock overhead for

503
00:31:22.200 --> 00:31:23.400
他们清楚这没必要加锁
something they knew didn't need to be

504
00:31:23.400 --> 00:31:25.819
所以这是个潜在的问题
locked so that's one potential problem

505
00:31:25.819 --> 00:31:31.140
另一件事
the other is that if you if there's any

506
00:31:45.160 --> 00:31:47.599
但常规解决死锁的方法
but the usual solutions to deadlocks

507
00:31:47.599 --> 00:31:52.369
需要把锁拿到实现的外面来
requires lifting the locks out of out of

508
00:31:52.369 --> 00:31:54.289
放到调用代码的地方（注：把函数里面的锁，移到外面）
the implementations up into the calling

509
00:31:59.180 --> 00:32:00.710
这是个不太好的方法
the locks but it's not always a good

510
00:32:00.710 --> 00:32:11.599
okay, 所以你使用多线程的问题之一
idea all right okay so one problem you

511
00:32:19.430 --> 00:32:25.180
同时访问数据的加锁策略
strategy for making access to the data single thread one thread at a time or

512
00:32:25.180 --> 00:32:29.170
另一个方案是你可以让你的代码不要共享数据
you fix your code to not share data

513
00:32:29.170 --> 00:32:32.420
如果可以的话，这种方法会更好
if you can do that it's that's probably

514
00:32:32.420 --> 00:32:35.539
因为这会降低复杂性
better because it's less complex all

515
00:32:35.539 --> 00:32:38.329
好，现在来看另一个话题 coordination(协作)
right so another issue that shows up

516
00:32:46.670 --> 00:32:48.529
可能并不知道其它线程也在加锁
probably have no idea that the other ones exist

517
00:32:48.529 --> 00:32:51.650
他们只是想在没有人干涉的情况下拿到数据
they just want to like be able to get out the data without anybody else interfering

518
00:32:51.650 --> 00:32:53.960
但也有一些情况
but there are also cases

519
00:32:53.960 --> 00:32:55.220
你确实就是故意的想让不同的线程之间
where you need where you do

520
00:32:55.220 --> 00:32:56.869
互相受到制约
intentionally want different threads to

521
00:32:56.869 --> 00:32:58.369
我就是想等着你
interact I want to wait for you

522
00:32:58.369 --> 00:32:59.930
比如你生产某些数据
maybe you're producing some data you

523
00:32:59.930 --> 00:33:01.549
但是你又和我不是同一个线程
know you're a different thread than me

524
00:33:01.549 --> 00:33:03.140
你生产数据
you're you're producing data I'm gonna

525
00:33:03.140 --> 00:33:05.900
我想在你生产完数据前一直等待
wait until you've generated the data

526
00:33:05.900 --> 00:33:09.980
直到你完成后，我再去读取
before I read it right or you launch a

527
00:33:09.980 --> 00:33:11.180
或者是你启动了一堆线程去抓取 web 页面
bunch of threads to say you crawl the

528
00:33:11.180 --> 00:33:12.440
然后需要等待所有线程都执行结束
web and you want to wait for all those

529
00:33:12.440 --> 00:33:14.180
所以当我们想
fits to finish so there's times when we

530
00:33:14.180 --> 00:33:18.769
特意的互相等待的时候
intentionally want different to us to interact with each other to wait for each other

531
00:33:18.769 --> 00:33:23.319
这种情况通常就称为 coordination (协作)
and that's usually called coordination

532
00:33:23.440 --> 00:33:26.630
你要是做完了咱们的教程的话
and there's a bunch of as you probably

533
00:33:26.630 --> 00:33:28.250
就能知道很多了
know from having done the tutorial

534
00:33:28.250 --> 00:33:31.220
Go 中有很多技术可以做到
there's a bunch of techniques in go for

535
00:33:31.220 --> 00:33:34.299
比如 channel (通道)
doing this like channels

536
00:33:45.240 --> 00:33:48.940
比如有个东西叫 condition variables (条件变量)
like there's a idea called condition

537
00:33:48.940 --> 00:33:51.549
这东西很牛逼
variables which is great if there's some

538
00:33:51.549 --> 00:33:53.230
如果有些线程在那里等着（马儿不走了）
thread out there and you want to kick it

539
00:33:53.230 --> 00:33:54.490
你想周期性的“踢”它一下（类似马儿，抽它一下）
period you're not sure if the other

540
00:33:54.490 --> 00:33:55.839
但你不确定哪些线程是否正在等待你
threads even waiting for you but if it

541
00:33:55.839 --> 00:33:57.460
如果它在等你，你就踢它一下
is waiting for you you just like to give

542
00:33:57.460 --> 00:33:59.500
这样它就知道它需要
it a kick so it can well know that it

543
00:33:59.500 --> 00:34:01.509
继续做它应该要做的事情
should continue whatever it's doing and

544
00:34:01.509 --> 00:34:06.279
还有一个工具 WaitGroup
then there's wait group which is

545
00:34:06.279 --> 00:34:08.260
相当牛逼
particularly good for launching a a

546
00:34:08.260 --> 00:34:10.449
常用于启动已知数据的 goroutine
known number of go routines and then

547
00:34:10.449 --> 00:34:14.469
然后等待它们结束
waiting for them end off to finish and a

548
00:34:23.619 --> 00:34:29.219
有时你运行到线程中的某个位置
that you sometimes run into where one thread

549
00:34:29.219 --> 00:34:35.860
这个线程（T1)正在等待另外一个线程(T2)生产的数据
you know thread this thread is waiting for thread 2 to produce something so

550
00:34:35.860 --> 00:34:37.750
我来画个箭头
you know it's draw an arrow to say

551
00:34:37.750 --> 00:34:41.170
表示 T1 正在等待 T2
thread one is waiting for thread 2 you

552
00:34:41.170 --> 00:34:43.989
线程 T1 可能正在等待 T2 释放锁
know for example thread one may be waiting for thread two to release a lock

553
00:34:43.989 --> 00:34:46.690
或是向 channel 上发数据
or to send something on the channel or

554
00:34:46.690 --> 00:34:48.280
又或是等着 T2 给 WaitGroup 计数减 1
to you know decrement something in a

555
00:34:48.280 --> 00:34:51.579
然而不幸的是
wait group however unfortunately maybe T

556
00:34:51.579 --> 00:34:55.210
T2 也可能正在等着 T1 做一些事情
two is waiting for thread thread one to

557
00:35:01.840 --> 00:35:05.739
T2 在请求锁 B
acquire lock B so thread one is

558
00:35:05.739 --> 00:35:07.690
应该这样，T1 持有锁 A, T2 持有锁 B
acquired lock A thread two is aquired

559
00:35:07.690 --> 00:35:11.230
然后下一步，T1 也需要请求锁 B
lot B and then next thread one needs to

560
00:35:11.230 --> 00:35:15.909
它需要同时持有 2 把锁
lock B also that is hold two locks which sometimes shows up

561
00:35:15.909 --> 00:35:17.289
刚好 T2 也需要请求锁 A
and it just so happens that thread two needs to hold

562
00:35:17.289 --> 00:35:19.989
这就死锁了
lock A that's a deadlock all right at

563
00:35:19.989 --> 00:35:21.489
这至少需要他们都能抢到第一把锁
least grab their first lock and then

564
00:35:21.489 --> 00:35:23.409
然后继续执行到他们需要第二把锁的位置
proceed down to where they need their

565
00:35:23.409 --> 00:35:24.519
现在它们都在永远互相等待着对方
second lock and now they're waiting for

566
00:35:24.519 --> 00:35:26.739
它们都无法继续进行下去
each other forever right neither can

567
00:35:26.739 --> 00:35:28.780
也没有人能释放掉刚拿到的锁
proceed neither then can release the

568
00:35:28.780 --> 00:35:33.570
通常什么都不会发生
lock and usually just nothing happens so

569
00:35:33.570 --> 00:35:36.190
所以如果你的程序像机器一样停下来
if your program just kind of grinds to a

570
00:35:36.190 --> 00:35:37.420
什么也不干的时候
halt and doesn't seem to be doing

571
00:35:43.800 --> 00:35:53.860
okay，让我们看看教程里的 web 爬虫
okay all right let's look at the web crawler from the tutorial

572
00:35:53.860 --> 00:36:00.429
这是一个使用多线程的例子
as an example of some of this threading stuff I have a

573
00:36:00.429 --> 00:36:03.730
我这里有 2 种不同风格的方案
couple of two solutions in different

574
00:36:03.730 --> 00:36:07.630
呃，实际上应该是有 3 种
styles are really three solutions in

575
00:36:07.630 --> 00:36:09.429
不同风格的方案里
different styles to allow us to talk a

576
00:36:09.429 --> 00:36:10.780
咱们可以谈谈多线程编程里的一些细节
bit about the details of some of this

577
00:36:10.780 --> 00:36:13.539
首先
thread programming so first of all you

578
00:36:13.539 --> 00:36:16.119
你们可能知道
all probably know web crawler its job is

579
00:36:16.119 --> 00:36:18.489
爬虫就是你给它一个 URL 让它开始运行
you give it the URL of a page that it

580
00:36:18.489 --> 00:36:20.469
在 web 页面里
starts at and you know many web pages

581
00:36:20.469 --> 00:36:23.110
包含有许多链接指向了其它的页面
have links to other pages so what a web

582
00:36:23.110 --> 00:36:24.849
所以 web 爬虫要做的就是
crawler is trying to do is if that's the

583
00:36:24.849 --> 00:36:29.530
把这些链接指向的页面提取出来
first page extract all the URLs that were mentioned that pages links

584
00:36:33.730 --> 00:36:35.739
然后继续抓取这些 url 指向的页面
those but all urls that they refer to

585
00:36:35.739 --> 00:36:38.380
它应该要能够停止
and keep on going until it's fetched all

586
00:36:38.380 --> 00:36:41.230
比如直到 web 中所有的页面被抓取完
the pages in the web let's just say and

587
00:36:41.230 --> 00:36:45.489
另外
then it should stop in addition the the

588
00:36:45.489 --> 00:36:52.150
网页构成的 graph 和 URL 存在环
graph of pages and URLs is cyclic that

589
00:36:52.150 --> 00:36:53.380
如果你不关心的话
is if you're not careful

590
00:36:53.380 --> 00:36:55.420
um 你的爬虫可能会结束
um you may end up following if you don't

591
00:37:01.449 --> 00:37:03.579
你的爬虫永远无法结束
your crawler will never finish so one of

592
00:37:03.579 --> 00:37:05.559
所以爬虫的工作之一就是需要记住
the jobs of the crawler is to remember

593
00:37:05.559 --> 00:37:08.139
它抓取过的页面
the set of pages that is already crawled

594
00:37:08.139 --> 00:37:10.780
或是已经开始抓取的页面
or already even started a fetch for and

595
00:37:10.780 --> 00:37:15.820
对于任何正在抓取中的页面
to not start a second fetch for any page

596
00:37:15.820 --> 00:37:17.199
都不应该有第二次抓取
that it's already started fetching on

597
00:37:17.199 --> 00:37:18.849
你可以想象
and you can think of that as sort of

598
00:37:18.849 --> 00:37:21.760
它是一个树结构
imposing a tree structure finding a sort

599
00:37:21.760 --> 00:37:25.269
这个树结构是一个
of tree shaped subset of the cyclic

600
00:37:25.269 --> 00:37:31.809
包含了环的实际网页 graph 的子集
graph of actual web pages okay so we

601
00:37:31.809 --> 00:37:33.429
我们想避开环
want to avoid cycles we want to be able

602
00:37:42.159 --> 00:37:46.960
因为网络有较长的延迟
has a long speed of light latency and so

603
00:37:46.960 --> 00:37:48.670
所以你完全不会想一次只抓取一个页面
you definitely don't want to fetch pages

604
00:37:48.670 --> 00:37:50.289
除非你想让你的爬虫运行个数年
one at a time unless you want to crawl

605
00:37:50.289 --> 00:37:54.190
如果你同时抓取许多页面的话
to take many years so it pays enormous

606
00:37:57.980 --> 00:37:59.480
你需要使用并行化的方式
keep on increasing the number of pages

607
00:37:59.480 --> 00:38:01.489
持续的增加抓取页面的数量
you fetch in parallel until the

608
00:38:01.489 --> 00:38:03.139
直到达到呑吐极限
throughput you're getting in pages per

609
00:38:03.139 --> 00:38:05.690
也就是每秒你抓取的页面数量
second stops increasing that is running

610
00:38:05.690 --> 00:38:07.909
不在增加为止，也就是并发数的增加
increase the concurrency until you run

611
00:38:07.909 --> 00:38:11.300
这时候也耗尽了网络带宽
out of network capacity so we want to be

612
00:38:11.300 --> 00:38:12.500
所以，我们希望利用并行化的方式抓取
able to launch multiple fetches in

613
00:38:12.500 --> 00:38:15.980
最后一个挑战
parallel and a final challenge which is

614
00:38:15.980 --> 00:38:17.900
有时候也是最难解决的问题
sometimes the hardest thing to solve is

615
00:38:17.900 --> 00:38:19.400
当爬虫运行结束
to know when the crawl is finished

616
00:38:19.400 --> 00:38:21.619
一旦我们已经抓取了所有的页面
and once we've crawled all the pages we

617
00:38:21.619 --> 00:38:24.110
就需要停止爬虫
want to stop and say we're done but we

618
00:38:24.110 --> 00:38:25.369
但是我确实需要写一些代码
actually need to write the code to

619
00:38:25.369 --> 00:38:27.110
来表明：啊哈
realize aha

620
00:38:27.110 --> 00:38:29.840
所有的页面都已经抓取了
we've crawled every single page and for

621
00:38:29.840 --> 00:38:32.480
我已经想出了一些方案
some solutions I've tried figuring out

622
00:38:32.480 --> 00:38:33.889
什么时候结束被证明是
when you're done has turned out to be

623
00:38:33.889 --> 00:38:38.420
最难的一部分
the hardest part all right so my first

624
00:38:38.420 --> 00:38:40.730
所以我的第一个爬虫是一个串行化的爬虫
crawler is this serial crawler here and

625
00:38:40.730 --> 00:38:43.400
顺便说一下，课程表里的 crawler.go 文件中的
by the way this code is available on the

626
00:38:43.400 --> 00:38:45.980
这段代码是可以用的
website under crawler dot go on the schedule

627
00:38:45.980 --> 00:38:48.500
后面你会看到它的
you will look at it this wrist calls a

628
00:38:48.500 --> 00:38:53.239
这个串行爬虫在网页 graph 中
serial crawler it effectively performs a

629
00:38:53.239 --> 00:38:58.119
进行深度优先搜索
depth-first search into the web graph

630
00:38:58.119 --> 00:39:02.869
有件比较有意思的事情
and there is sort of one moderately

631
00:39:02.869 --> 00:39:04.489
它会使用一个 map 类型的变量 fetched 
interesting thing about it it keeps this

632
00:39:04.489 --> 00:39:06.650
它只是被当作一个 set 使用
map called fetched which is basically

633
00:39:06.650 --> 00:39:08.630
目的就是为了记住
using as a set in order to remember

634
00:39:08.630 --> 00:39:11.210
它所抓取过的页面
which pages it's crawled and that's like

635
00:39:11.210 --> 00:39:12.829
这是最有意思的部分
the only interesting part of this you

636
00:39:12.829 --> 00:39:16.250
在 18 行你给它一个 URL
give it a URL that at line 18 if it's

637
00:39:16.250 --> 00:39:17.920
如果这个 URL 已经被抓取过它就直接 return
already fetched the URL it just returns

638
00:39:17.920 --> 00:39:20.210
如果没有被抓取过
if it doesn't fetch the URL it first

639
00:39:20.210 --> 00:39:22.420
首先它要把这个 URL 记下
remembers that it is now fetched it

640
00:39:27.650 --> 00:39:29.539
接下来迭代所有的 URL
with the fetcher and then iterates over

641
00:39:29.539 --> 00:39:33.429
然后递归的调用它自己
the URLs in that page and calls itself

642
00:39:33.429 --> 00:39:35.659
对于所有的页面
for every one of those pages and it

643
00:39:45.769 --> 00:39:47.329
它又抓取了很多页面
fetches a bunch of pages after it

644
00:39:47.329 --> 00:39:49.969
在它返回后，我需要意识到
returns I want to be aware you know the

645
00:39:49.969 --> 00:39:52.340
你知道，在抓取实例的外面，需要意识到
outer crawl instance needs to be aware

646
00:39:52.340 --> 00:39:53.960
某些页面是已经抓取过的
that certain pages are already fetched

647
00:39:53.960 --> 00:39:56.329
所以我们十分依赖于
so we depend very much on the fetched

648
00:39:56.329 --> 00:39:58.250
在函数里传递的 fetched 对象
map being passed between the functions

649
00:39:58.250 --> 00:40:01.969
map 使用引用而不是拷贝
by reference instead of by copying so it

650
00:40:01.969 --> 00:40:03.769
所以在底层
so under the hood what must really be

651
00:40:03.769 --> 00:40:05.329
go 把指向map对象的指针
going on here is that go is passing a

652
00:40:05.329 --> 00:40:08.480
传递给
pointer to the map object

653
00:40:12.829 --> 00:40:15.739
而不是（对象）的拷贝
and memory rather than copying rather

654
00:40:15.739 --> 00:40:22.760
有什么问题吗
than copying than that any questions so

655
00:40:22.760 --> 00:40:24.139
这段代码显然没有解决
this code definitely does not solve the

656
00:40:24.139 --> 00:40:25.760
之前提到的问题
problem that was posed right because it

657
00:40:25.760 --> 00:40:30.650
因为它没有并行化的执行 fetch（函数）
doesn't launch parallel parallel fetches

658
00:40:30.650 --> 00:40:33.199
我们需要把 goroutine
now so clue we need to insert goroutines

659
00:40:33.199 --> 00:40:35.150
放在这段代码的某个位置
somewhere in this code right to get

660
00:40:35.150 --> 00:40:37.880
来实现并行的 fetch 让我们假设
parallel fetches so let's suppose just

661
00:40:37.880 --> 00:40:41.480
为了让大家开心一下……
for chuckles dad we just start with the

662
00:40:41.480 --> 00:40:51.440
老爹，让我偷个懒
most lazy thing because why so I'm gonna

663
00:40:51.440 --> 00:40:54.949
为啥我非得这么改代码…… 
just modify the code to run the

664
00:40:54.949 --> 00:40:57.469
其实就是想把每个 crawl 子调用
subsidiary crawls each in its own

665
00:40:57.469 --> 00:41:00.469
放到各自的 goroutine 里执行
goroutine actually before I do that why

666
00:41:00.469 --> 00:41:01.579
我执行这段代码 给你们看看
don't I run the code just to show you

667
00:41:07.670 --> 00:41:09.380
实际上执行了全部3个crawler
it actually runs all three copies of the

668
00:41:09.380 --> 00:41:10.969
它们都找到了
crawler and they all find exactly the

669
00:41:10.969 --> 00:41:14.329
完全相同的一组网页
same set of webpages so this is the

670
00:41:19.219 --> 00:41:20.750
每个打印出一行
fetched prints a line for each one so

671
00:41:20.750 --> 00:41:26.119
现在我们把crawler
let me now run the subsidiary crawls in

672
00:41:26.119 --> 00:41:28.130
放在各自的goroutine里执行
their own goroutines and run that code

673
00:41:28.130 --> 00:41:35.539
我将看到什么结果
so what am I going to see the hope is to

674
00:41:35.539 --> 00:41:37.880
我们的期望是并行爬取网页
fetch these webpages in parallel for

675
00:41:37.880 --> 00:41:42.800
达到更高的性能 好的 
higher performance so okay so you're

676
00:41:42.800 --> 00:41:45.110
你的观点是只会看到一个URL
voting for only seeing one URL and why

677
00:41:45.110 --> 00:41:47.679
为什么
so why is that

678
00:41:50.980 --> 00:41:55.219
对 完全正确
yeah yes that's exactly right you know

679
00:42:00.559 --> 00:42:02.449
它将迅速执行完循环
right through that loop I was gonna

680
00:42:02.449 --> 00:42:04.849
当最开始的那个网页被抓取（第22行）
fetch 1 page when the very first webpage at

681
00:42:08.389 --> 00:42:10.219
紧接着crawl函数就将返回
the crawl function is gonna return and

682
00:42:10.219 --> 00:42:11.989
而且crawl是在main函数里调用的
if it was called from main main what was

683
00:42:11.989 --> 00:42:13.789
几乎可以确定main
exit almost certainly before any of the

684
00:42:13.789 --> 00:42:15.199
会在这些goroutine能做任何事之前退出
goroutines was able to do any work at all

685
00:42:15.199 --> 00:42:16.880
所以我们很可能只会看到第一个网页
so we'll probably just see the first web

686
00:42:16.880 --> 00:42:19.690
我运行它
page and I'm gonna do when I run it

687
00:42:19.690 --> 00:42:23.920
你会看到，这里，在Serial下面
you'll see here under serial that only

688
00:42:23.920 --> 00:42:26.659
唯一被找到的网页
the one web page was found now in fact

689
00:42:26.659 --> 00:42:28.730
由于程序并没有在Serial Crawler结束后退出
since this program doesn't exit after

690
00:42:28.730 --> 00:42:30.800
这些goroutine
the Serial crawler those goroutines are

691
00:42:30.800 --> 00:42:32.269
仍然在运行 实际上 他们打印的输出
still running and they actually print

692
00:42:32.269 --> 00:42:35.389
和后面的crawler例子（的输出）
their output down here interleaved with

693
00:42:35.389 --> 00:42:37.820
混在了一起
the next crawler example but

694
00:42:37.820 --> 00:42:42.829
然而 这段代码 只是在这里加了一个go关键词
nevertheless the codes just adding a go

695
00:42:42.829 --> 00:42:45.829
完全不起作用
here absolutely doesn't work so let's

696
00:42:45.829 --> 00:42:49.579
我们忘掉这段代码 现在我
get rid of that okay so now I want to

697
00:42:49.579 --> 00:42:52.190
想给你们看一种并发风格的crawler
show you a one style of concurrent

698
00:42:52.190 --> 00:42:55.789
我马上会展示其中一个
crawler and I'm presenting to one of

699
00:42:55.789 --> 00:42:59.750
（它）使用了共享数据
them written with shared data shared

700
00:42:59.750 --> 00:43:02.809
共享对象和锁 这是第一个（crawler）
objects and locks it's the first one and

701
00:43:08.989 --> 00:43:11.360
channel 可以让不同的线程之间进行协作
channels in order to coordinate the

702
00:43:11.360 --> 00:43:12.920
现在（要讲的）是共享数据的
different threads so this is the shared

703
00:43:18.980 --> 00:43:22.460
这段代码明显
shared data so this code significantly

704
00:43:31.130 --> 00:43:33.739
最大的不同之处在于
does alright but the huge difference is

705
00:43:33.739 --> 00:43:38.389
它做了两件事
that it does with two things one it does

706
00:43:38.389 --> 00:43:40.699
一是必要的统计 以注意到
the bookkeeping required to notice when

707
00:43:40.699 --> 00:43:44.690
所有爬取完成的时刻
all of the crawls have finished and it

708
00:43:44.690 --> 00:43:47.900
它也会处理共享表格
handles the shared table of which URLs

709
00:43:47.900 --> 00:43:49.849
这个表格记录了已爬取的URL
have been crawled correctly so this code

710
00:43:49.849 --> 00:43:53.809
所以这段代码仍然有URL表格
still has this table of URLs and that's

711
00:43:53.809 --> 00:43:59.349
即 f.fetched
this F dot fetched this F dot fetch

712
00:43:59.349 --> 00:44:06.130
在第43行 这个表格
map at line 43 but this this table is

713
00:44:06.130 --> 00:44:10.659
被所有的crawler线程共享
actually shared by all of the all of the

714
00:44:10.659 --> 00:44:12.190
所有的crawler线程
crawler threads and all the crawler

715
00:44:12.190 --> 00:44:14.889
执行在
threads are making or executing inside

716
00:44:14.889 --> 00:44:16.900
函数 ConcurrentMutex 内 所以我们仍然
ConcurrentMutex and so we still have

717
00:44:16.900 --> 00:44:18.610
有 ConcurrentMutex 的树结构
this sort of tree of ConcurrentMutexes

718
00:44:18.610 --> 00:44:20.619
来探索 web graph 的不同部分
that's exploring different parts of the

719
00:44:20.619 --> 00:44:22.599
但它们中的每一个是被
web graph but each one of them was

720
00:44:22.599 --> 00:44:25.659
被放在各自的goroutine中启动
launched as a as his own goroutine

721
00:44:25.659 --> 00:44:28.719
而不是作为函数调用
instead of as a function call but

722
00:44:28.719 --> 00:44:30.400
但是它们都共享一个状态表
they're all sharing this table of state

723
00:44:30.400 --> 00:44:32.860
记录已爬取URL的表格 
this table of fetched URLs because if one

724
00:44:32.860 --> 00:44:34.989
因为如果有个goroutine爬取了一个URL
goroutine fetches a URL we don't want

725
00:44:34.989 --> 00:44:36.969
我们不希望另一个goroutine
another goroutine to accidentally

726
00:44:36.969 --> 00:44:40.420
意外地爬取同一个URL 
fetch the same URL and as you can see

727
00:44:40.420 --> 00:44:43.150
你在这里看到 在第42行和第45行
here line 42 and 45 I've surrounded them

728
00:44:43.150 --> 00:44:48.250
我在这段代码前后加上互斥锁
by the mutexes that are required to to

729
00:44:52.900 --> 00:44:57.730
所以这里的危险是
here is that at line 43 a thread is

730
00:44:57.730 --> 00:44:59.980
在第43行 一个线程正在检查URL是否已经被爬取
checking of URLs already been fetched so

731
00:44:59.980 --> 00:45:02.679
两个线程恰好在处理
two threads happen to be following the

732
00:45:02.679 --> 00:45:06.820
同一个URL  两个ConcurrentMutex函数的调用
same URL now two calls to ConcurrentMutex

733
00:45:06.820 --> 00:45:09.489
结果却会看到同一个URL
end up looking at the same URL

734
00:45:09.489 --> 00:45:11.139
原因可能是同一个URL
maybe because that URL was mentioned in

735
00:45:11.139 --> 00:45:13.929
在两个不同的网页都出现过
two different web pages if we didn't

736
00:45:13.929 --> 00:45:17.559
如果我们没有锁 
have the lock they'd both access the

737
00:45:17.559 --> 00:45:18.820
它们都将访问表格 
math table to see if the threaded and

738
00:45:18.820 --> 00:45:20.829
查看URL是否已经爬取
then already if the URL had been already

739
00:45:20.829 --> 00:45:23.650
在第43行它们都拿到False
fetched and they both get false at line

740
00:45:30.880 --> 00:45:32.380
在第47行 它们都看到already值为False
will both see that I already was false

741
00:45:32.380 --> 00:45:33.880
之后它们都会去爬取这个网页
and then they both go on to fetch the

742
00:45:38.739 --> 00:45:41.409
我们希望第43行和44行（一起）
that we want lines 43 and 44 to be

743
00:45:45.909 --> 00:45:48.460
使用表 我们想要
table between 43 and 44 we we want to

744
00:45:48.460 --> 00:45:50.349
读取当前的内容 每个线程
read the current content each thread

745
00:45:50.349 --> 00:45:52.690
希望能读取当前的表格内容
wants to read the current table contents

746
00:45:52.690 --> 00:45:55.780
并更新 且没有其他线程干扰
and update it without any other thread

747
00:45:55.780 --> 00:45:57.309
这正是锁
interfering and so that's what the locks

748
00:45:57.309 --> 00:46:01.150
为我们做到的事情 对于这里使用锁的策略 
are doing for us okay so so actually any

749
00:46:01.150 --> 00:46:03.280
有任何问题吗
questions about the about the locking

750
00:46:03.280 --> 00:46:05.940
strategy here

751
00:46:07.750 --> 00:46:10.760
好 当我们检查表中的URL条目之后
all right once we check the URLs entry

752
00:46:10.760 --> 00:46:13.670
在51行 
in the table at line 51 it just crawls

753
00:46:13.670 --> 00:46:15.320
URL被以常见的方式爬取
it just fetches that page in the usual

754
00:46:15.320 --> 00:46:18.949
之后另一个有趣的事情
way and then the other thing interesting

755
00:46:18.949 --> 00:46:20.599
是线程的启动
thing that's going on is the launching

756
00:46:20.599 --> 00:46:35.449
（这个同学的）问题是
of the threads yes so the question is

757
00:46:35.449 --> 00:46:43.969
关于F. 不 
what's with the F dot no no the mu it is

758
00:46:43.969 --> 00:46:47.119
在第36行有一个结构体
okay so there's a structure to find out

759
00:46:47.119 --> 00:46:50.329
某种意义上聚集了
line 36 that sort of collects together

760
00:46:50.329 --> 00:46:53.929
所有的不同的东西
all the different stuff that all the

761
00:46:53.929 --> 00:46:55.280
所有我们需要的不同状态 用以运行crawl
different state that we need to run this

762
00:46:55.280 --> 00:46:57.380
这里只有两个对象
crawl and here it's only two objects but

763
00:46:57.380 --> 00:46:58.820
但是可以是更多
you know it could be a lot more and

764
00:46:58.820 --> 00:47:00.619
只是为了方便
they're only grouped together for

765
00:47:05.389 --> 00:47:07.489
并没有什么深层意义
significance the fact that mu and fetched

766
00:47:07.489 --> 00:47:11.750
在同一个结构体里
inside the same structure and

767
00:47:11.750 --> 00:47:14.690
F. 只是一种语法
that F dot is just sort of the syntax

768
00:47:14.690 --> 00:47:15.889
用于取出结构体里的元素
are getting out one of the elements in

769
00:47:15.889 --> 00:47:17.179
我只是刚巧把它们
the structure so I just happened to put

770
00:47:22.789 --> 00:47:25.599
这绝对不是说
absolutely does not mean that go

771
00:47:25.599 --> 00:47:28.880
go把mu和那个结构体联系在一起
associates the mu with that structure or

772
00:47:28.880 --> 00:47:30.949
或是和fetch表联系在一起 
with the fetch map or anything it's just

773
00:47:30.949 --> 00:47:33.710
它只是个锁的对象 
a lock objects and just has a Lock

774
00:47:53.789 --> 00:47:58.750
（学生的）问题是
so the question is how come in order to

775
00:47:58.750 --> 00:48:00.519
为了传引用，我必须在这里使用*操作符
pass something by reference I had to use

776
00:48:00.519 --> 00:48:02.440
但在前一个例子里
star here where it is when a in the

777
00:48:02.440 --> 00:48:03.940
我们传递了一个map
previous example when we were passing a

778
00:48:15.340 --> 00:48:16.809
我们传递指针
that we're passing a pointer to this

779
00:48:16.809 --> 00:48:19.210
给这个fetchState对象 我们这里要用指针
fetch state object and we want it to be

780
00:48:19.210 --> 00:48:20.559
是因为我们希望
a pointer because we want there to be

781
00:48:23.710 --> 00:48:25.239
所以它们需要一个
same object so they all need a pointer

782
00:48:29.409 --> 00:48:30.940
某种你用来传递指针的语法
the syntax you use for passing a pointer

783
00:48:30.940 --> 00:48:32.530
我们不需要对map这么做
the reason why we didn't have to do it

784
00:48:32.530 --> 00:48:35.920
是因为 虽然
with map is because although it's not

785
00:48:50.530 --> 00:48:52.420
如果你声明一个map类型的变量
declare a variable type map what that is

786
00:48:52.420 --> 00:48:55.320
这个变量是指向堆上数据的指针
is a pointer to some data in the heap so

787
00:48:55.320 --> 00:48:57.579
所以不管怎样，它是个指针
it was a pointer anyway and it's always

788
00:48:57.579 --> 00:48:59.260
它总是以引用形式传递
passed by reference do they you just

789
00:48:59.260 --> 00:49:00.610
你就无需使用*运算符 它（语言）替你做了
don't have to put the star and it does

790
00:49:00.610 --> 00:49:01.210
it for you

791
00:49:01.210 --> 00:49:03.610
所以map是特殊的
so there's they're definitely map is

792
00:49:03.610 --> 00:49:06.130
你不能在语言中定义map
special you cannot define map in the

793
00:49:06.130 --> 00:49:07.900
它必须是语言内置的
language it's it has to be built-in

794
00:49:07.900 --> 00:49:09.429
因为有些古怪的事情
because there's some curious things

795
00:49:09.429 --> 00:49:15.820
好的 好的 我们爬取网页 
about it okay good okay so we fetch the

796
00:49:15.820 --> 00:49:18.849
现在我们想要
page now we want to fire off a crawl goroutine

797
00:49:18.849 --> 00:49:20.800
为每一个刚爬取页面中的URL
for each URL mentioned in the

798
00:49:20.800 --> 00:49:23.170
启动一个crawler goroutine
page we just fetch so that's done in

799
00:49:23.170 --> 00:49:26.440
在第56行 
line 56 on line 56 just loops over

800
00:49:26.440 --> 00:49:29.889
遍历fetch函数返回的URLs
the URLs that the fetch function

801
00:49:29.889 --> 00:49:32.949
第58行 对每个URL
returned and for each one fires off a

802
00:49:32.949 --> 00:49:35.739
启动一个goroutine
goroutine at line 58 and that lines that

803
00:49:35.739 --> 00:49:41.530
58行的func语法是一个闭包
func syntax in line 58 is a closure or a

804
00:49:41.530 --> 00:49:43.989
或一个匿名函数
sort of immediate function but that func

805
00:49:43.989 --> 00:49:46.599
func关键字声明了一个函数
thing keyword is doing is to clearing a

806
00:49:46.599 --> 00:49:49.139
然后我们调用了这个函数
function right there that we then call

807
00:49:49.139 --> 00:49:53.280
所以 可能 理解（这段代码）的方式是
so the way to read it maybe is

808
00:49:53.739 --> 00:49:56.780
你把一个函数声明成
that if you can declare a function as a

809
00:49:56.780 --> 00:50:00.230
一段数据 先写下func关键字
piece of data as just func you know and

810
00:50:00.230 --> 00:50:03.349
然后给出函数参数
then you give the arguments and then you

811
00:50:03.349 --> 00:50:08.929
之后写出函数体 结束
give the body and that's a clears and so

812
00:50:08.929 --> 00:50:12.500
现在这是一个对象 
this is an object now this is like it's

813
00:50:18.349 --> 00:50:19.820
你在声明某种常量对象
a sort of constant object and this is

814
00:50:25.730 --> 00:50:27.289
来运行我们刚声明的这个函数
this function that we declared right

815
00:50:27.289 --> 00:50:29.119
为了让它成为一个goroutine
here and so we in order to make the goroutine

816
00:50:37.519 --> 00:50:39.139
go关键字后面
keywords as you follow it by a function

817
00:50:39.139 --> 00:50:40.909
接函数名 以及要传递的参数
name and arguments you want to pass that

818
00:50:40.909 --> 00:50:43.460
所以我们在这里
function and so we're gonna pass some

819
00:50:43.460 --> 00:50:50.900
传递一些参数 这么做有两个原因
arguments here and there's two reasons

820
00:50:50.900 --> 00:50:52.670
我们这么做
we're doing this well really this one

821
00:50:57.789 --> 00:51:00.230
ConcurrentMutex是
ConcurrentMutex so I ConcurrentMutex is

822
00:51:00.230 --> 00:51:01.400
我们要调用的函数的名字
the name of the function we actually

823
00:51:01.400 --> 00:51:06.619
实际上我们把URL作为参数调用这个函数
want to call with this URL but we want

824
00:51:06.619 --> 00:51:08.119
但我们也想要做一点别的事情
to do a few other things as well so we

825
00:51:08.119 --> 00:51:10.159
所以我们定义这个小辅助函数
define this little helper function that

826
00:51:10.159 --> 00:51:12.170
先调用函数ConcurrentMutex url作为参数
first calls ConcurrentMutex for us with

827
00:51:12.170 --> 00:51:15.739
在ConcurrentMutex
the URL and then after ConcurrentMutex

828
00:51:15.739 --> 00:51:17.119
结束之后 我们做一些
is finished we do something

829
00:51:17.119 --> 00:51:19.519
特殊操作 来帮助我们
special in order to help us wait for all

830
00:51:24.920 --> 00:51:27.380
引入了WaitGroup 第55行的WaitGroup 
the the wait group the WaitGroup at

831
00:51:27.380 --> 00:51:29.570
是go语言定义的一个数据结构
line 55 it's a just a data structure defined

832
00:51:29.570 --> 00:51:33.619
用于帮助协作
by go to help with coordination and

833
00:51:39.289 --> 00:51:43.639
就像第57行 你调用WaitGroup.Add()来增加计数器
WaitGroup dot add like line 57 to

834
00:51:43.639 --> 00:51:46.550
调用WaitGroup.Done()
increment the counter and WaitGroup dot done

835
00:51:46.550 --> 00:51:48.619
来减小计数器
to decrement it and then this wait

836
00:51:48.619 --> 00:51:50.900
第63行 这个Wait方法被调用
what this wait method called line 63

837
00:51:50.900 --> 00:51:53.119
等待计数器归零
waits for the counter to get down to

838
00:51:53.119 --> 00:51:56.510
因此WaitGroup是一种
zero so a wait group is a way to wait

839
00:51:56.510 --> 00:51:59.329
用于等待若干事件结束的方式
for a specific number of things to

840
00:51:59.329 --> 00:52:02.539
它在很多不同场景中
finish and it's useful in a bunch of

841
00:52:05.360 --> 00:52:05.920
结束
finish

842
00:52:05.920 --> 00:52:07.840
因为我们对于每个goroutine
because we add one to the wait group

843
00:52:07.840 --> 00:52:11.199
都对WaitGroup加一
for every goroutine we create line 60

844
00:52:11.199 --> 00:52:13.119
第60行 在这个函数的末尾
at the end of this function we've

845
00:52:13.119 --> 00:52:15.309
我们把WaitGroup里的counter减一
declared decrement the counter in the

846
00:52:15.309 --> 00:52:18.130
然后第63行等待
WaitGroup and then line three waits

847
00:52:18.130 --> 00:52:20.250
直到所有的减一操作完成
until all the decrements have finished

848
00:52:20.250 --> 00:52:22.300
我们声明这种函数的原因
and so the reason why we declared this

849
00:52:22.300 --> 00:52:23.920
基本上是为了能够
sort of function was basically to be able

850
00:52:23.920 --> 00:52:26.530
即调用函数ConcurrentMutex 又调用Done
to both call ConcurrentMutex and call

851
00:52:26.530 --> 00:52:28.630
这就是为什么
done that's really why we needed that

852
00:52:28.630 --> 00:52:39.760
我们需要这个函数 （学生的）问题是
function so the question is what if one

853
00:52:39.760 --> 00:52:43.239
如果某个子程序失败 导致done没被调用
of the subroutines fails and doesn't

854
00:52:43.239 --> 00:52:45.820
该怎么办  这是个很好的问题
reach the done line that's a darn good

855
00:52:45.820 --> 00:52:49.210
我不记得
question there is you know if I forget

856
00:52:53.440 --> 00:52:55.150
的错误有哪些
causing the program to fail maybe

857
00:52:55.150 --> 00:52:56.590
可能是除零错误 我不确定
divides by zero I don't know or

858
00:52:56.590 --> 00:52:57.789
或者对null指针解引用
dereferences a null pointer

859
00:52:57.789 --> 00:52:59.139
不太确定 但是有些方式
not sure but there are certainly ways

860
00:52:59.139 --> 00:53:04.570
可以使function失败
for a function to fail and I have the go

861
00:53:04.570 --> 00:53:06.909
goroutine死掉而整个程序不死
routine die without having the program

862
00:53:06.909 --> 00:53:08.889
这对我们是个麻烦
die and that would be a problem for us

863
00:53:08.889 --> 00:53:12.130
所以实际上 正确的方式是
and so really the white right way to I'm

864
00:53:12.130 --> 00:53:13.659
我确定你其实知道这个 
sure you had this in mind and asking the

865
00:53:13.659 --> 00:53:15.849
才问这个问题的 正确的写法是
question the right way to write this to

866
00:53:15.849 --> 00:53:18.519
这样写（defer） 以确保 不论goroutine是怎么结束的
be sure that the done call is made no

867
00:53:18.519 --> 00:53:20.739
done都会被调用
matter why this goroutine is finishing

868
00:53:20.739 --> 00:53:27.179
把defer放在这里
would be to put a defer here which means

869
00:53:27.179 --> 00:53:31.539
意味着在包含它的函数结束前调用done.Done()
call done before the surrounding

870
00:53:31.539 --> 00:53:34.329
而且总是会被调用
function finishes and always call it no

871
00:53:34.329 --> 00:53:36.130
不管包含它的函数
matter why this surrounding function is

872
00:53:36.130 --> 00:53:42.119
是以何种原因结束的
finished yes

873
00:53:53.559 --> 00:53:58.789
是的 提问说的是 
and yes yeah so the question is how come

874
00:53:58.789 --> 00:54:00.650
为什么两个不同threads对done的调用
two uses of done in different threads

875
00:54:00.650 --> 00:54:08.210
不构成race 答案是
aren't a race yeah so the answer must be

876
00:54:08.210 --> 00:54:10.639
（WaitGroup）内部有互斥锁
that internally dot a WaitGroup has a

877
00:54:10.639 --> 00:54:14.170
或类似的机制
mutex or something like it that each of

878
00:54:14.170 --> 00:54:18.199
每个done的方法会在执行任何指令前先取得锁
done's methods acquires before doing

879
00:54:18.199 --> 00:54:19.969
于是同时
anything else so that simultaneously

880
00:54:19.969 --> 00:54:22.789
调用WaitGroup的方法
calls to a done to a WaitGroups methods

881
00:54:22.789 --> 00:54:32.170
并不构成race
aren't races we could to did a low class

882
00:54:39.519 --> 00:54:43.880
是的 当然 C++ 在C语言中
yeah for certainty C++ and in C you

883
00:54:43.880 --> 00:54:45.440
你可能需要看 pthreads
want to look at something called P

884
00:54:45.440 --> 00:54:47.389
对于C语言，线程由库提供
threads for C threads come in a library

885
00:54:47.389 --> 00:54:48.650
它们不是语言的一部分
they're not really part of the language

886
00:54:48.650 --> 00:54:51.710
叫做 pthreads 它有
called P threads which they have these

887
00:54:51.710 --> 00:54:55.420
非常传统且古老的原语
are extremely traditional and ancient

888
00:54:55.420 --> 00:55:04.449
所有的语言都有
primitives that all languages have yeah

889
00:55:06.630 --> 00:55:12.219
请重复一遍 不在这段代码里
say it again you know not in this code

890
00:55:12.219 --> 00:55:14.139
你可以想象一下WaitGroup如何使用
but you know you could imagine a use of

891
00:55:14.139 --> 00:55:15.250
我的意思是 WaitGroup只是
WaitGroups I mean WaitGroups just

892
00:55:15.250 --> 00:55:21.250
一个计数的东西 是的
count stuff and yeah yeah yeah WaitGroup

893
00:55:21.250 --> 00:55:22.989
WaitGroup并不关心
doesn't really care what you're

894
00:55:22.989 --> 00:55:27.369
你在数什么或者为什么计数 我的意思是
counding or why I mean you know this is

895
00:55:27.369 --> 00:55:45.849
这是最常见的用法
the most common way to see it use you're

896
00:55:45.849 --> 00:55:48.550
你在困惑 为什么u被作为参数
wondering why u is passed as a

897
00:55:48.550 --> 00:55:54.780
传递给58行这个函数 
parameter to the function at 58 okay

898
00:56:01.449 --> 00:56:05.889
这里function的规则是
the rules for these for a function like

899
00:56:26.380 --> 00:56:28.780
这里内部函数里的fetcher变量
what is this variable here refer to what

900
00:56:28.780 --> 00:56:30.250
指代的
does the fetcher variable refer to in

901
00:56:30.250 --> 00:56:32.980
内部函数 好吧 它指代
the inner function well it refers it's

902
00:56:32.980 --> 00:56:35.289
和外部函数中fetcher指代的
the same variable as as the fetcher in

903
00:56:35.289 --> 00:56:37.480
是同一个变量
the outer function says just is that

904
00:56:37.480 --> 00:56:38.920
所以当内部函数
variable and so when the inner function

905
00:56:38.920 --> 00:56:40.510
涉及fetcher的地方意味着
refers to fetcher it just means it's

906
00:56:40.510 --> 00:56:42.309
表示它指代的是和这里相同的变量
just referring the same variable as this

907
00:56:42.309 --> 00:56:45.670
同理f也是一样
one here and the same with F f is it's

908
00:56:45.670 --> 00:56:48.159
这里用了它 它就是这个变量
used here it's just is this variable so

909
00:56:48.159 --> 00:56:50.320
所以你可能觉得我们可以摆脱
you might think that we could get rid of

910
00:56:50.320 --> 00:56:55.989
这个u参数
the this u argument that we're passing

911
00:56:55.989 --> 00:56:57.880
就让内部函数完全不含参数
and just have the inner function take no

912
00:56:57.880 --> 00:56:59.860
直接使用
arguments at all but just use the u that

913
00:56:59.860 --> 00:57:04.530
定义在第56行循环里的u
was defined up on line 56 in the loop

914
00:57:07.389 --> 00:57:09.909
因为能让我们少打些字
because save us some typing it turns out

915
00:57:09.909 --> 00:57:12.550
但这样行不通 理由是
not to work and the reason is that the

916
00:57:17.409 --> 00:57:21.849
for循环更新了变量u
for loop updates the variable u so in

917
00:57:21.849 --> 00:57:23.619
所以在for循环的第一次迭代中
the first iteration of the for loop that

918
00:57:23.619 --> 00:57:29.380
变量u包含了某个URL
variable u contains some URL and when

919
00:57:29.380 --> 00:57:31.510
当进入for循环的第二次迭代
you enter the second iteration the for loop

920
00:57:31.510 --> 00:57:34.150
变量的内容
that variable its content are

921
00:57:34.150 --> 00:57:37.750
变成了第二个URL
changed to be the second URL and that

922
00:57:37.750 --> 00:57:39.369
这意味着 我们第一个启动的goroutine
means that the first goroutine that we

923
00:57:39.369 --> 00:57:41.530
看外部
launched that's just looking at the

924
00:57:46.929 --> 00:57:48.909
将看到u中是
we launched would see a different

925
00:57:48.909 --> 00:57:51.400
不同的值 
value in the u variable after the outer

926
00:57:51.400 --> 00:57:53.800
（因为）外部函数 已经更新了u
function it updated it and sometimes

927
00:57:53.800 --> 00:57:55.150
有时这正是你们想要的
that's actually what you want so for

928
00:58:01.599 --> 00:58:04.960
希望看到map的变化 但是
wants to see changes to that map but for

929
00:58:04.960 --> 00:58:06.489
对于u 我们不希望看到改变
u we don't want to see changes the

930
00:58:12.130 --> 00:58:13.809
所以我们希望goroutine能够有一份拷贝
want that goroutine to have a copy you

931
00:58:18.369 --> 00:58:20.559
我们也可以那么做
other ways we could have but the way

932
00:58:20.559 --> 00:58:22.150
但是这段代码的
this code happens to do it to produce

933
00:58:22.150 --> 00:58:25.630
给内部函数一个私有拷贝的方式
the copy private to that inner function

934
00:58:25.630 --> 00:58:31.860
是传递URL参数给内部函数 是的
is by passing the URLs in argument yes

935
00:58:34.449 --> 00:58:36.889
是的 如果我们把u的地址传递
yeah if we have passed the address of

936
00:58:36.889 --> 00:58:51.199
是的 事实上
u yeah then it uh it's actually I

937
00:58:51.199 --> 00:58:52.190
我不知道string怎么行得通的
don't know how strings work but it is

938
00:59:00.139 --> 00:59:08.949
变量拷贝 它 是的
copy of the variable and it yeah

939
00:59:26.500 --> 00:59:28.849
你说我们不需要
are you saying we don't need to play

940
00:59:28.849 --> 00:59:33.860
在这段代码中 用这个技巧？
this trick in the code we definitely

941
00:59:33.860 --> 00:59:35.269
我们当然需要这个技巧
need to play this trick in the code and

942
00:59:35.269 --> 00:59:37.699
实际上发生的是 它是
what's going on is this it's so the

943
00:59:37.699 --> 00:59:39.170
（学生的）问题是 既然strings是不可变的
question is Oh strings are immutable

944
00:59:39.170 --> 00:59:41.960
strings是不可变的 是的 那么
strings are immutable right yeah so how

945
00:59:41.960 --> 00:59:43.849
strings是不可变的 那么
kind of strings are immutable how can

946
00:59:43.849 --> 00:59:45.110
外部函数又是怎么改变这个string的呢
the outer function change the string

947
00:59:45.110 --> 00:59:47.719
不该有这个问题 问题并不是
there should be no problem the problem

948
00:59:47.719 --> 00:59:49.699
string被改变了
is not that the string is changed the

949
00:59:49.699 --> 00:59:51.500
问题是变量u
problem is that the variable u is

950
00:59:51.500 --> 00:59:56.150
被改变了 所以当内部函数
changed so the when the inner function

951
00:59:56.150 --> 00:59:57.860
访问一个定义在
mentions a variable that's defined in

952
01:00:03.320 --> 01:00:06.590
里面含有一个字母‘a’ 
variable that has has a in it and then

953
01:00:06.590 --> 01:00:09.110
然后你把‘B’赋值给那个string变量
you assign B to that string variable

954
01:00:09.110 --> 01:00:10.519
你并不是在重写这个string
you're not overwriting the string

955
01:00:10.519 --> 01:00:12.530
（而是）你改变了这个变量
you're changing the variable to point to

956
01:00:12.530 --> 01:00:15.949
让它指向了一个不同的string
a different string and and because the

957
01:00:15.949 --> 01:00:18.679
由于for循环改变了变量u 
for loop changes the u variable to point

958
01:00:18.679 --> 01:00:21.289
它指向了一个不同的string 你懂的
to a different string you know that

959
01:00:21.289 --> 01:00:22.969
这种改变对于内部函数
change to you would be visible inside

960
01:00:22.969 --> 01:00:24.679
是可见的 因此
the inner function and therefore the

961
01:00:24.679 --> 01:00:26.389
内部函数自己需要一个变量的拷贝
inner function needs its own copy of the

962
01:00:26.389 --> 01:00:29.260
variable

963
01:00:50.250 --> 01:00:53.110
好的 但是这正是我们在这段代码里做的
okay but that is what we're doing in

964
01:00:53.110 --> 01:00:54.670
这就是为什么是这段code
this code and that's that is why this

965
01:00:54.670 --> 01:00:56.440
能跑通的原因
code works okay

966
01:01:00.400 --> 01:01:02.849
错误的代码
broken code

967
01:01:46.440 --> 01:01:47.699
但是不幸的 
it is unfortunately one that you'll run

968
01:01:47.699 --> 01:01:50.849
你们在lab中会遇到它们
into while doing the labs so you should

969
01:01:50.849 --> 01:01:52.199
所以你们至少应该有意识 这里有个麻烦
be at least aware that there's a problem

970
01:01:52.199 --> 01:01:54.690
当你遇到这个问题时
and when you run into it maybe you can

971
01:01:54.690 --> 01:02:12.170
你可以尝试想弄清楚细节
try to figure out the details okay

972
01:02:12.170 --> 01:02:15.869
这是个很好的问题
that's a great question so so the

973
01:02:19.769 --> 01:02:21.179
如果你有一个内部函数
have an inner function that refers to a

974
01:02:21.179 --> 01:02:23.429
访问定义在外部的变量
variable in the surrounding function but

975
01:02:23.429 --> 01:02:25.980
但是外部函数返回之后
the surrounding function returns what is

976
01:02:25.980 --> 01:02:28.590
内部函数的变量将指向哪里
the inner functions variable referring

977
01:02:32.460 --> 01:02:35.190
go会注意到 go会分析你的内部函数
notices go analyzes your inner functions

978
01:02:35.190 --> 01:02:38.159
或者说闭包
or these are called closures go analyzes

979
01:02:38.159 --> 01:02:39.869
go分析它们 编译器分析它们 aha
them the compiler analyze them says aha

980
01:02:39.869 --> 01:02:41.579
oh 这个闭包 这个函数
oh this disclosure this inner function

981
01:02:41.579 --> 01:02:42.570
使用了外部函数里的变量
is using a variable in the outer

982
01:02:42.570 --> 01:02:44.309
我们实际上会
function we're actually gonna and the

983
01:02:44.309 --> 01:02:47.579
编译器会分配堆内存
compiler will allocate heap memory to

984
01:02:47.579 --> 01:02:50.670
来放这些变量 你懂的
hold the variable the you know the

985
01:02:50.670 --> 01:02:52.590
这些变量的当前的值
current value of the variable and both

986
01:02:52.590 --> 01:02:55.230
两个函数将找到
functions will refer to that that little

987
01:02:55.230 --> 01:02:58.349
堆上的那小片区域 所以
area heap that has the barrel so it

988
01:02:58.349 --> 01:02:59.760
变量不会被分配在栈上
won't be allocated the variable won't be

989
01:02:59.760 --> 01:03:01.590
如你可能预期的
on the stack as you might expect it's

990
01:03:01.590 --> 01:03:03.179
如果编译器看到闭包 
moved to the heap if if the compiler

991
01:03:03.179 --> 01:03:04.980
变量会被放到堆上
sees that it's using a closure and then

992
01:03:07.949 --> 01:03:09.840
内部函数还是能够访问到它
inner function can still get at it and

993
01:03:09.840 --> 01:03:11.820
之后垃圾回收器负责
then the garbage collector is

994
01:03:11.820 --> 01:03:13.440
监测最后一个
responsible for noticing that the last

995
01:03:13.440 --> 01:03:15.539
涉及那段堆的函数退出
function to refer to this little piece

996
01:03:15.539 --> 01:03:18.539
返回
of heap that's exited returned and to

997
01:03:18.539 --> 01:03:24.769
并且将它释放 好的
free it only then okay okay

998
01:03:24.769 --> 01:03:29.309
所以WaitGroup WaitGroup可能是
okay so WaitGroup WaitGroup is maybe

999
01:03:29.309 --> 01:03:30.630
（这节课） 更重要的话题
the more important thing here that the

1000
01:03:30.630 --> 01:03:32.550
这段代码使用这个技术
technique that this code uses to wait

1001
01:03:32.550 --> 01:03:35.719
来等待当前层所有的crawl结束
for all the all this level of crawls to

1002
01:03:35.719 --> 01:03:37.739
等待它的直系孩子结束
finish all its direct children and the

1003
01:03:37.739 --> 01:03:39.599
当然
finish is the WaitGroup of course

1004
01:03:39.599 --> 01:03:41.280
这里有很多这样的WaitGroup
there's many of these WaitGroups one

1005
01:03:41.280 --> 01:03:44.909
每次调用ConcurrentMutex函数就有一个（WaitGroup）
per call to ConcurrentMutex each call

1006
01:03:44.909 --> 01:03:46.289
ConcurrentMutex等待孩子结束
that ConcurrentMutex just waits for its

1007
01:03:46.289 --> 01:03:49.519
然后返回
own children to finish and then returns

1008
01:03:49.519 --> 01:03:53.610
好的 回到锁 实际上
okay so back to the lock actually

1009
01:03:53.610 --> 01:03:54.480
关于锁还有一个事情 我想要谈
there's one more thing I want to talk

1010
01:03:54.480 --> 01:03:56.280
那就是探究 如果我们不加锁
about with a lock and that is to explore

1011
01:03:56.280 --> 01:03:57.949
会发生什么
what would happen if we hadn't locked

1012
01:03:57.949 --> 01:04:00.690
好的 我认为 你懂的  
right I'm claiming oh you know you don't

1013
01:04:00.690 --> 01:04:02.369
你不加锁的话，你会遇到race
lock you're gonna get these races you're

1014
01:04:02.369 --> 01:04:05.210
你会得到不正确的运行结果
gonna get incorrect execution whatever

1015
01:04:14.519 --> 01:04:17.159
问题是：如果我运行这段不加锁的代码
is what happens if I run the code with

1016
01:04:17.159 --> 01:04:24.179
我将会看到什么
no locks what am I gonna see so we might

1017
01:04:24.179 --> 01:04:26.460
我们可能会看到一个URL打印两次，或者说被爬取两遍
see a url called twice or I fetch

1018
01:04:26.460 --> 01:04:28.590
是的 你会想 
twice yeah that's yeah that would be the

1019
01:04:28.590 --> 01:04:31.650
那将是个错误
error you might expect alright so I'll

1020
01:04:31.650 --> 01:04:34.800
我运行无锁的代码
run it without locks and we're looking

1021
01:04:34.800 --> 01:04:36.269
我们看ConcurrentMutex 
at the ConcurrentMutex the one in the

1022
01:04:36.269 --> 01:04:38.460
中间的这段  这次似乎没有
middle this time it doesn't seem to have

1023
01:04:38.460 --> 01:04:40.369
爬取任何URL两遍 只有五行
fetched anything twice it's only five

1024
01:04:40.369 --> 01:04:49.139
再运行一次 天哪 
run again gosh so far genius so maybe

1025
01:04:49.139 --> 01:04:50.719
我们可能在浪费时间
we're wasting our time with those locks

1026
01:04:50.719 --> 01:04:52.500
是的 似乎永远不有出错
yeah never seems to go wrong I've

1027
01:04:52.500 --> 01:04:57.420
实际上我从来没有看到它出错
actually never seen to go wrong so the

1028
01:04:57.420 --> 01:05:00.269
虽然如此 代码是错的
code is nevertheless wrong and someday

1029
01:05:00.269 --> 01:05:03.329
总有一天程序会失败 好的 问题在于
it will fail okay the problem is that

1030
01:05:03.329 --> 01:05:04.559
你懂的 
you know this is only a couple of

1031
01:05:04.559 --> 01:05:06.179
这里只是几个指令 
instructions here and so the chances of

1032
01:05:06.179 --> 01:05:07.980
而线程有几百个指令
these two threads which are maybe

1033
01:05:07.980 --> 01:05:09.539
两个线程同时执行到这几个指令
hundreds of instructions happening to

1034
01:05:09.539 --> 01:05:12.269
且犯错的几率非常低
stumble on this you know the same couple

1035
01:05:12.269 --> 01:05:14.489
undefined
of instructions at the same time is

1036
01:05:14.489 --> 01:05:17.730
确实 这是
quite low and indeed and and this is a

1037
01:05:17.730 --> 01:05:20.460
一个有race bug的代码令人失望的地方
real bummer about buggy code with races

1038
01:05:20.460 --> 01:05:23.519
它通常运行良好
is that it usually works just fine but

1039
01:05:23.519 --> 01:05:25.289
但当客户在他们的电脑上运行时
it probably won't work when the customer

1040
01:05:30.510 --> 01:05:32.940
你懂的 这可能出现在
what do we you know it it can be in

1041
01:05:32.940 --> 01:05:34.920
复杂的程序里 
complex programs quite difficult to

1042
01:05:34.920 --> 01:05:37.170
非常难搞清楚你是不有一个race
figure out if you have a race right and

1043
01:05:37.170 --> 01:05:39.389
你可能会 你可能会有一段代码
you might you may have code that just

1044
01:05:39.389 --> 01:05:41.909
看起来非常合理
looks completely reasonable that is in

1045
01:05:41.909 --> 01:05:44.610
但实际上有某些你未知的race 
fact sort of unknown to you using shared

1046
01:05:44.610 --> 01:05:47.969
是使用共享变量导致的  
variables and the answer is you really

1047
01:05:53.579 --> 01:05:55.889
go给我们提供了一个很不错的race探测器
go actually gives us this pretty good

1048
01:05:55.889 --> 01:06:00.119
内置于go 
race detector built-in to go and you

1049
01:06:00.119 --> 01:06:04.619
你应该使用它 如果你把 -race 作为命令行参数
should use it so if you pass the minus race

1050
01:06:04.619 --> 01:06:06.539
当你必须让你的go程序
flag when you have to get your go

1051
01:06:06.539 --> 01:06:09.710
运行这个race探测器
program and run this race detector which

1052
01:06:09.710 --> 01:06:11.760
好的 我将会运行race检测器
well I'll run the race detector and

1053
01:06:11.760 --> 01:06:16.650
我们将会看到 它发出了一个错误信息
we'll see so it emits an error message

1054
01:06:16.650 --> 01:06:19.679
它已经找到一个race
from us it's found a race and it

1055
01:06:19.679 --> 01:06:21.420
实际它上告诉我们
actually tells us exactly where the race

1056
01:06:21.420 --> 01:06:23.550
race发生的准确位置 输出里有很多废物
happened so there's a lot of junk in

1057
01:06:23.550 --> 01:06:25.260
但是真正关键的是
this output but the really critical

1058
01:06:25.260 --> 01:06:28.320
race检测器意识到
thing is that the race detector realize

1059
01:06:28.320 --> 01:06:30.179
我们读了一个变量
that we had read a variable that's what

1060
01:06:30.179 --> 01:06:32.789
读取的内容是之前写入的
this read is that was previously written

1061
01:06:32.789 --> 01:06:35.670
并且（这两个操作）中间
and there was no intervening release and

1062
01:06:35.670 --> 01:06:37.769
没有锁的释放和申请
acquire of a lock that's what that's

1063
01:06:37.769 --> 01:06:40.199
此外 它告诉我们
what this means furthermore it tells us

1064
01:06:40.199 --> 01:06:43.710
行号 所以它告诉我们
the line number so it's told us that the

1065
01:06:43.710 --> 01:06:49.289
读取在第43行 写入
read was a line 43 and the write the

1066
01:06:49.289 --> 01:06:51.659
之前的写入在第44行 确实
previous write was at line 44 and indeed

1067
01:06:51.659 --> 01:06:53.190
我们看代码 读操作在第43行
we look at the code and the read is on

1068
01:06:53.190 --> 01:06:56.219
写操作在第44行
line 43 and the write is at line 44 so

1069
01:06:56.219 --> 01:06:58.170
这意味着一个线程在第44行
that means that one thread did a write

1070
01:06:58.170 --> 01:07:00.869
执行了写入 
at line 44 and then without any

1071
01:07:00.869 --> 01:07:02.519
之后没有任何锁介入
intervening lock and another thread came

1072
01:07:02.519 --> 01:07:05.340
并且之后另一个线程在第43行读取了这个写入的数据
along and read that written data at line

1073
01:07:05.340 --> 01:07:07.559
这些就是race探测器寻找的
43 that's basically what the race

1074
01:07:16.260 --> 01:07:17.460
基本上对于每一个内存位置
basically for every one of your memory

1075
01:07:17.460 --> 01:07:19.710
race探测器
locations the race detector is allocated

1076
01:07:19.710 --> 01:07:21.599
都被分配了少量内存
a little bit of memory itself in which

1077
01:07:21.599 --> 01:07:24.329
用于跟踪哪些线程
it keeps track of which threads recently

1078
01:07:24.329 --> 01:07:26.400
最近读取或者写入了任何内存位置
read or wrote every single memory

1079
01:07:26.400 --> 01:07:28.590
然后
location and then when and it also to

1080
01:07:28.590 --> 01:07:30.809
它也跟踪
keep tracking keeping track of when

1081
01:07:30.809 --> 01:07:32.610
线程申请锁和释放锁
threads acquires or release locks and do

1082
01:07:32.610 --> 01:07:35.429
以及别的强制线程
other synchronization activities that it

1083
01:07:35.429 --> 01:07:37.980
以非并发形式运行的
knows forces before threads to not

1084
01:07:37.980 --> 01:07:39.179
同步活动
run concurrently

1085
01:07:39.179 --> 01:07:40.980
如果race探测器看到
and if the race detector ever sees a

1086
01:07:40.980 --> 01:07:42.449
有内存位置被写入 
ha there was a memory location that was

1087
01:07:42.449 --> 01:07:45.210
然后被读取
written and then read with no

1088
01:07:45.210 --> 01:07:49.159
而且中间没有锁 它就会报错
intervening lock it'll raise an error

1089
01:07:49.159 --> 01:08:06.599
是的 我相信这并不完美
yes I believe it is not perfect yeah I

1090
01:08:06.599 --> 01:08:12.170
我必须要思考一下
have to think about it what one

1091
01:08:12.170 --> 01:08:15.179
当然一个不完美的情况是
certainly one way it is not perfect is

1092
01:08:15.179 --> 01:08:18.899
如果你不执行任何代码
that if you if you don't execute some

1093
01:08:18.899 --> 01:08:21.270
那么race探测器不会知道任何事
code the race detector doesn't know

1094
01:08:21.270 --> 01:08:25.109
它将不会分析
anything about it so it's not analyzing

1095
01:08:25.109 --> 01:08:27.989
它并不是做静态分析
it's not doing static analysis the

1096
01:08:27.989 --> 01:08:29.220
race探测器不会看你的源代码
racing detectors not looking at your

1097
01:08:29.220 --> 01:08:31.770
不会基于源代码作出判断
source and making decisions based on the

1098
01:08:31.770 --> 01:08:33.390
某种程度上 它观察
source it's sort of watching what

1099
01:08:33.390 --> 01:08:35.699
一次具体的程序运行
happened at on this particular run of

1100
01:08:35.699 --> 01:08:37.649
所以如果这次
the program and so if this particular

1101
01:08:37.649 --> 01:08:39.329
具体的程序运行 没有执行
run of the program didn't execute some

1102
01:08:39.329 --> 01:08:42.449
某些恰好读写共享数据的代码
code that happens to read or write

1103
01:08:42.449 --> 01:08:44.369
那么race探测器不可能知道（有race）
shared data then the race detector will

1104
01:08:44.369 --> 01:08:46.500
但这里可能确实有race
never know and there could be a race

1105
01:08:46.500 --> 01:08:48.270
这是需要小心的地方
there so that's certainly something to

1106
01:08:48.270 --> 01:08:49.319
你懂的 如果你想
watch out for so you know if you're

1107
01:08:49.319 --> 01:08:50.579
认真对待race探测器
serious about the race detector you need

1108
01:08:50.579 --> 01:08:53.100
你需要设置某种测试装置
to set up sort of testing apparatus that

1109
01:08:53.100 --> 01:08:55.619
以确保所有的代码
tries to make sure all all the code is

1110
01:08:55.619 --> 01:08:59.340
都被执行 但是这是 非常好
executed but it's it's it's very good

1111
01:08:59.340 --> 01:09:01.619
你需要把它用在你的6.824lab中
and you just have to use it for your 824

1112
01:09:01.619 --> 01:09:07.829
这是这里的race 
labs okay so this is race here and

1113
01:09:07.829 --> 01:09:09.300
当然这个race没有真的发生
of course the race didn't actually occur

1114
01:09:09.300 --> 01:09:12.329
race探测器没有看到
what the race detector did not see was the

1115
01:09:12.329 --> 01:09:14.369
这些敏感代码真的同时执行交织在一起
actual interleaving simultaneous

1116
01:09:14.369 --> 01:09:17.369
execution of some sensitive code right

1117
01:09:17.369 --> 01:09:18.899
它没有看到两个线程
it didn't see two threads literally

1118
01:09:18.899 --> 01:09:21.859
同时执行第43行和第44行
execute lines 43 and 44 at the same time

1119
01:09:21.859 --> 01:09:23.970
我们知道
and as we know from having run the

1120
01:09:23.970 --> 01:09:25.140
我们已经手动运行了过几次
things by hand that apparently doesn't

1121
01:09:25.140 --> 01:09:28.319
显而易见race并没有发生 或者概率很小
happen or only with low probability all it

1122
01:09:28.319 --> 01:09:29.880
探测器看到的只是 某时刻有一个写操作
saw was at one point that was a write

1123
01:09:29.880 --> 01:09:31.529
很久之后有一个读操作
and then much later there was a

1124
01:09:31.529 --> 01:09:37.619
没有锁隔开
read with no intervening lock and so

1125
01:09:37.619 --> 01:09:39.180
从那种意义上 它能探测到
in that sense it can sort of

1126
01:09:39.180 --> 01:09:41.539
不一定真的会发生的race
detect races that didn't actually happen

1127
01:09:41.539 --> 01:09:47.630
或者不会真的导致bug
or didn't really cause bugs okay

1128
01:09:49.539 --> 01:09:52.550
好的 最后一个关于这个crawler的问题
okay one final question about this this

1129
01:09:52.550 --> 01:09:57.550
它创建了多少个线程
crawler how many threads does it create

1130
01:10:03.640 --> 01:10:10.119
最多有多少个并发的线程
yeah and how many concurrent threads

1131
01:10:10.119 --> 01:10:24.970
是的 这个crawler的缺陷是
could there be yeah so a defect in this

1132
01:10:24.970 --> 01:10:27.159
没有一个明显的
crawler is that there's no obvious bound

1133
01:10:27.159 --> 01:10:28.720
同时存在线程的
on the number of simultaneous threads

1134
01:10:28.720 --> 01:10:30.579
数量界限 你懂的 
that might create you know with the test

1135
01:10:30.579 --> 01:10:32.800
在这个测试数据下，只有5个URL
case which only has five URLs big

1136
01:10:32.800 --> 01:10:34.659
如果你爬取真实的网络
whoopee but if you're crawling a real

1137
01:10:34.659 --> 01:10:36.609
真实的网络 我不确定
real web with you know I don't know are

1138
01:10:36.609 --> 01:10:38.380
有数十亿的URL在那儿
there billions of URLs out there maybe

1139
01:10:38.380 --> 01:10:40.390
我们当然不希望
not we certainly don't want to be in a

1140
01:10:40.390 --> 01:10:41.380
遇到这种情况 crawler可能
position where the crawler might

1141
01:10:41.380 --> 01:10:43.380
意外地创建了数十亿计的线程
accidentally create billions of threads

1142
01:10:43.380 --> 01:10:46.119
因为 你懂的 几千个线程 
because you know thousands of threads

1143
01:10:46.119 --> 01:10:47.890
没问题 数十亿计个线程是不行
it's just fine billions of threads it's

1144
01:10:58.270 --> 01:11:00.220
它确实创建太多线程
talking about is that it does create too

1145
01:11:00.220 --> 01:11:01.600
最好有一种方式
many threads and really ought to have a

1146
01:11:01.600 --> 01:11:03.279
可以创建 好比20,000个
way of saying well you can create 20

1147
01:11:03.279 --> 01:11:04.630
或100个 或1000个线程
threads or 100 threads or a thousand

1148
01:11:04.630 --> 01:11:06.520
但是不会更多
threads but no more so one way to do

1149
01:11:06.520 --> 01:11:08.199
一个方式是预先创建
that would be to pre-create a pool a

1150
01:11:13.180 --> 01:11:14.829
寻找下一个要爬取的URL
another URL to crawl crawl that URL

1151
01:11:14.829 --> 01:11:18.159
而不是为每个URL创建新的线程
rather than creating a new thread for

1152
01:11:23.229 --> 01:11:25.600
它的实现方式显著不同
implemented in a significantly

1153
01:11:25.600 --> 01:11:28.779
使用了channel 
different way using channels instead of

1154
01:11:28.779 --> 01:11:31.869
而不是共享内存
shared memory remember on the mutex

1155
01:11:31.869 --> 01:11:33.489
回忆之前的版本
call or I just said there is this table

1156
01:11:33.489 --> 01:11:34.840
记录URL的表格被所有线程共享
of URLs recorded that's shared

1157
01:11:34.840 --> 01:11:36.550
必须加锁
between all the threads has to be

1158
01:11:36.550 --> 01:11:40.329
这个版本没有这样一个（共享）的表格
locked this version does not have such a

1159
01:11:40.329 --> 01:11:44.439
没有共享内存
table does not share memory and does not

1160
01:11:44.439 --> 01:11:52.510
不需要使用锁 好的
need to use locks okay so this one the

1161
01:11:57.789 --> 01:12:00.699
它有一个表格
line 86 and it has a table but the

1162
01:12:00.699 --> 01:12:02.800
但是这个表格是master函数私有的
table is private to the master function

1163
01:12:02.800 --> 01:12:06.689
master函数并不像前一个版本那样
and what the master function is doing is

1164
01:12:06.689 --> 01:12:09.220
创建
instead of sort of basically creating a

1165
01:12:09.220 --> 01:12:11.409
一棵函数调用树
tree of functions that corresponds to

1166
01:12:11.409 --> 01:12:13.329
以对应图结构的搜索
the exploration of the graph which the

1167
01:12:13.329 --> 01:12:17.939
这个版本
previous crawler did this one fires off just

1168
01:12:17.939 --> 01:12:21.880
为每个URL创建一个goroutine
one u one goroutine per URL that is

1169
01:12:21.880 --> 01:12:23.770
但是只由master来创建
fetches and that but it's only the

1170
01:12:23.770 --> 01:12:26.560
只有唯一一个master
master only the one master that's

1171
01:12:26.560 --> 01:12:28.300
创建这些线程 所以我们没有
creating these threads so we don't have

1172
01:12:28.300 --> 01:12:30.130
一个函数的树形结构
a tree of functions creating threads we

1173
01:12:30.130 --> 01:12:35.199
我们只有一个master 好的
just have the one master okay so it

1174
01:12:35.199 --> 01:12:37.539
它在第88行创建了自己的私有的map
creates its own private map at line 88

1175
01:12:37.539 --> 01:12:41.550
记录哪些URL已经爬取
this record what it's fetched and then

1176
01:12:41.550 --> 01:12:44.649
然后创建一个channel
it also creates a channel just a single

1177
01:12:44.649 --> 01:12:46.899
只有一个channel 所有的worker线程
channel that all of its worker threads

1178
01:12:46.899 --> 01:12:49.119
都将通过这个channel沟通
are going to talk to and the idea is

1179
01:12:49.119 --> 01:12:50.699
这个思路是 启动一个worker线程
that it's gonna fire up a worker thread

1180
01:12:55.630 --> 01:12:58.149
只会通过channel发送恰好一份数据
page will send exactly one item back to

1181
01:12:58.149 --> 01:13:00.250
给master
the master on the channel and that item

1182
01:13:00.250 --> 01:13:03.220
这份数据包含了这个worker
will be a list of the URLs in the page

1183
01:13:03.220 --> 01:13:07.960
从网页上爬取的网页中的URL的列表
that that worker thread fetched so the

1184
01:13:07.960 --> 01:13:10.420
master在第89行循环中 从channel中
master sits in a loop we're in line

1185
01:13:10.420 --> 01:13:13.989
读取数据
89 is reading entries from the

1186
01:13:13.989 --> 01:13:16.779
我们想象
channel and so we have to imagine that

1187
01:13:16.779 --> 01:13:20.470
它已经预先启动一些worker
it's started up some workers in advance

1188
01:13:20.470 --> 01:13:22.840
现在读取
and now it's reading the information the

1189
01:13:22.840 --> 01:13:24.489
这些worker发回的URL列表
URL lists that those workers send back

1190
01:13:24.489 --> 01:13:26.829
每当89行拿到一个URL
and each time he gets a URLs is sitting

1191
01:13:26.829 --> 01:13:28.810
它遍历
on line 89 it then loops over

1192
01:13:28.810 --> 01:13:32.619
这些从爬取的网页中获得的
the URLs in that URL list from a single

1193
01:13:32.619 --> 01:13:36.100
URL列表里的URL
page fetch at line 90 and if the URL

1194
01:13:36.100 --> 01:13:39.970
如果URL还未被爬取，它将在第94行
hasn't already been fetched it fires off

1195
01:13:39.970 --> 01:13:42.189
启动一个新的worker去爬取那个URL 
a new worker at line 94 to fetch that

1196
01:13:42.189 --> 01:13:44.800
我们看worker代码
URL and if we look at the worker code

1197
01:13:44.800 --> 01:13:47.319
第77行 从第77行开始 大概是说
on line starting on line 77 basically calls

1198
01:13:47.319 --> 01:13:51.130
调用fetcher 然后第80行，82行
his fetcher and then sends a message on

1199
01:13:51.130 --> 01:13:53.710
发送信息给channel
the channel at line 80 or 82 saying

1200
01:13:53.710 --> 01:13:57.930
这是爬取的网页中的URLs
here's the URLs in the page they fetched

1201
01:13:57.930 --> 01:14:01.170
注意到
and notice that now that the maybe

1202
01:14:01.170 --> 01:14:03.640
可能有趣的事情是
interesting thing about this is that the

1203
01:14:03.640 --> 01:14:07.989
worker线程不共享任何对象
worker threads don't share any objects

1204
01:14:07.989 --> 01:14:10.210
worker和master之间
there's no shared object between the

1205
01:14:10.210 --> 01:14:11.529
也不共享任何对象
workers and the master so we don't have

1206
01:14:11.529 --> 01:14:12.850
所以我们不必担心锁
to worry about locking we don't have to

1207
01:14:12.850 --> 01:14:16.359
我们不必担心race
worry about races instead this is a

1208
01:14:16.359 --> 01:14:18.939
这是通信的例子
example of sort of communicating

1209
01:14:18.939 --> 01:14:21.100
而不是通过
information instead of getting at it

1210
01:14:21.100 --> 01:14:25.619
共享内存 是的
through shared memory yes

1211
01:14:33.930 --> 01:14:38.140
是的 可以观察到
yeah yeah so the observation is that the

1212
01:14:38.140 --> 01:14:40.810
代码看上去好像 但是worker是
code appears but the workers are the

1213
01:14:40.810 --> 01:14:42.250
可以观察到 worker在改变channel
observation is the workers are modifying

1214
01:14:42.250 --> 01:14:47.130
同时master在读channel
ch while the master is reading it and

1215
01:14:49.170 --> 01:14:51.520
go的作者不会希望
that's not the way the go authors would

1216
01:14:51.520 --> 01:14:54.159
你们这样理解
like you to think about this the way

1217
01:14:54.159 --> 01:14:55.359
他们希望你这么思考
they want you to think about this is

1218
01:15:05.260 --> 01:15:09.250
这完全合法 channel毫无压力
that's perfectly legal the channel is

1219
01:15:12.789 --> 01:15:15.609
有一个互斥锁
channel has a mutex in it and the

1220
01:15:20.859 --> 01:15:22.449
使用了互斥锁
the channels internal data to ensure

1221
01:15:22.449 --> 01:15:24.189
来保证 
that it doesn't actually have any

1222
01:15:24.189 --> 01:15:27.579
实际上没有任何race 是的
races in it but yeah channels are sort

1223
01:15:27.579 --> 01:15:29.289
channel被保护了起来 免受并发风险
of protected against concurrency and

1224
01:15:29.289 --> 01:15:30.399
你可以在不同的线程中
you're allowed to use them concurrently

1225
01:15:30.399 --> 01:15:34.680
并发地使用它 是的
from different threads yes

1226
01:15:36.390 --> 01:15:43.189
通过channel接收 是的
over the channel receive yes

1227
01:15:53.810 --> 01:15:56.260
我们不需要关闭channel
we don't need to close the channel I

1228
01:15:56.260 --> 01:15:58.850
我的意思是 好吧 这个break语句
mean okay the the break statement is

1229
01:15:58.850 --> 01:16:00.590
当crawl完全结束
about when the crawl has completely

1230
01:16:00.590 --> 01:16:03.159
我们爬取了每个URL 
finished and we fetched every single URL

1231
01:16:03.159 --> 01:16:06.409
发生的事情是
right because hey what's going on is the

1232
01:16:06.409 --> 01:16:09.229
master持续  我的意思是 这个n
master is keeping I mean this n value is

1233
01:16:09.229 --> 01:16:13.189
是私有的 每当master
private value and a master every time it

1234
01:16:13.189 --> 01:16:14.859
启动一个worker 会增加n
fires off a worker increments the n

1235
01:16:14.859 --> 01:16:17.359
每个启动的worker
though every worker it starts sends

1236
01:16:17.359 --> 01:16:20.479
发送恰好一个东西到channel上
exactly one item on the channel and so

1237
01:16:20.479 --> 01:16:21.920
所以每次master从channel读取一个
every time the master reads an item off

1238
01:16:21.920 --> 01:16:23.119
就能知道 一个worker
the channel it knows that one of his

1239
01:16:23.119 --> 01:16:24.920
已经结束 当worker数目
workers is finished and when the number

1240
01:16:32.869 --> 01:16:34.520
当所有worker的数目降为0
of outstanding workers goes to zero then

1241
01:16:34.520 --> 01:16:36.500
之后唯一引用channel的
the only reference to the channel is

1242
01:16:36.500 --> 01:16:40.369
是master函数 或者
from the master or from oh really from

1243
01:16:40.369 --> 01:16:41.779
是调用master的代码
the code that calls the master and so

1244
01:16:41.779 --> 01:16:43.460
垃圾回收器很快看到
the garbage collector will very soon see

1245
01:16:43.460 --> 01:16:45.260
这个channel没有被引用
that the channel has no references to it

1246
01:16:45.260 --> 01:16:48.680
将会释放这个channel
and will free the channel so in this

1247
01:16:53.630 --> 01:16:56.170
关闭channel
close channels

1248
01:17:09.750 --> 01:17:12.220
问题说的是 
so the question is alright so you can

1249
01:17:12.220 --> 01:17:16.390
看第106行 在调用master之前
see at line 106 before calling master

1250
01:17:16.390 --> 01:17:19.949
并发channel某种程度启动了一个
concurrent channel sort of fires up one

1251
01:17:19.949 --> 01:17:25.659
把一个URL塞进了channel
shoves one URL into the channel and it's

1252
01:17:25.659 --> 01:17:26.710
这样开始整个流程
to sort of get the whole thing started

1253
01:17:29.470 --> 01:17:31.750
从channel读取数据
reading from the channel line 89 so

1254
01:17:31.750 --> 01:17:33.489
所以最开始channel中要有数据
there better be something in the channel

1255
01:17:33.489 --> 01:17:36.550
否则89行将永远阻塞
otherwise line 89 would block forever so

1256
01:17:36.550 --> 01:17:38.260
如果没有107行的代码
if it weren't for that little code at

1257
01:17:38.260 --> 01:17:42.550
89行将block在读channel上
line 107 the for loop at 89 would block

1258
01:17:54.460 --> 01:17:56.289
一个观察是 天哪 如果
observation is gosh you know wouldn't it

1259
01:17:56.289 --> 01:17:57.510
写出的代码 
be nice to be able to write code that

1260
01:17:57.510 --> 01:17:59.529
能够注意到
would be able to notice if there's

1261
01:17:59.529 --> 01:18:01.569
是否有东西在等待channel 就好了
nothing waiting on the channel and you

1262
01:18:01.569 --> 01:18:03.220
如果你去看select语句 你可以做到
can if you look up the Select statement

1263
01:18:06.579 --> 01:18:09.460
让你免于block 继续执行
allows you to proceed to not block if

1264
01:18:09.460 --> 01:18:11.140
如果没有等待在channel
something if there's nothing waiting on

1265
01:18:11.140 --> 01:18:13.590
如果没有等待在channel
the channel

1266
01:18:44.590 --> 01:18:59.600
因为worker没有结束 好的 抱歉
because the worker aren't finish okay sorry

1267
01:18:59.600 --> 01:19:02.600
对于第一个问题 我觉得
to the first question is there I think

1268
01:19:02.600 --> 01:19:03.829
你真正担心的是
what you're really worried about is

1269
01:19:03.829 --> 01:19:05.630
我们是否真的能够并行启动
whether we're actually able to launch

1270
01:19:05.630 --> 01:19:09.109
最开始的第一个fetch不会并行
parallel so the very first fetch won't be

1271
01:19:09.109 --> 01:19:37.220
因为
in parallel because there's an exit

1272
01:19:37.220 --> 01:19:40.270
不 不 不 for循环在第89行等待
no no no the for-loop waits in at line 89

1273
01:19:40.270 --> 01:19:44.449
89行的for loop
that's not okay that for loop at line 89

1274
01:19:44.449 --> 01:19:47.659
并不是 遍历当前channel的内容
is does not just loop over the current

1275
01:19:47.659 --> 01:19:49.189
然后退出
contents of the channel and then quit

1276
01:19:49.189 --> 01:19:54.229
89行的for循环将会读 
that is the for loop at 89 is going to

1277
01:19:54.229 --> 01:19:58.100
它可以永不退出
read it may never exit but it's gonna

1278
01:19:58.100 --> 01:19:59.779
它将一直等待
read it's just going to keep waiting

1279
01:19:59.779 --> 01:20:01.130
直到有东西出现在channel中
until something shows up in the channel

1280
01:20:01.130 --> 01:20:04.279
所以 如果没有第99行的break
so if you don't hit the break at line 99

1281
01:20:04.279 --> 01:20:10.250
for循环不会被结束 是的 好
the for loop won't exit yeah alright I'm

1282
01:20:10.250 --> 01:20:12.439
恐怕我们时间到了 我们会继续
afraid we're out of time we'll continue

1283
01:20:12.439 --> 01:20:15.800
事实上我们的助教安排了一场展示
this actually we have a presentation

1284
01:20:15.800 --> 01:20:18.260
在那儿会聊更多关于go的话题
scheduled by the TAs which will talk more about go

