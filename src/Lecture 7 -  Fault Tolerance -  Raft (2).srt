1
00:00:01,000 --> 00:00:06,870
let's imagine three servers with logs

2
00:00:07,070 --> 00:00:13,200
that looked like this where the numbers

3
00:00:13,400 --> 00:00:15,120
I'm writing are the term numbers of the

4
00:00:15,320 --> 00:00:16,859
command that's in that log entry so we

5
00:00:17,059 --> 00:00:18,300
don't really care what the actual

6
00:00:18,500 --> 00:00:20,579
commands are then I got a number the log

7
00:00:20,778 --> 00:00:35,089
slots and so let's imagine that the

8
00:00:35,289 --> 00:00:38,640
presumably the the next term is term six

9
00:00:38,840 --> 00:00:40,619
although you can't actually tell that

10
00:00:40,820 --> 00:00:42,299
from looking the evidence on the board

11
00:00:42,500 --> 00:00:44,570
but it must be at least six or greater

12
00:00:44,770 --> 00:00:47,279
let's imagine that server s3 is chosen

13
00:00:47,479 --> 00:00:52,378
as the leader for term six and at some

14
00:00:52,579 --> 00:00:55,919
point s3 the new leader is going to want

15
00:00:56,119 --> 00:00:58,108
to send out a new log entry so let's

16
00:00:58,308 --> 00:00:59,909
suppose it wants to send out its first

17
00:01:00,109 --> 00:01:02,788
log entry per term six so we're sort of

18
00:01:02,988 --> 00:01:04,259
thinking about the append entries our

19
00:01:04,459 --> 00:01:06,000
PCs that the leader is going to send out

20
00:01:06,200 --> 00:01:11,099
to carry the first log entry for term

21
00:01:11,299 --> 00:01:13,698
six really should be under slot thirteen

22
00:01:13,899 --> 00:01:16,259
the rules in Figure two say that an

23
00:01:16,459 --> 00:01:18,719
append entries are bc actually as - as

24
00:01:18,920 --> 00:01:21,899
well as the command that the client sent

25
00:01:22,099 --> 00:01:22,918
in to the leader that we want to

26
00:01:23,118 --> 00:01:24,838
replicate on the logs of all the

27
00:01:25,039 --> 00:01:27,929
followers there's this append entries

28
00:01:28,129 --> 00:01:33,078
RPC also contains this previous log

29
00:01:33,278 --> 00:01:39,268
index field and a previous log term

30
00:01:39,468 --> 00:01:44,069
field and when we're sending out an end

31
00:01:44,269 --> 00:01:46,228
pend entries for where this is the first

32
00:01:46,429 --> 00:01:48,658
entry we're leaders supposed to put

33
00:01:48,858 --> 00:01:51,179
information about the previous slot the

34
00:01:51,379 --> 00:01:54,478
slot before the new information sending

35
00:01:54,679 --> 00:01:56,968
out so in this case the log index of the

36
00:01:57,168 --> 00:02:03,828
previous entry is 12 and the term of the

37
00:02:04,028 --> 00:02:06,509
command in the leaders log for the

38
00:02:06,709 --> 00:02:10,558
previous entry is by so sends out this

39
00:02:10,758 --> 00:02:13,200
information to the followers

40
00:02:13,400 --> 00:02:16,209
and the followers before they accept a

41
00:02:16,408 --> 00:02:18,759
upend entries are supposed to check you

42
00:02:18,959 --> 00:02:19,689
know they know they've received an

43
00:02:19,889 --> 00:02:23,709
append entries that for some log entries

44
00:02:23,908 --> 00:02:26,649
that start here and the first thing they

45
00:02:26,848 --> 00:02:29,110
do is check that there are previous the

46
00:02:29,310 --> 00:02:30,730
receiving followers check that their

47
00:02:30,930 --> 00:02:34,000
previous log entry matches the previous

48
00:02:34,199 --> 00:02:35,920
information that follow that the leader

49
00:02:36,120 --> 00:02:38,110
sent out so for a server to of course it

50
00:02:38,310 --> 00:02:42,160
doesn't match the server to has a entry

51
00:02:42,360 --> 00:02:43,750
here all right but it's an entry from

52
00:02:43,949 --> 00:02:46,599
term for not from turn five and so the

53
00:02:46,799 --> 00:02:49,149
server twos going to reject this append

54
00:02:49,348 --> 00:02:50,860
entries and sort of send a false reply

55
00:02:51,060 --> 00:02:54,490
back leader and server one doesn't even

56
00:02:54,689 --> 00:02:56,500
have anything here so server ones gonna

57
00:02:56,699 --> 00:02:59,800
also reject the append entries in the

58
00:03:00,000 --> 00:03:03,280
leader and so so far so good right the

59
00:03:03,479 --> 00:03:05,618
terrible thing that that has been

60
00:03:05,818 --> 00:03:08,020
averted at this point is you know the

61
00:03:08,219 --> 00:03:09,789
bad thing we absolutely don't want to

62
00:03:09,989 --> 00:03:11,830
see is that server to actually stuck the

63
00:03:12,030 --> 00:03:15,009
new blog entry in here which would break

64
00:03:15,209 --> 00:03:20,080
sort of inductive proofs essentially

65
00:03:20,280 --> 00:03:24,399
that the figure to scheme relies on and

66
00:03:24,598 --> 00:03:27,159
hide the fact that server two actually

67
00:03:27,359 --> 00:03:28,599
had a different log so instead of

68
00:03:28,799 --> 00:03:30,099
accepting log entry server two projects

69
00:03:30,299 --> 00:03:34,240
this RPC the leader sees is two

70
00:03:34,439 --> 00:03:35,950
rejections and leader is maintaining

71
00:03:36,150 --> 00:03:38,129
this next index field one for each

72
00:03:38,329 --> 00:03:44,999
follower so it has a next index for

73
00:03:45,199 --> 00:03:48,429
server two and the leader has a next

74
00:03:48,628 --> 00:03:54,460
index for server one presumably if the

75
00:03:54,659 --> 00:03:55,929
should have said this before if the

76
00:03:56,128 --> 00:03:58,230
server sending out information about

77
00:03:58,430 --> 00:04:01,689
slot thirteen here that must mean that

78
00:04:01,889 --> 00:04:03,670
the server's next index is for both of

79
00:04:03,870 --> 00:04:08,890
these other servers this started out as

80
00:04:09,090 --> 00:04:10,899
thirteen and that would be the case at

81
00:04:11,098 --> 00:04:13,030
the server if this leader had just

82
00:04:13,229 --> 00:04:14,740
restarted because the figure two rules

83
00:04:14,939 --> 00:04:16,449
say that next index starts out at the

84
00:04:16,649 --> 00:04:21,038
end of the new leaders log and so in

85
00:04:21,238 --> 00:04:23,560
response to errors the leaders supposed

86
00:04:23,759 --> 00:04:25,780
to decrement its next in

87
00:04:25,980 --> 00:04:28,270
steal so it does that for both got

88
00:04:28,470 --> 00:04:34,509
errors from boat deca mr. Calvin resends

89
00:04:34,709 --> 00:04:36,100
and this time the server is going to

90
00:04:36,300 --> 00:04:39,250
send out append entries with previous

91
00:04:39,449 --> 00:04:41,579
log index equals 11

92
00:04:41,779 --> 00:04:47,230
and previous log term equals 3 and this

93
00:04:47,430 --> 00:04:50,139
new append entries has it has a

94
00:04:50,339 --> 00:04:53,050
different previous log index but it's

95
00:04:53,250 --> 00:04:55,600
the content in the log entries that the

96
00:04:55,800 --> 00:04:57,939
server is going to send out this time

97
00:04:58,139 --> 00:05:01,210
include you know all the entries after

98
00:05:01,410 --> 00:05:03,220
that the new previous log index is

99
00:05:03,420 --> 00:05:06,040
sending out so server 2 now the previous

100
00:05:06,240 --> 00:05:10,509
log index 11 it looks there and it sees

101
00:05:10,709 --> 00:05:12,759
a ha you know the term is 3 same as what

102
00:05:12,959 --> 00:05:15,310
the reader is sending me so server 2 is

103
00:05:15,509 --> 00:05:17,020
actually going to accept this append

104
00:05:17,220 --> 00:05:20,319
entries and figure 2 rules say oh if you

105
00:05:20,519 --> 00:05:22,240
accept a pendent we supposed to delete

106
00:05:22,439 --> 00:05:23,829
everything in your log after where the

107
00:05:24,029 --> 00:05:25,840
append entry starts and replace it with

108
00:05:26,040 --> 00:05:28,139
whatever's in the append entries so

109
00:05:28,339 --> 00:05:32,359
server tune is going to do that now it's

110
00:05:32,810 --> 00:05:35,560
he just went to 5 6 server 1 still has a

111
00:05:35,759 --> 00:05:38,379
problem cuz it has nothing at slot 11

112
00:05:38,579 --> 00:05:41,530
middle would return another error the

113
00:05:41,730 --> 00:05:47,530
server will now backup its server 1 next

114
00:05:47,730 --> 00:05:51,040
index 2 11 it'll send out its log

115
00:05:51,240 --> 00:05:54,129
starting here with the previous index

116
00:05:54,329 --> 00:05:56,139
and term referring now to this slot and

117
00:05:56,339 --> 00:05:58,050
this one's actually acceptable server 1

118
00:05:58,250 --> 00:06:00,790
it'll adopt it'll accept the new log

119
00:06:00,990 --> 00:06:02,920
entries and send a positive response

120
00:06:03,120 --> 00:06:06,740
back to the server and now they're all

121
00:06:07,670 --> 00:06:13,879
now they're all caught up and the

122
00:06:14,720 --> 00:06:17,680
presumably the server also when it sees

123
00:06:17,879 --> 00:06:21,220
that followers accepted and append

124
00:06:21,420 --> 00:06:22,720
entries that had a certain number of log

125
00:06:22,920 --> 00:06:24,160
entries it actually increments this next

126
00:06:24,360 --> 00:06:28,870
index could be 14 4 alright so the net

127
00:06:29,069 --> 00:06:30,819
effect of all this backing up is that

128
00:06:31,019 --> 00:06:32,889
the server has used a backup mechanism

129
00:06:33,089 --> 00:06:36,569
to detect the point at which the

130
00:06:36,769 --> 00:06:38,170
followers logs

131
00:06:38,370 --> 00:06:39,560
started to be equal to this

132
00:06:39,759 --> 00:06:42,230
servers and then sent each of the

133
00:06:42,430 --> 00:06:43,699
followers starting from that point that

134
00:06:43,899 --> 00:06:47,079
a complete remainder of the server's log

135
00:06:47,279 --> 00:06:49,610
after that last point at which they were

136
00:06:49,810 --> 00:07:01,889
equal any questions all right

137
00:07:01,920 --> 00:07:05,540
just to repeat discussion we've had

138
00:07:05,740 --> 00:07:07,790
before and we'll probably have again you

139
00:07:07,990 --> 00:07:09,590
notice that we erased some blog entries

140
00:07:09,790 --> 00:07:11,540
here which are now su erase that I

141
00:07:11,740 --> 00:07:14,810
forget what they were 4 & 5 so there

142
00:07:15,009 --> 00:07:18,370
were some well actually that was mostly

143
00:07:18,569 --> 00:07:21,110
remember we erased this log entry here

144
00:07:21,310 --> 00:07:24,560
this used to say for um server - the

145
00:07:24,759 --> 00:07:27,259
question is why was it ok for the system

146
00:07:27,459 --> 00:07:29,240
to forget about this client command

147
00:07:29,439 --> 00:07:31,970
right this thing we erased corresponds

148
00:07:32,170 --> 00:07:33,170
to some client command which are now

149
00:07:33,370 --> 00:07:36,770
throwing away I talked about this

150
00:07:36,970 --> 00:07:42,590
yesterday what's the rationale here yeah

151
00:07:42,790 --> 00:07:44,840
so it's not a majority of the servers

152
00:07:45,040 --> 00:07:46,520
and therefore whatever previous leader

153
00:07:46,720 --> 00:07:49,100
it was who sent this out couldn't have

154
00:07:49,300 --> 00:07:51,110
gotten acknowledgments from a majority

155
00:07:51,310 --> 00:07:52,610
of servers therefore that previous

156
00:07:52,810 --> 00:07:55,040
leader couldn't have decided it was

157
00:07:55,240 --> 00:07:57,199
committed couldn't have executed it and

158
00:07:57,399 --> 00:07:58,730
applied it to the application state

159
00:07:58,930 --> 00:08:00,770
could never have sent a positive reply

160
00:08:00,970 --> 00:08:03,379
back to the client so because this isn't

161
00:08:03,579 --> 00:08:05,120
done a majority of servers we know that

162
00:08:05,319 --> 00:08:06,860
the client who send in and has no reason

163
00:08:07,060 --> 00:08:08,660
to believe it was executed couldn't have

164
00:08:08,860 --> 00:08:10,040
gotten a reply because one of the rules

165
00:08:10,240 --> 00:08:12,740
is the server only sends over the leader

166
00:08:12,939 --> 00:08:14,870
only sends a reply to a client after it

167
00:08:15,069 --> 00:08:18,889
commits and executes so the client had

168
00:08:19,089 --> 00:08:20,180
no reason to believe it was even

169
00:08:20,379 --> 00:08:23,180
received by any server and then and the

170
00:08:23,379 --> 00:08:24,530
rules of figure to basically say the

171
00:08:24,730 --> 00:08:26,389
client if he gets no response after a

172
00:08:26,589 --> 00:08:27,680
while it supposed to resend the request

173
00:08:27,879 --> 00:08:29,600
so we know whatever request this was it

174
00:08:29,800 --> 00:08:33,500
threw away we've never executed never

175
00:08:33,700 --> 00:08:35,839
included in any state already and the

176
00:08:36,039 --> 00:08:41,159
clients gonna resend it by-and-by yes

177
00:08:58,440 --> 00:09:03,259
well it's always deleting suffix of the

178
00:09:03,460 --> 00:09:08,089
followers log I mean in the end the sort

179
00:09:08,289 --> 00:09:10,549
of backup answer to this is that the

180
00:09:10,750 --> 00:09:13,639
leader has a complete log so all its

181
00:09:13,840 --> 00:09:16,309
fails it can just send us complete log

182
00:09:16,509 --> 00:09:19,069
to the follower and indeed if you know

183
00:09:19,269 --> 00:09:20,389
if you've just started up the system and

184
00:09:20,590 --> 00:09:22,189
something very strange happened even at

185
00:09:22,389 --> 00:09:24,679
the very beginning then you may end up

186
00:09:24,879 --> 00:09:25,939
actually you know maybe in some of the

187
00:09:26,139 --> 00:09:28,579
tests for lab two you may end up backing

188
00:09:28,779 --> 00:09:31,129
up to the very first entry and then

189
00:09:31,330 --> 00:09:32,719
having the leader essentially send the

190
00:09:32,919 --> 00:09:33,979
whole log but because the leader has

191
00:09:34,179 --> 00:09:35,419
this whole law we know it could sort of

192
00:09:35,620 --> 00:09:37,129
it's got all the information that's

193
00:09:37,330 --> 00:09:40,129
required to feel everybody's logs if it

194
00:09:40,330 --> 00:09:42,570
needs to

195
00:09:49,259 --> 00:09:53,750
okay all right so in this example which

196
00:09:53,950 --> 00:09:57,649
I guess are now erased we elected s3 as

197
00:09:57,850 --> 00:10:02,479
the leader and the question is could we

198
00:10:02,679 --> 00:10:04,669
you know who can we who are we allowed

199
00:10:04,870 --> 00:10:08,629
to elect this leader right cool

200
00:10:08,830 --> 00:10:10,639
you know that all right if you read the

201
00:10:10,840 --> 00:10:12,529
paper you know the answer is not just

202
00:10:12,730 --> 00:10:15,469
anyone it turns out it matters a lot for

203
00:10:15,669 --> 00:10:17,209
the correctness the correctness of the

204
00:10:17,409 --> 00:10:19,699
system that we don't allow just anyone

205
00:10:19,899 --> 00:10:21,469
to be the leader like for example the

206
00:10:21,669 --> 00:10:24,409
first node whose timer goes off may in

207
00:10:24,610 --> 00:10:27,949
fact not be an acceptable leader and so

208
00:10:28,149 --> 00:10:29,599
it turns out raft has some rules that

209
00:10:29,799 --> 00:10:32,419
applies about oh yes you can be leader

210
00:10:32,620 --> 00:10:35,240
or you can't be leader and to see why

211
00:10:35,440 --> 00:10:36,799
this is true let's sort of set up a

212
00:10:37,000 --> 00:10:42,889
straw man proposal that maybe raft

213
00:10:43,090 --> 00:10:45,919
should accept should use the server with

214
00:10:46,120 --> 00:10:49,009
the longest log as the leader right you

215
00:10:49,210 --> 00:10:50,629
know some alternate universe that could

216
00:10:50,830 --> 00:10:52,219
be true and it is actually true in

217
00:10:52,419 --> 00:10:54,799
systems with different designs just not

218
00:10:55,000 --> 00:10:57,139
in raft so the question we're

219
00:10:57,340 --> 00:11:02,059
investigating is why not use the

220
00:11:02,259 --> 00:11:09,709
cervical longest law as leader and this

221
00:11:09,909 --> 00:11:11,509
would involve changing the voting rules

222
00:11:11,710 --> 00:11:15,889
in raft have a voters only vote for

223
00:11:16,090 --> 00:11:19,399
nodes that have longer logs all right so

224
00:11:19,600 --> 00:11:21,409
the example that's going to be

225
00:11:21,610 --> 00:11:22,879
convenient for showing why this is a bad

226
00:11:23,080 --> 00:11:25,699
idea so let's imagine we have three

227
00:11:25,899 --> 00:11:29,779
servers again and now the log set setups

228
00:11:29,980 --> 00:11:34,159
are server Wan has entries for terms

229
00:11:34,360 --> 00:11:38,329
five six and seven server two four five

230
00:11:38,529 --> 00:11:41,750
and eight and server three also four

231
00:11:41,950 --> 00:11:46,699
five and eight that's the first question

232
00:11:46,899 --> 00:11:49,819
of course to avoid spending our time

233
00:11:50,019 --> 00:11:51,409
scratching our heads about utter

234
00:11:51,610 --> 00:11:54,319
nonsense is to make sure that convince

235
00:11:54,519 --> 00:11:56,120
ourselves that this configuration could

236
00:11:56,320 --> 00:11:57,859
actually arise because if it couldn't

237
00:11:58,059 --> 00:11:59,599
possibly arise then

238
00:11:59,799 --> 00:12:01,189
may be a waste of time to figure out

239
00:12:01,389 --> 00:12:03,559
what would happen if it did arise so

240
00:12:03,759 --> 00:12:07,429
anybody wanna propose a sequence of

241
00:12:07,629 --> 00:12:10,578
events whereby this set of logs could

242
00:12:10,778 --> 00:12:16,939
have arisen how about an argument that

243
00:12:17,139 --> 00:12:26,959
it couldn't have arisen oh yeah okay so

244
00:12:27,159 --> 00:12:31,649
well maybe we'll back up sometime

245
00:12:31,799 --> 00:12:34,250
all right so server one wins is wins the

246
00:12:34,450 --> 00:12:36,949
election at this point and it's in term

247
00:12:37,149 --> 00:12:42,319
six sends out yeah it receives a client

248
00:12:42,519 --> 00:12:43,819
request sends out the first append

249
00:12:44,019 --> 00:12:52,699
entries and then that's fine actually

250
00:12:52,899 --> 00:12:56,159
everything's fine so far nothing's wrong

251
00:12:56,789 --> 00:12:59,569
all right well a good bet for all these

252
00:12:59,769 --> 00:13:01,759
things is then it crashes right or it

253
00:13:01,960 --> 00:13:04,789
receives the client requests in term six

254
00:13:04,990 --> 00:13:06,589
it appends the client requests to its

255
00:13:06,789 --> 00:13:08,389
own log which it does first and it's

256
00:13:08,589 --> 00:13:10,069
about to send out a pen entries but it

257
00:13:10,269 --> 00:13:12,559
crashes yes it didn't send out any pen

258
00:13:12,759 --> 00:13:14,569
entries and then you know we need then

259
00:13:14,769 --> 00:13:16,309
it crashes and restarts very quickly

260
00:13:16,509 --> 00:13:19,159
there's a new election and gosh server

261
00:13:19,360 --> 00:13:21,889
one is elected again as the as the new

262
00:13:22,089 --> 00:13:24,259
leader it receives in term seven and

263
00:13:24,460 --> 00:13:25,639
receives a client request appends it to

264
00:13:25,839 --> 00:13:33,019
its log and then it crashes right and

265
00:13:33,220 --> 00:13:35,179
then after after a crashes we have a new

266
00:13:35,379 --> 00:13:37,159
election maybe server 2 gets elected

267
00:13:37,360 --> 00:13:42,379
this time maybe server 1 is down now so

268
00:13:42,580 --> 00:13:45,769
off the table if server 2 is elected at

269
00:13:45,970 --> 00:13:48,709
this point suppose server 1 is still

270
00:13:48,909 --> 00:13:51,139
dead what term is server what server two

271
00:13:51,339 --> 00:13:53,550
venues

272
00:13:56,419 --> 00:13:58,109
yeah eights the right answer so why

273
00:13:58,309 --> 00:14:00,509
eight and not remember this you know

274
00:14:00,710 --> 00:14:04,570
this is now gone why eight and not six

275
00:14:07,240 --> 00:14:09,419
that's absolutely right so not written

276
00:14:09,620 --> 00:14:11,069
on the board but in order for server one

277
00:14:11,269 --> 00:14:12,539
to have been elected here it must have

278
00:14:12,740 --> 00:14:13,949
votes from majority of nodes which

279
00:14:14,149 --> 00:14:16,490
include at least one of server-to-server

280
00:14:16,690 --> 00:14:20,899
three if you look at the vote request

281
00:14:21,100 --> 00:14:24,179
code and figure two if you vote for

282
00:14:24,379 --> 00:14:25,439
somebody you're you're supposed to

283
00:14:25,639 --> 00:14:29,809
record the term in persistent storage

284
00:14:30,009 --> 00:14:32,699
and that means that either server 2 or

285
00:14:32,899 --> 00:14:34,949
server 3 are both new about term six and

286
00:14:35,149 --> 00:14:37,829
in fact term seven and therefore when

287
00:14:38,029 --> 00:14:39,509
sever one dies and they cannot elect a

288
00:14:39,710 --> 00:14:41,549
new leader at least one of them knows

289
00:14:41,750 --> 00:14:44,729
that the current term was eight if that

290
00:14:44,929 --> 00:14:47,819
one and only that one actually if

291
00:14:48,019 --> 00:14:48,899
there's only one of them only that one

292
00:14:49,100 --> 00:14:51,029
could win an election because it has the

293
00:14:51,230 --> 00:14:52,199
higher terminal birth they both know

294
00:14:52,399 --> 00:14:53,639
about term eight sorry if they both know

295
00:14:53,840 --> 00:14:55,949
about term seven then they'll both and

296
00:14:56,149 --> 00:14:57,539
either one of them will try to be leader

297
00:14:57,740 --> 00:15:00,329
and term eight so that fact of that the

298
00:15:00,529 --> 00:15:02,759
next term must be term a dis is insured

299
00:15:02,960 --> 00:15:04,889
by the property of the majorities must

300
00:15:05,090 --> 00:15:07,859
overlap and the fact that current term

301
00:15:08,059 --> 00:15:10,289
is updated by vote request and is

302
00:15:10,490 --> 00:15:12,509
persistent and guarantee did not be lost

303
00:15:12,710 --> 00:15:14,609
even if there were some crashes here so

304
00:15:14,809 --> 00:15:15,449
the next term is going to be eight

305
00:15:15,649 --> 00:15:17,159
server two or server three will win the

306
00:15:17,360 --> 00:15:19,289
leadership election and let's just

307
00:15:19,490 --> 00:15:21,149
imagine that whichever one it is sends

308
00:15:21,350 --> 00:15:25,620
out append entries for a new client

309
00:15:25,820 --> 00:15:27,179
requests the other one gets it and so

310
00:15:27,379 --> 00:15:29,819
now we have this configuration right so

311
00:15:30,019 --> 00:15:32,429
I was a bit of a detour we're back to

312
00:15:32,629 --> 00:15:35,879
our original question of in this

313
00:15:36,080 --> 00:15:37,949
configuration suppose server one revives

314
00:15:38,149 --> 00:15:42,659
we have an election would it be okay to

315
00:15:42,860 --> 00:15:44,519
use server one would it be okay to have

316
00:15:44,720 --> 00:15:48,689
the rule be the longest log wins the

317
00:15:48,889 --> 00:15:54,089
longest log gets to be the leader yeah

318
00:15:54,289 --> 00:15:56,490
obviously not right because server was a

319
00:15:56,690 --> 00:16:04,259
leader did it's going to force its log

320
00:16:04,460 --> 00:16:07,049
on to the to followers by the append

321
00:16:07,250 --> 00:16:08,370
entries machinery that we just talked

322
00:16:08,570 --> 00:16:09,750
about a few minutes ago

323
00:16:09,950 --> 00:16:11,189
if we live server one to be the leader

324
00:16:11,389 --> 00:16:13,649
it's gonna you know sent out a pen

325
00:16:13,850 --> 00:16:15,509
entries whatever backup overwrite these

326
00:16:15,710 --> 00:16:18,839
aids tell the followers to erase their

327
00:16:19,039 --> 00:16:21,269
log entries for term a to accept to

328
00:16:21,470 --> 00:16:23,279
overwrite them with this six and seven

329
00:16:23,480 --> 00:16:25,879
log entries and then to proceed now with

330
00:16:26,080 --> 00:16:30,179
identical to server ones so of course

331
00:16:30,379 --> 00:16:39,659
why are we upset about this yeah yeah

332
00:16:39,860 --> 00:16:42,870
exactly it was already committed right

333
00:16:43,070 --> 00:16:45,209
it's not a majority of servers has

334
00:16:45,409 --> 00:16:49,859
already committed probably executed

335
00:16:50,059 --> 00:16:52,469
quite possibly a reply sent to a client

336
00:16:52,669 --> 00:16:56,309
so we're not entitled to delete it and

337
00:16:56,509 --> 00:16:59,909
therefore server one cannot be allowed

338
00:17:00,110 --> 00:17:02,459
to become leader and force its log onto

339
00:17:02,659 --> 00:17:05,970
servers two and three everybody see why

340
00:17:06,170 --> 00:17:11,849
that's bad idea for rapid and because of

341
00:17:12,049 --> 00:17:15,720
that this can't possibly have been rule

342
00:17:15,920 --> 00:17:19,769
for elections of course shortest log

343
00:17:19,970 --> 00:17:23,579
didn't work too well either and so in

344
00:17:23,779 --> 00:17:26,700
fact if you read forward to section

345
00:17:26,900 --> 00:17:31,300
something five point four point one

346
00:17:32,950 --> 00:17:34,710
draft actually has a slightly more

347
00:17:34,910 --> 00:17:41,380
sophisticated election restriction that

348
00:17:43,960 --> 00:17:46,919
the request vote handling RPC handling

349
00:17:47,119 --> 00:17:49,319
code is supposed to check before it says

350
00:17:49,519 --> 00:17:51,539
yes before votes yes for a different

351
00:17:51,740 --> 00:17:59,849
peer and the rule is we only vote you

352
00:18:00,049 --> 00:18:02,430
vote yes for some candidate who send us

353
00:18:02,630 --> 00:18:10,529
over request votes only if candidate has

354
00:18:10,730 --> 00:18:13,990
a higher

355
00:18:15,049 --> 00:18:26,608
term in the last log entry or same last

356
00:18:26,808 --> 00:18:31,250
term same charming the last log entry

357
00:18:31,450 --> 00:18:37,889
and a log length that's greater than or

358
00:18:38,089 --> 00:18:44,519
equal to the the server that received

359
00:18:44,720 --> 00:18:51,539
that received the boat request and so if

360
00:18:51,740 --> 00:18:53,639
we apply this here if server two gets a

361
00:18:53,839 --> 00:18:58,200
vote request from server one there our

362
00:18:58,400 --> 00:19:03,210
last log entry terms or seven the server

363
00:19:03,410 --> 00:19:04,470
one's gonna send out a request votes

364
00:19:04,670 --> 00:19:07,950
with a last entry term whatever of 7

365
00:19:08,150 --> 00:19:11,720
server twos is eight so this isn't true

366
00:19:11,920 --> 00:19:14,700
server service we didn't get a request

367
00:19:14,900 --> 00:19:16,169
from somebody with a higher term in the

368
00:19:16,369 --> 00:19:22,019
last entry and or the last entry terms

369
00:19:22,220 --> 00:19:23,279
aren't the same either said the second

370
00:19:23,480 --> 00:19:26,339
Clause doesn't apply either so neither

371
00:19:26,539 --> 00:19:28,259
server to new serve nor server three is

372
00:19:28,460 --> 00:19:30,269
going to vote for server one and so even

373
00:19:30,470 --> 00:19:32,039
if it sends out this vote requests first

374
00:19:32,240 --> 00:19:33,450
because this has a shorter election

375
00:19:33,650 --> 00:19:35,309
timeout nobody's going to vote for it

376
00:19:35,509 --> 00:19:36,629
except itself so I don't think it's one

377
00:19:36,829 --> 00:19:38,700
vote it's not a majority if either

378
00:19:38,900 --> 00:19:41,700
server two or server three becomes a

379
00:19:41,900 --> 00:19:44,430
candidate then either of them will

380
00:19:44,630 --> 00:19:45,720
accept the other because they have the

381
00:19:45,920 --> 00:19:48,059
same last term number and their logs are

382
00:19:48,259 --> 00:19:49,799
each greater than or equal to in length

383
00:19:50,000 --> 00:19:52,079
and the others so either of them will

384
00:19:52,279 --> 00:19:54,839
vote for for the other one will server

385
00:19:55,039 --> 00:19:56,720
one vote for either of them

386
00:19:56,920 --> 00:19:59,940
yes because either server 2 or server 3

387
00:20:00,140 --> 00:20:01,169
has a higher term number in the last

388
00:20:01,369 --> 00:20:05,759
entry so you know what this is doing is

389
00:20:05,960 --> 00:20:07,740
making sure that you can only become a

390
00:20:07,940 --> 00:20:11,579
candidate if or it prefers candidates

391
00:20:11,779 --> 00:20:13,259
that knew about higher that have log

392
00:20:13,460 --> 00:20:15,509
entries some higher terms that is it

393
00:20:15,710 --> 00:20:16,889
prefers candidates that are more likely

394
00:20:17,089 --> 00:20:18,479
to have been receiving log entries from

395
00:20:18,679 --> 00:20:23,549
the previous leader and you know this

396
00:20:23,750 --> 00:20:25,200
second part says well we were all

397
00:20:25,400 --> 00:20:26,608
listening to the previous leader then

398
00:20:26,808 --> 00:20:27,180
we're going to

399
00:20:27,380 --> 00:20:30,299
for the server that has saw more

400
00:20:30,500 --> 00:20:35,339
requests from the very last leader any

401
00:20:35,539 --> 00:20:40,509
questions about the election restriction

402
00:20:45,519 --> 00:20:54,869
okay final thing about sending out log

403
00:20:55,069 --> 00:20:59,309
entries is that this rollback scheme at

404
00:20:59,509 --> 00:21:01,259
least as I described it and it's as its

405
00:21:01,460 --> 00:21:03,479
described in Figure two rolls back one

406
00:21:03,679 --> 00:21:07,829
log entry at a time and you know

407
00:21:08,029 --> 00:21:09,358
probably a lot of fun that's okay

408
00:21:09,558 --> 00:21:12,899
but there are situations maybe in the

409
00:21:13,099 --> 00:21:15,089
real world and definitely in the lab

410
00:21:15,289 --> 00:21:18,329
tests where backing up one entry at a

411
00:21:18,529 --> 00:21:19,919
time is going to take a long long time

412
00:21:20,119 --> 00:21:22,200
and so the real-world situation where

413
00:21:22,400 --> 00:21:25,619
that might be true is if they if a

414
00:21:25,819 --> 00:21:27,750
follower has been down for a long time

415
00:21:27,950 --> 00:21:29,970
and missed a lot of upend entries and

416
00:21:30,170 --> 00:21:32,909
the leader restarts and if you follow

417
00:21:33,109 --> 00:21:34,470
the pseudocode in Figure two if a leader

418
00:21:34,670 --> 00:21:36,029
restarts is supposed to set its next

419
00:21:36,230 --> 00:21:38,369
index to the end of the leaders log so

420
00:21:38,569 --> 00:21:39,990
if the follower has been down and you

421
00:21:40,190 --> 00:21:42,358
know miss the last thousand log entries

422
00:21:42,558 --> 00:21:45,419
and leader reboots the leader is gonna

423
00:21:45,619 --> 00:21:48,149
have to walk back off one at a time one

424
00:21:48,349 --> 00:21:50,759
RPC at a time all thousand of those log

425
00:21:50,960 --> 00:21:53,639
entries that the follower missed and

426
00:21:53,839 --> 00:21:54,990
there's no you know particular reason

427
00:21:55,190 --> 00:21:57,389
why this would never happen in real life

428
00:21:57,589 --> 00:22:00,960
it could easily happen at somewhat more

429
00:22:01,160 --> 00:22:03,750
contrived situation that the tests are

430
00:22:03,950 --> 00:22:06,990
definitely explorers is if a follower is

431
00:22:07,190 --> 00:22:09,690
if we say we have five servers and

432
00:22:09,890 --> 00:22:13,710
there's there's a leader but the leaders

433
00:22:13,910 --> 00:22:16,799
got trapped with one follower in a

434
00:22:17,000 --> 00:22:18,240
network partition but the leader doesn't

435
00:22:18,440 --> 00:22:19,589
know it's not leader anymore and it's

436
00:22:19,789 --> 00:22:21,720
still sending out append entries to its

437
00:22:21,920 --> 00:22:22,950
one follower and none of which are

438
00:22:23,150 --> 00:22:25,740
committed while in the other majority

439
00:22:25,940 --> 00:22:28,529
partition the system is continuing as

440
00:22:28,730 --> 00:22:32,299
usual the ex leader and follower in that

441
00:22:32,500 --> 00:22:35,490
Minority partition could end up putting

442
00:22:35,690 --> 00:22:37,289
in their logs you know sort of unlimited

443
00:22:37,490 --> 00:22:40,589
numbers of log entries for a stale term

444
00:22:40,789 --> 00:22:42,059
that will never be committed and need to

445
00:22:42,259 --> 00:22:44,039
be deleted and overwritten eventually

446
00:22:44,240 --> 00:22:47,399
when they rejoin the main group that's

447
00:22:47,599 --> 00:22:48,539
maybe a little less likely in the real

448
00:22:48,740 --> 00:22:52,319
world but you'll see it happen and the

449
00:22:52,519 --> 00:22:55,079
test set up so in order to be able to

450
00:22:55,279 --> 00:22:57,409
back up faster that paper has

451
00:22:57,609 --> 00:22:59,750
somewhat a vague description of a faster

452
00:22:59,950 --> 00:23:04,809
scheme towards the end of section 5.3

453
00:23:05,009 --> 00:23:07,099
it's a little bit hard to interpret so

454
00:23:07,299 --> 00:23:09,950
I'm gonna try to explain what their

455
00:23:10,150 --> 00:23:11,450
ideas about how to back up faster a

456
00:23:11,650 --> 00:23:13,069
little bit better and the general idea

457
00:23:13,269 --> 00:23:15,319
is to be able to to have the follower

458
00:23:15,519 --> 00:23:17,180
send enough information to the leader

459
00:23:17,380 --> 00:23:19,430
that the leader can jump back an entire

460
00:23:19,630 --> 00:23:22,759
terms worth of entries that have to be

461
00:23:22,960 --> 00:23:25,940
deleted per append entries so it leader

462
00:23:26,140 --> 00:23:27,379
may only have to send one in a pennant

463
00:23:27,579 --> 00:23:30,680
and append entries per term in which the

464
00:23:30,880 --> 00:23:33,649
leader and follower disagree instead of

465
00:23:33,849 --> 00:23:37,879
one per entry so there's three cases I

466
00:23:38,079 --> 00:23:39,710
think are important and the fact is that

467
00:23:39,910 --> 00:23:42,759
you can probably think of many different

468
00:23:42,960 --> 00:23:46,419
log backup acceleration strategies and

469
00:23:46,619 --> 00:23:49,970
here's one so I'm going to divide the

470
00:23:50,170 --> 00:23:51,680
kinds of situations you might see into

471
00:23:51,880 --> 00:24:01,279
three cases so this is fast backup case

472
00:24:01,480 --> 00:24:06,740
one I'm just going to talk about one

473
00:24:06,940 --> 00:24:09,079
follower and the leader and not worry

474
00:24:09,279 --> 00:24:11,899
about the other nodes the same we have

475
00:24:12,099 --> 00:24:17,839
two server one which is the follower and

476
00:24:18,039 --> 00:24:25,369
server 2 which is the leader so this is

477
00:24:25,569 --> 00:24:28,879
one case and here we need to backup over

478
00:24:29,079 --> 00:24:30,829
a term where that term is entirely

479
00:24:31,029 --> 00:24:39,599
missing from the leader another case

480
00:24:44,640 --> 00:24:47,480
so in this case we need to back up over

481
00:24:47,680 --> 00:24:48,980
some entries but their entries for a

482
00:24:49,180 --> 00:24:50,210
term that the leader actually knows

483
00:24:50,410 --> 00:24:53,779
about so apparently the this followers

484
00:24:53,980 --> 00:24:56,599
saw a couple of entry a couple of the

485
00:24:56,799 --> 00:24:58,759
very Flass few append entries sent out

486
00:24:58,960 --> 00:25:01,700
by a leader that was about to crash but

487
00:25:01,900 --> 00:25:03,440
the new leader didn't see them we still

488
00:25:03,640 --> 00:25:05,659
need to back up over them and a third

489
00:25:05,859 --> 00:25:11,480
case is where the followers entirely

490
00:25:11,680 --> 00:25:15,009
missing the following the leader agree

491
00:25:15,210 --> 00:25:19,700
but the followers is missing the end of

492
00:25:19,900 --> 00:25:24,589
the leaders log and I believe you can

493
00:25:24,789 --> 00:25:27,009
take care of all three of these with

494
00:25:27,210 --> 00:25:29,720
three pieces of extra information in the

495
00:25:29,920 --> 00:25:31,940
reply that a follower sends back to the

496
00:25:32,140 --> 00:25:35,389
leader in the case in the append entries

497
00:25:35,589 --> 00:25:37,099
so we're talking about the append

498
00:25:37,299 --> 00:25:42,019
entries reply if the follower rejects

499
00:25:42,220 --> 00:25:43,730
the append entries because the logs

500
00:25:43,930 --> 00:25:46,009
don't agree there's three pieces of

501
00:25:46,210 --> 00:25:47,299
information that will be useful and

502
00:25:47,500 --> 00:25:49,789
taking care of three street cases I'll

503
00:25:49,990 --> 00:25:55,250
call them X term which is the term of

504
00:25:55,450 --> 00:25:58,099
the conflicting entry I remember the

505
00:25:58,299 --> 00:26:05,259
leader sent this previous log term and

506
00:26:05,460 --> 00:26:07,609
if the follower rejects it because it

507
00:26:07,809 --> 00:26:08,839
has something here but the terms wrong

508
00:26:09,039 --> 00:26:12,680
so it'll put the followers term for the

509
00:26:12,880 --> 00:26:19,129
conflicting entry here or you know I'm

510
00:26:19,329 --> 00:26:20,839
negative one or something it doesn't

511
00:26:21,039 --> 00:26:24,829
have anything in the log there it'll

512
00:26:25,029 --> 00:26:30,019
also send back the index of the

513
00:26:30,220 --> 00:26:33,109
conflicting but the index are the first

514
00:26:33,309 --> 00:26:36,240
entry with that term

515
00:26:46,750 --> 00:26:49,639
and finally if there wasn't any log

516
00:26:49,839 --> 00:26:52,549
entry there at all the follower will

517
00:26:52,750 --> 00:26:56,659
send back on the length of its law like

518
00:26:56,859 --> 00:27:02,269
the followers log so for case one the

519
00:27:02,470 --> 00:27:12,589
way this helps if the it's a leader sees

520
00:27:12,789 --> 00:27:15,950
that the leader doesn't even have an

521
00:27:16,150 --> 00:27:18,829
entry with X term of term X term at all

522
00:27:19,029 --> 00:27:22,669
in its log so that's this case where the

523
00:27:22,869 --> 00:27:24,200
leader didn't have turn five and if the

524
00:27:24,400 --> 00:27:26,059
leader can simply back up to the

525
00:27:26,259 --> 00:27:30,369
beginning of the followers run of

526
00:27:30,569 --> 00:27:33,819
entries with X term that is the the

527
00:27:34,019 --> 00:27:36,799
leader can set its next index to this X

528
00:27:37,000 --> 00:27:41,450
index thing which is the first entry the

529
00:27:41,650 --> 00:27:44,979
followers run of items from term five

530
00:27:45,179 --> 00:27:48,259
alright so if the leader doesn't have X

531
00:27:48,460 --> 00:27:50,869
term at all it should back up to X back

532
00:27:51,069 --> 00:27:53,509
the follower up to X index the second

533
00:27:53,710 --> 00:27:55,369
case you can detect the fault the leader

534
00:27:55,569 --> 00:27:59,569
can detect if X term is valid and the

535
00:27:59,769 --> 00:28:04,700
leader actually has log entries of term

536
00:28:04,900 --> 00:28:08,079
X term that's the case here where the

537
00:28:08,279 --> 00:28:10,309
you know the disagreement is here but

538
00:28:10,509 --> 00:28:12,619
the leader actually has some entries

539
00:28:12,819 --> 00:28:14,690
that term in that case the leader should

540
00:28:14,890 --> 00:28:18,309
back up to the last entry it has that

541
00:28:18,509 --> 00:28:22,729
has the contesta followers term for the

542
00:28:22,929 --> 00:28:24,589
conflicting term in it that is the last

543
00:28:24,789 --> 00:28:26,719
entry that a leader has for term for in

544
00:28:26,919 --> 00:28:29,509
this case and if neither of these two

545
00:28:29,710 --> 00:28:32,930
cases hold that is the well actually if

546
00:28:33,130 --> 00:28:35,809
the follower indicates by maybe setting

547
00:28:36,009 --> 00:28:37,460
X term to minus one it actually didn't

548
00:28:37,660 --> 00:28:39,319
have anything whatsoever at the

549
00:28:39,519 --> 00:28:41,719
conflicting log and index because it's

550
00:28:41,919 --> 00:28:46,759
log is too short then the leader should

551
00:28:46,960 --> 00:28:49,579
back up its next index to the last entry

552
00:28:49,779 --> 00:28:51,200
that the follower had at all and start

553
00:28:51,400 --> 00:28:53,639
sending from there

554
00:28:53,839 --> 00:28:55,629
and I'm telling you this because it'll

555
00:28:55,829 --> 00:29:00,450
be useful for doing a lab and if you

556
00:29:00,650 --> 00:29:02,889
miss some of my description it's it's in

557
00:29:03,089 --> 00:29:04,930
electronics then any questions about

558
00:29:05,130 --> 00:29:20,769
this backing up business Jack I think

559
00:29:20,970 --> 00:29:24,879
that's true yeah yeah yeah maybe binary

560
00:29:25,079 --> 00:29:26,680
search I'm not ruling out other

561
00:29:26,880 --> 00:29:29,409
solutions I mean that you know after

562
00:29:29,609 --> 00:29:31,930
reading the papers non description of

563
00:29:32,130 --> 00:29:34,269
how to do it I like cook this up and

564
00:29:34,470 --> 00:29:37,329
there's probably other ways to do this

565
00:29:37,529 --> 00:29:38,859
probably better ways and faster ways of

566
00:29:39,059 --> 00:29:40,389
doing it like I'm I'm sure that if

567
00:29:40,589 --> 00:29:41,680
you're willing to send back more

568
00:29:41,880 --> 00:29:43,690
information or have a more sophisticated

569
00:29:43,890 --> 00:29:45,819
strategy like binary search you can do a

570
00:29:46,019 --> 00:29:50,349
better job yeah well you you almost

571
00:29:50,549 --> 00:29:52,950
certainly need to do something

572
00:29:53,150 --> 00:29:54,940
experience suggests that in order to

573
00:29:55,140 --> 00:29:57,399
pass the tests you'll need to do

574
00:29:57,599 --> 00:30:01,839
something to as well probably not me

575
00:30:02,039 --> 00:30:04,750
although I that's not quite true like

576
00:30:04,950 --> 00:30:06,220
one of the solutions I've written over

577
00:30:06,420 --> 00:30:08,349
the years actually does the stupid thing

578
00:30:08,549 --> 00:30:11,289
and still passes the tests but because

579
00:30:11,490 --> 00:30:15,789
the tests you know the one of the sort

580
00:30:15,990 --> 00:30:17,230
of unfortunate but inevitable things

581
00:30:17,430 --> 00:30:19,210
about the tests we give you is that they

582
00:30:19,410 --> 00:30:21,460
have a bit of a real time requirement

583
00:30:21,660 --> 00:30:23,049
that is the tests are not willing to

584
00:30:23,250 --> 00:30:25,389
wait forever for your solution to

585
00:30:25,589 --> 00:30:29,169
produce an answer so it is possible to

586
00:30:29,369 --> 00:30:30,519
have a solution that's you know

587
00:30:30,720 --> 00:30:33,730
technically correct but takes so long

588
00:30:33,930 --> 00:30:36,509
that the tester gives up and

589
00:30:36,710 --> 00:30:38,859
unfortunately you know we will the

590
00:30:39,059 --> 00:30:40,629
tester will fail you if your solution

591
00:30:40,829 --> 00:30:42,609
doesn't finish the test and whatever the

592
00:30:42,809 --> 00:30:44,589
time limit is and therefore you do

593
00:30:44,789 --> 00:30:46,740
actually have to pay some attention to

594
00:30:46,940 --> 00:30:50,259
performance in order you know your

595
00:30:50,460 --> 00:30:52,269
solution has to be both correct and have

596
00:30:52,470 --> 00:30:53,889
enough performance to finish before the

597
00:30:54,089 --> 00:30:56,289
tester gets bored and sometimes out on

598
00:30:56,490 --> 00:30:58,059
you which is like 10 minutes or I don't

599
00:30:58,259 --> 00:31:00,190
know what it is and unfortunately it's

600
00:31:00,390 --> 00:31:02,079
relatively this stuff's complex enough

601
00:31:02,279 --> 00:31:04,450
that it's not that hard to write a color

602
00:31:04,650 --> 00:31:05,009
correction

603
00:31:05,210 --> 00:31:15,149
that's not fast enough yes so the way

604
00:31:15,349 --> 00:31:16,649
you can tap the leader can tell the

605
00:31:16,849 --> 00:31:20,519
difference is that the follower we're

606
00:31:20,720 --> 00:31:22,919
supposed to send back the term number it

607
00:31:23,119 --> 00:31:25,529
sees in the conflicting entry you we

608
00:31:25,730 --> 00:31:28,919
have case one if the leader does not

609
00:31:29,119 --> 00:31:31,159
have that term in its log

610
00:31:31,359 --> 00:31:34,680
so here the follower will set X term to

611
00:31:34,880 --> 00:31:37,379
five to five because this is this is

612
00:31:37,579 --> 00:31:39,719
going to be the this is gonna be the

613
00:31:39,919 --> 00:31:44,009
conflicting entry the follower says this

614
00:31:44,210 --> 00:31:46,169
X term to five the leader observes oh I

615
00:31:46,369 --> 00:31:48,539
do not have term five in my log and

616
00:31:48,740 --> 00:31:57,000
therefore this case one and you know it

617
00:31:57,200 --> 00:31:57,899
should back up to the beginning

618
00:31:58,099 --> 00:31:59,969
like it doesn't follower hasn't leader

619
00:32:00,169 --> 00:32:02,338
has none of those and term five entry so

620
00:32:02,538 --> 00:32:03,930
it should just get rid of all of them in

621
00:32:04,130 --> 00:32:05,578
the follower by backing up to the

622
00:32:05,778 --> 00:32:19,919
beginning which is X index yeah yeah

623
00:32:20,119 --> 00:32:22,289
because the leaders gonna back up its

624
00:32:22,490 --> 00:32:25,709
next index to here and then send an

625
00:32:25,909 --> 00:32:27,838
append entries that starts here and the

626
00:32:28,038 --> 00:32:29,698
rules a figure to say ah the follower

627
00:32:29,898 --> 00:32:31,740
just has to replace its log so it is

628
00:32:31,940 --> 00:32:37,619
gonna get rid of the fives okay alright

629
00:32:37,819 --> 00:32:38,729
the next thing I want to talk about is

630
00:32:38,929 --> 00:32:41,940
persistence you'll notice in Figure two

631
00:32:42,140 --> 00:32:44,309
that the state in the upper left-hand

632
00:32:44,509 --> 00:32:47,549
corners sort of divided and summer

633
00:32:47,750 --> 00:32:50,629
marked persistent and some are marked

634
00:32:50,829 --> 00:32:54,448
volatile and what's going on here is

635
00:32:54,648 --> 00:32:57,448
that the the distinction between

636
00:32:57,648 --> 00:32:59,698
persistence and volatile you know only

637
00:32:59,898 --> 00:33:03,358
matters if a server reboots crashes and

638
00:33:03,558 --> 00:33:06,059
restarts because the persistent what the

639
00:33:06,259 --> 00:33:08,009
persistent means is that if you change

640
00:33:08,210 --> 00:33:09,539
one of those items it's marked

641
00:33:09,740 --> 00:33:13,919
persistent you're supposed to the server

642
00:33:14,119 --> 00:33:15,509
supposed to write it to disk or to some

643
00:33:15,710 --> 00:33:17,729
other non-volatile storage like as

644
00:33:17,929 --> 00:33:20,598
or battery-backed something or whatever

645
00:33:20,798 --> 00:33:23,250
that will ensure that if the server

646
00:33:23,450 --> 00:33:26,129
restarts that it will be able to find

647
00:33:26,329 --> 00:33:28,289
that information and sort of reload it

648
00:33:28,490 --> 00:33:33,959
into memory and that's to allow us to

649
00:33:34,159 --> 00:33:35,789
allow servers to be able to pick up

650
00:33:35,990 --> 00:33:37,740
where they left off if they crash and

651
00:33:37,940 --> 00:33:46,198
restart now you might think that it

652
00:33:46,398 --> 00:33:47,969
would it would be sufficient and simpler

653
00:33:48,169 --> 00:33:51,509
to say well if a server crashes then we

654
00:33:51,710 --> 00:33:55,678
just throw it away and or we need to be

655
00:33:55,878 --> 00:33:57,358
able to throw it away and replace it

656
00:33:57,558 --> 00:33:58,889
with a brand-new empty server and bring

657
00:33:59,089 --> 00:34:01,769
it up to speed right and of course you

658
00:34:01,970 --> 00:34:04,409
do actually it is vital to be able to do

659
00:34:04,609 --> 00:34:06,389
that right because if some server

660
00:34:06,589 --> 00:34:07,979
suffers a failure of some catastrophic

661
00:34:08,179 --> 00:34:10,590
failure like it's you know disk melts or

662
00:34:10,789 --> 00:34:14,280
something you absolutely need to be able

663
00:34:14,480 --> 00:34:16,919
to replace it and you cannot count on

664
00:34:17,119 --> 00:34:18,689
getting anything useful off its disk if

665
00:34:18,889 --> 00:34:20,519
something bad happened to its disk so we

666
00:34:20,719 --> 00:34:21,840
absolutely need to be able to replace

667
00:34:22,039 --> 00:34:24,659
completely replace servers that have no

668
00:34:24,858 --> 00:34:28,169
state whatsoever you might think that's

669
00:34:28,369 --> 00:34:30,179
sufficient to handle any difficulties

670
00:34:30,378 --> 00:34:32,399
but it's actually not it turns out that

671
00:34:32,599 --> 00:34:34,560
another common failure mode is power

672
00:34:34,760 --> 00:34:38,340
failure of you know the entire cluster

673
00:34:38,539 --> 00:34:40,500
where they all stop executing at the

674
00:34:40,699 --> 00:34:42,929
same time right and in that case we

675
00:34:43,128 --> 00:34:46,590
can't handle or we can't handle that

676
00:34:46,789 --> 00:34:48,479
failure by simply throwing away the

677
00:34:48,679 --> 00:34:50,519
servers and replacing them with new

678
00:34:50,719 --> 00:34:53,550
hardware that we buy from Dell we

679
00:34:53,750 --> 00:34:56,280
actually have to be able to get off the

680
00:34:56,480 --> 00:34:58,769
ground we need to be able to get a copy

681
00:34:58,969 --> 00:35:01,440
of the state back in order to keep

682
00:35:01,639 --> 00:35:03,930
executing if we want our service to be

683
00:35:04,130 --> 00:35:06,810
fault tolerant and therefore in order at

684
00:35:07,010 --> 00:35:09,090
least in order to handle the situation

685
00:35:09,289 --> 00:35:11,490
of simultaneous power failure we have to

686
00:35:11,690 --> 00:35:13,200
have a way for the server's to sort of

687
00:35:13,400 --> 00:35:15,119
save their state somewhere where it will

688
00:35:15,318 --> 00:35:18,840
be available when the power returns and

689
00:35:19,039 --> 00:35:20,369
that's one way of viewing what's going

690
00:35:20,568 --> 00:35:23,760
on with persistence it said that's the

691
00:35:23,960 --> 00:35:26,289
state that's required

692
00:35:26,489 --> 00:35:28,659
to get a server going again I'm after

693
00:35:28,858 --> 00:35:31,000
either a single power failure or power

694
00:35:31,199 --> 00:35:33,389
failure of the entire cluster

695
00:35:33,588 --> 00:35:38,409
alright so figure two this three items

696
00:35:38,608 --> 00:35:42,500
only three items are persistent so

697
00:35:44,900 --> 00:35:49,000
there's a log that's like all the log

698
00:35:49,199 --> 00:36:03,579
entries current term and voted for and

699
00:36:03,778 --> 00:36:05,889
by the way you know one of us server

700
00:36:06,088 --> 00:36:07,359
reboots it actually has to make an

701
00:36:07,559 --> 00:36:09,639
explicit check to make sure that these

702
00:36:09,838 --> 00:36:14,649
data are valid on its disk before it

703
00:36:14,849 --> 00:36:17,019
rejoins the raft cluster I have to have

704
00:36:17,219 --> 00:36:18,669
some way of saying oh yeah I actually do

705
00:36:18,869 --> 00:36:20,200
have some save persistent state as

706
00:36:20,400 --> 00:36:23,980
opposed to a bunch of zeros that that

707
00:36:24,179 --> 00:36:28,180
are not valid all right so the reason

708
00:36:28,380 --> 00:36:33,970
why log has to be persisted is that at

709
00:36:34,170 --> 00:36:35,829
least according to figure two this is

710
00:36:36,028 --> 00:36:39,960
the only record of the application state

711
00:36:40,159 --> 00:36:41,919
that is figure two doesn't really have a

712
00:36:42,119 --> 00:36:43,960
notion fears two does not say that we

713
00:36:44,159 --> 00:36:46,060
have to persist the application state so

714
00:36:46,260 --> 00:36:48,129
if we're running a database or you know

715
00:36:48,329 --> 00:36:50,349
a test and set service like for vmware

716
00:36:50,548 --> 00:36:53,109
ft the actual database or the actual

717
00:36:53,309 --> 00:36:54,849
value of the test and set flag isn't

718
00:36:55,048 --> 00:36:57,010
persistent according to figure two only

719
00:36:57,210 --> 00:36:59,050
the logins and so when the server

720
00:36:59,250 --> 00:37:01,960
restarts the only information available

721
00:37:02,159 --> 00:37:05,019
to reconstruct the application state is

722
00:37:05,219 --> 00:37:08,260
the sequence of commands in the log and

723
00:37:08,460 --> 00:37:13,240
so that has to be persisted that's what

724
00:37:13,440 --> 00:37:17,169
about current term why does current term

725
00:37:17,369 --> 00:37:20,329
have to be persistent

726
00:37:34,588 --> 00:37:36,830
yeah so they're both about ensuring that

727
00:37:37,030 --> 00:37:39,560
there's only one that each term has at

728
00:37:39,760 --> 00:37:42,950
most one leader so yeah so voted for the

729
00:37:43,150 --> 00:37:45,710
specific you know potential damaging

730
00:37:45,909 --> 00:37:48,139
case is that if a server receives a boat

731
00:37:48,338 --> 00:37:50,600
request and votes for server one and

732
00:37:50,800 --> 00:37:53,060
then it crashes and if it didn't persist

733
00:37:53,260 --> 00:37:55,519
this the identity of who had voted for

734
00:37:55,719 --> 00:37:57,800
and in my crash we start get another

735
00:37:58,000 --> 00:37:59,720
boat request for the same term from

736
00:37:59,920 --> 00:38:01,639
server two and say gosh I haven't voted

737
00:38:01,838 --> 00:38:03,350
for anybody because my voted for is

738
00:38:03,550 --> 00:38:03,740
blank

739
00:38:03,940 --> 00:38:05,659
now I'm gonna vote for server 2 and now

740
00:38:05,858 --> 00:38:08,149
our servers voted for server 1 and for

741
00:38:08,349 --> 00:38:11,960
server 2 in the same term and that might

742
00:38:12,159 --> 00:38:14,090
allow two servers

743
00:38:14,289 --> 00:38:15,800
since both server and server to voted

744
00:38:16,000 --> 00:38:17,780
for themselves they both may think they

745
00:38:17,980 --> 00:38:19,010
have a majority out of three and they're

746
00:38:19,210 --> 00:38:20,240
both going to become leader now we have

747
00:38:20,440 --> 00:38:23,149
two simultaneous servers for the same

748
00:38:23,349 --> 00:38:24,710
term so this that's why I voted for it

749
00:38:24,909 --> 00:38:28,369
has to be persistent current term is

750
00:38:28,568 --> 00:38:30,500
gonna be a little more subtle but we

751
00:38:30,699 --> 00:38:34,310
actually talked before about how you

752
00:38:34,510 --> 00:38:36,200
know again we don't want to have more

753
00:38:36,400 --> 00:38:38,269
than one server for a term and if we

754
00:38:38,469 --> 00:38:41,019
don't know what term number it is then

755
00:38:41,219 --> 00:38:44,300
we can't necessarily then it may be hard

756
00:38:44,500 --> 00:38:46,580
to ensure that there's only one server

757
00:38:46,780 --> 00:38:49,580
for a term and I think maybe in this

758
00:38:49,780 --> 00:38:53,899
example ya if s if server 1 was down and

759
00:38:54,099 --> 00:38:56,990
server 2 and server 3 we're gonna try to

760
00:38:57,190 --> 00:38:59,480
elect a new server they need evidence

761
00:38:59,679 --> 00:39:01,940
that the correct turn numbers 8 and not

762
00:39:02,139 --> 00:39:04,789
6 right because if they if they forgot

763
00:39:04,989 --> 00:39:06,470
about current term and it was just

764
00:39:06,670 --> 00:39:08,119
server 2 and server 3 voting for each

765
00:39:08,318 --> 00:39:09,350
other and they only had their log to

766
00:39:09,550 --> 00:39:10,789
look at they might think the next term

767
00:39:10,989 --> 00:39:12,649
should be term 6 they did that they

768
00:39:12,849 --> 00:39:14,480
start producing stuff for term 6 but now

769
00:39:14,679 --> 00:39:15,919
there's gonna be a lot of confusion

770
00:39:16,119 --> 00:39:18,519
because we have two different term sixes

771
00:39:18,719 --> 00:39:21,519
and so that's the reason my current term

772
00:39:21,719 --> 00:39:24,619
has to be persistent to preserve

773
00:39:24,818 --> 00:39:27,379
evidence about term numbers that have

774
00:39:27,579 --> 00:39:34,210
already been used these have to be

775
00:39:34,409 --> 00:39:38,240
persisted pretty much every time you

776
00:39:38,440 --> 00:39:42,440
change them right so certainly the safe

777
00:39:42,639 --> 00:39:43,970
thing to do is every time you add an

778
00:39:44,170 --> 00:39:46,700
entry of log or change current term

779
00:39:46,900 --> 00:39:50,990
are said voted for you need you probably

780
00:39:51,190 --> 00:39:53,120
need to persist that and in a real raft

781
00:39:53,320 --> 00:39:54,320
server that would mean writing it to the

782
00:39:54,519 --> 00:39:56,120
disk so you'd have some set of files

783
00:39:56,320 --> 00:39:59,030
that recorded this stuff you can

784
00:39:59,230 --> 00:40:01,789
probably be a little bit you may be can

785
00:40:01,989 --> 00:40:04,419
cut some corners if you observed that

786
00:40:04,619 --> 00:40:07,940
you don't need to persist these things

787
00:40:08,139 --> 00:40:09,530
until you communicate with the outside

788
00:40:09,730 --> 00:40:11,690
world so there may be some opportunity

789
00:40:11,889 --> 00:40:13,010
for a little bit of batching by saying

790
00:40:13,210 --> 00:40:14,300
well we don't have to persist anything

791
00:40:14,500 --> 00:40:17,030
until we're about to reply to an RPC or

792
00:40:17,230 --> 00:40:20,539
about to send out an RPC I mean that may

793
00:40:20,739 --> 00:40:23,019
allow you to avoid a few persisting x'

794
00:40:23,219 --> 00:40:26,860
the reason that's important is that

795
00:40:27,059 --> 00:40:30,980
writing stuff to disk is can be very

796
00:40:31,179 --> 00:40:32,419
expensive it's a if it's a mechanical

797
00:40:32,619 --> 00:40:34,130
hard drive that we're talking about then

798
00:40:34,329 --> 00:40:36,830
writing anything you know if the way

799
00:40:37,030 --> 00:40:38,450
we're persisting is writing files on the

800
00:40:38,650 --> 00:40:41,180
disk writing anything on the disk cost

801
00:40:41,380 --> 00:40:42,830
you about 10 milliseconds because you

802
00:40:43,030 --> 00:40:45,070
either have to wait for the disk to spin

803
00:40:45,269 --> 00:40:47,360
for the point you want to write to spin

804
00:40:47,559 --> 00:40:49,700
under the head which disk only rotates

805
00:40:49,900 --> 00:40:51,649
about once every 10 milliseconds or

806
00:40:51,849 --> 00:40:52,940
worse that you may actually have to seek

807
00:40:53,139 --> 00:40:55,490
to move the arm the right track right so

808
00:40:55,690 --> 00:40:58,370
these per systems can be terribly

809
00:40:58,570 --> 00:41:01,310
terribly expensive and if for sort of

810
00:41:01,510 --> 00:41:03,320
any kind of straightforward design

811
00:41:03,519 --> 00:41:06,019
they're likely to be the limiting factor

812
00:41:06,219 --> 00:41:08,889
in performance because they mean that

813
00:41:09,088 --> 00:41:13,490
doing anything anything whatsoever on

814
00:41:13,690 --> 00:41:15,139
these graph servers takes ten

815
00:41:15,338 --> 00:41:18,380
milliseconds a pop and 10 milliseconds

816
00:41:18,579 --> 00:41:20,210
as far longer than it takes to say send

817
00:41:20,409 --> 00:41:23,120
an RPC or almost anything else you might

818
00:41:23,320 --> 00:41:25,970
do 10 milliseconds each means you can

819
00:41:26,170 --> 00:41:29,409
just never if you persist data to a

820
00:41:29,608 --> 00:41:31,669
mechanical drive you just can never

821
00:41:31,869 --> 00:41:33,200
build a raft service it can serve more

822
00:41:33,400 --> 00:41:37,130
than 100 requests per second because

823
00:41:37,329 --> 00:41:38,330
that's what you get it at 10

824
00:41:38,530 --> 00:41:41,419
milliseconds per operation and you know

825
00:41:41,619 --> 00:41:44,570
this is this cost so this is really all

826
00:41:44,769 --> 00:41:48,420
about cost of synchronous

827
00:41:49,920 --> 00:41:57,890
just updates and it comes up in many

828
00:41:58,090 --> 00:41:59,330
systems like file systems the file

829
00:41:59,530 --> 00:42:00,769
systems that are running in your laptops

830
00:42:00,969 --> 00:42:03,080
are that the designers spend a huge

831
00:42:03,280 --> 00:42:04,970
amount of time sort of trying to

832
00:42:05,170 --> 00:42:06,920
navigate around the performance problems

833
00:42:07,119 --> 00:42:08,840
of synchronous disk up they think of as

834
00:42:09,039 --> 00:42:10,760
disk writes because in order for stuff

835
00:42:10,960 --> 00:42:12,170
to get safe on your disk in order to

836
00:42:12,369 --> 00:42:14,000
update the file system on your laptop's

837
00:42:14,199 --> 00:42:18,230
disk safely there turns out the file

838
00:42:18,429 --> 00:42:20,420
system has to like be careful about how

839
00:42:20,619 --> 00:42:22,640
it writes and needs to sometimes wait

840
00:42:22,840 --> 00:42:25,220
for the disk to finish writing so this

841
00:42:25,420 --> 00:42:27,680
is a like a cross-cutting issue in all

842
00:42:27,880 --> 00:42:29,539
kinds of systems certainly comes up in

843
00:42:29,739 --> 00:42:33,500
draft if you want it to build a system

844
00:42:33,699 --> 00:42:34,700
they could serve more than a hundred

845
00:42:34,900 --> 00:42:38,630
quests per second then there's a bunch

846
00:42:38,829 --> 00:42:39,740
of options one is you can use a

847
00:42:39,940 --> 00:42:41,570
solid-state drive or some kind of flash

848
00:42:41,769 --> 00:42:44,120
or something solid eight drives can do a

849
00:42:44,320 --> 00:42:50,330
write to the flash memory in maybe a

850
00:42:50,530 --> 00:42:52,400
tenth of a millisecond so that's a

851
00:42:52,599 --> 00:42:55,280
factor of a hundred for you or if you're

852
00:42:55,480 --> 00:42:57,530
even more sophisticated maybe you can

853
00:42:57,730 --> 00:43:02,000
build yourself battery backed DRAM and

854
00:43:02,199 --> 00:43:03,620
do the persistence into battery back

855
00:43:03,820 --> 00:43:07,070
DRAM and then if the server reboots hope

856
00:43:07,269 --> 00:43:10,820
that reboot was took shorter than the

857
00:43:11,019 --> 00:43:12,230
amount of time the battery lasts and

858
00:43:12,429 --> 00:43:14,360
that this stuff you persisted is still

859
00:43:14,559 --> 00:43:17,570
in the RAM and the reason I mean if you

860
00:43:17,769 --> 00:43:19,220
have money and sophistication the reason

861
00:43:19,420 --> 00:43:21,200
to favor that is you can write DRAM you

862
00:43:21,400 --> 00:43:23,030
know millions of times per second and so

863
00:43:23,230 --> 00:43:24,400
it's probably not going to be a

864
00:43:24,599 --> 00:43:28,400
performance bottleneck anyway so that

865
00:43:28,599 --> 00:43:33,170
this problem is why and it's sort of

866
00:43:33,369 --> 00:43:35,030
marking a persistent versus volatile and

867
00:43:35,230 --> 00:43:36,680
figure 2 is like has a lot of

868
00:43:36,880 --> 00:43:38,710
significance for performance as well as

869
00:43:38,909 --> 00:43:43,490
crash recovery and correctness any

870
00:43:43,690 --> 00:43:48,300
questions about persisting yeah

871
00:43:55,570 --> 00:44:08,039
yes alright so your question is

872
00:44:08,239 --> 00:44:10,140
basically you're writing code say go

873
00:44:10,340 --> 00:44:12,210
code for your raft implementation or

874
00:44:12,409 --> 00:44:13,320
you're trying to write a real rafterman

875
00:44:13,519 --> 00:44:15,000
implementation and you actually want to

876
00:44:15,199 --> 00:44:18,300
make sure that when you persist your an

877
00:44:18,500 --> 00:44:19,980
update to the law or the current term or

878
00:44:20,179 --> 00:44:21,600
whatever that it in fact will be there

879
00:44:21,800 --> 00:44:23,670
after a crash and reboot like what's the

880
00:44:23,869 --> 00:44:26,100
recipe for what you have to do to make

881
00:44:26,300 --> 00:44:27,810
sure it's there and your observation

882
00:44:28,010 --> 00:44:30,840
that if you call you know on a UNIX or

883
00:44:31,039 --> 00:44:34,250
Linux or whatever Mac if you call right

884
00:44:34,449 --> 00:44:36,780
you know the right system call is how

885
00:44:36,980 --> 00:44:38,310
you write to a disk file you simply call

886
00:44:38,510 --> 00:44:41,130
right as you pointed out it is not the

887
00:44:41,329 --> 00:44:43,470
case that after the write returns the

888
00:44:43,670 --> 00:44:45,600
data is safe on disk and will survive a

889
00:44:45,800 --> 00:44:48,450
reboot it almost certainly isn't almost

890
00:44:48,650 --> 00:44:51,000
certainly not on disk so the you know

891
00:44:51,199 --> 00:44:53,280
the particular piece of magic you need

892
00:44:53,480 --> 00:44:56,010
to do is on unix at any rate you need

893
00:44:56,210 --> 00:44:58,310
you need to call right so you cannot

894
00:44:58,510 --> 00:45:01,140
write some file you've opened that's

895
00:45:01,340 --> 00:45:02,519
going to contain the stuff that you want

896
00:45:02,719 --> 00:45:06,090
to write and then you got a call this F

897
00:45:06,289 --> 00:45:09,510
st. call which on most systems the

898
00:45:09,710 --> 00:45:11,810
guarantee is that F sync doesn't return

899
00:45:12,010 --> 00:45:15,150
until all the data you've previously

900
00:45:15,349 --> 00:45:17,940
written into this file is safely on the

901
00:45:18,139 --> 00:45:21,930
surface on the media in a place on a

902
00:45:22,130 --> 00:45:23,580
place where it will still be there if

903
00:45:23,780 --> 00:45:26,730
there's a crash so so this thing is some

904
00:45:26,929 --> 00:45:28,830
then this call is an expensive call and

905
00:45:29,030 --> 00:45:30,420
that's why it's a separate that's why

906
00:45:30,619 --> 00:45:33,300
Wright doesn't write the disk only F

907
00:45:33,500 --> 00:45:35,220
sync does is because it's so expensive

908
00:45:35,420 --> 00:45:36,810
you would never want to do it unless you

909
00:45:37,010 --> 00:45:40,260
really wanted to persist some stuff some

910
00:45:40,460 --> 00:45:46,080
data okay so you can use more expensive

911
00:45:46,280 --> 00:45:47,730
disk hardware the other trick people

912
00:45:47,929 --> 00:45:51,210
play a lot is to try to batch that is if

913
00:45:51,409 --> 00:45:53,610
you can if client requests are if you

914
00:45:53,809 --> 00:45:55,170
have a lot of client requests coming in

915
00:45:55,369 --> 00:45:57,210
maybe you should accept a lot of them

916
00:45:57,409 --> 00:45:59,010
and not reply to any of them for a

917
00:45:59,210 --> 00:46:00,660
little bit we call a lot of them

918
00:46:00,860 --> 00:46:01,440
accumulate

919
00:46:01,639 --> 00:46:04,800
and then persist you know a hundred log

920
00:46:05,000 --> 00:46:07,410
entries at a time from your hundred

921
00:46:07,610 --> 00:46:09,600
clients and you know only then send out

922
00:46:09,800 --> 00:46:12,120
the append entries good because you do

923
00:46:12,320 --> 00:46:13,350
actually have to persist this stuff to

924
00:46:13,550 --> 00:46:15,930
disk if you receive a client request you

925
00:46:16,130 --> 00:46:17,400
have to persist the new entry to disk

926
00:46:17,599 --> 00:46:20,130
before you send the append entries our

927
00:46:20,329 --> 00:46:24,720
PCs the followers because you're not

928
00:46:24,920 --> 00:46:26,490
allowed if the leader you know the

929
00:46:26,690 --> 00:46:29,220
leader it's essentially promising to

930
00:46:29,420 --> 00:46:34,200
commit that that request and can't

931
00:46:34,400 --> 00:46:34,950
forget about it

932
00:46:35,150 --> 00:46:37,289
and indeed the followers have to persist

933
00:46:37,489 --> 00:46:39,060
the new log entry to their disk before

934
00:46:39,260 --> 00:46:40,680
they reply to the append entries because

935
00:46:40,880 --> 00:46:41,970
they were apply to the append entries

936
00:46:42,170 --> 00:46:44,910
it's also a promise to preserve and

937
00:46:45,110 --> 00:46:46,769
eventually commit that log entry so they

938
00:46:46,969 --> 00:46:48,420
can't be allowed to forget about it if

939
00:46:48,619 --> 00:46:51,750
they crash other questions about

940
00:46:51,949 --> 00:47:01,230
persistence all right well final you

941
00:47:01,429 --> 00:47:02,580
know a little detail about persistence

942
00:47:02,780 --> 00:47:09,420
is that some of the stuff in figure two

943
00:47:09,619 --> 00:47:11,100
is not persistent and so it's worth

944
00:47:11,300 --> 00:47:12,570
scratching your head a little bit about

945
00:47:12,769 --> 00:47:15,090
why commit index lasts apply next index

946
00:47:15,289 --> 00:47:17,039
and match index why it's fair game for

947
00:47:17,239 --> 00:47:19,440
them to be simply thrown away if the

948
00:47:19,639 --> 00:47:21,810
server crashes and restarts like why

949
00:47:22,010 --> 00:47:24,660
wasn't you know commit index or last

950
00:47:24,860 --> 00:47:26,310
apply it like geez last applied is the

951
00:47:26,510 --> 00:47:29,160
record of how much we've executed right

952
00:47:29,360 --> 00:47:30,240
if we throw that away aren't we gonna

953
00:47:30,440 --> 00:47:31,980
execute log entries twice and is that

954
00:47:32,179 --> 00:47:35,490
correct how about that why is why is it

955
00:47:35,690 --> 00:47:39,309
safe to throw away last applied

956
00:47:46,679 --> 00:47:55,430
yes I am we're all about simplicity and

957
00:47:55,630 --> 00:47:57,950
safety here with raft so that's exactly

958
00:47:58,150 --> 00:48:02,120
correct the the reason why all that

959
00:48:02,320 --> 00:48:04,039
other stuff can be non-volatile as you

960
00:48:04,239 --> 00:48:06,680
mentioned I mean sorry volatile the

961
00:48:06,880 --> 00:48:07,730
reason why those other fields can be

962
00:48:07,929 --> 00:48:10,160
volatile and thrown away is that we can

963
00:48:10,360 --> 00:48:12,380
the leader can reconstruct sort of

964
00:48:12,579 --> 00:48:15,140
what's been committed by inspecting its

965
00:48:15,340 --> 00:48:17,450
own log and by the results of append

966
00:48:17,650 --> 00:48:18,890
entries that it sends out to the

967
00:48:19,090 --> 00:48:20,480
followers I mean initially the leader if

968
00:48:20,679 --> 00:48:22,100
it if everybody restarts because they

969
00:48:22,300 --> 00:48:23,120
experienced a power failure

970
00:48:23,320 --> 00:48:24,740
initially the leader does not know

971
00:48:24,940 --> 00:48:27,680
what's committed what's executed but

972
00:48:27,880 --> 00:48:29,480
when it sends out log and append entries

973
00:48:29,679 --> 00:48:31,010
it'll sort of gather back information

974
00:48:31,210 --> 00:48:32,570
and essentially from the followers about

975
00:48:32,769 --> 00:48:34,580
What's in how much of their logs match

976
00:48:34,780 --> 00:48:36,170
the leaders and therefore how much must

977
00:48:36,369 --> 00:48:37,870
have been committed before the crash

978
00:48:38,070 --> 00:48:41,750
another thing in the 4-2 world which is

979
00:48:41,949 --> 00:48:42,950
not the real world

980
00:48:43,150 --> 00:48:44,930
another thing about figure two is that

981
00:48:45,130 --> 00:48:47,570
figure two assumes that the application

982
00:48:47,769 --> 00:48:51,380
state is destroyed and thrown away if

983
00:48:51,579 --> 00:48:54,110
there's a crash in a restart so the

984
00:48:54,309 --> 00:48:55,700
figure two world assumes that while log

985
00:48:55,900 --> 00:48:57,350
is persistent that the application state

986
00:48:57,550 --> 00:48:59,900
is absolutely not persistent required

987
00:49:00,099 --> 00:49:04,000
not to be consistent in figure 2 because

988
00:49:04,199 --> 00:49:07,190
the in figure 2 the log is preserved

989
00:49:07,389 --> 00:49:09,830
persisted from the very beginning of the

990
00:49:10,030 --> 00:49:12,800
system and so what's going to happen if

991
00:49:13,000 --> 00:49:15,440
you sort of play out what the various

992
00:49:15,639 --> 00:49:18,260
rules in figure 2 after a leader restart

993
00:49:18,460 --> 00:49:20,930
is that the leader will eventually re

994
00:49:21,130 --> 00:49:23,810
execute every single log entry that is

995
00:49:24,010 --> 00:49:26,300
handed to the application you know

996
00:49:26,500 --> 00:49:28,400
starting with log entry one after a

997
00:49:28,599 --> 00:49:31,220
reboot it's the raft is gonna hand the

998
00:49:31,420 --> 00:49:33,140
application every log entry starting

999
00:49:33,340 --> 00:49:34,640
from one and so that will after a

1000
00:49:34,840 --> 00:49:36,590
restart the application will completely

1001
00:49:36,789 --> 00:49:39,440
reconstruct its state from scratch by a

1002
00:49:39,639 --> 00:49:41,690
replay from the beginning of the time of

1003
00:49:41,889 --> 00:49:45,230
the entire log after each restart and

1004
00:49:45,429 --> 00:49:46,160
again that's like a sort of

1005
00:49:46,360 --> 00:49:49,190
straightforward elegant plan but

1006
00:49:49,389 --> 00:49:55,289
obviously potentially very slow

1007
00:49:56,119 --> 00:49:57,840
which brings us to the next topic which

1008
00:49:58,039 --> 00:50:04,470
is log compaction and and snapshots and

1009
00:50:04,670 --> 00:50:07,769
this has a lot to do with lab 3b

1010
00:50:07,969 --> 00:50:09,419
actually you'll see log compaction and

1011
00:50:09,619 --> 00:50:13,769
snapshots in vlog 3b in lab 3b and so

1012
00:50:13,969 --> 00:50:15,240
the problem that log compaction and

1013
00:50:15,440 --> 00:50:18,600
snapshotting is solving a raft is that

1014
00:50:18,800 --> 00:50:20,490
indeed for a long-running system that's

1015
00:50:20,690 --> 00:50:22,159
been going for weeks or months or years

1016
00:50:22,358 --> 00:50:25,110
if we just follow the figure 2 rules the

1017
00:50:25,309 --> 00:50:27,210
log just keeps on growing may end up you

1018
00:50:27,409 --> 00:50:28,289
know millions and millions of entries

1019
00:50:28,489 --> 00:50:30,570
long and so requires a lot of memory to

1020
00:50:30,769 --> 00:50:33,930
store if you store it on disk like if

1021
00:50:34,130 --> 00:50:35,159
you have to persist it every time you

1022
00:50:35,358 --> 00:50:36,930
persist the log it's using up a huge I

1023
00:50:37,130 --> 00:50:39,000
may not space on disk and if a server

1024
00:50:39,199 --> 00:50:41,789
ever be starts it has to reconstruct its

1025
00:50:41,989 --> 00:50:44,460
state by replaying these millions and

1026
00:50:44,659 --> 00:50:45,840
millions of log entries from the very

1027
00:50:46,039 --> 00:50:47,460
beginning which could take like hours

1028
00:50:47,659 --> 00:50:49,830
for a server to run through its entire

1029
00:50:50,030 --> 00:50:52,590
log and we execute it if it crashes and

1030
00:50:52,789 --> 00:50:54,480
restarts all of which is like similar

1031
00:50:54,679 --> 00:50:56,280
what kind of wasted because before it

1032
00:50:56,480 --> 00:50:58,470
crashed it had already had applications

1033
00:50:58,670 --> 00:51:08,030
state and so in order to cope with this

1034
00:51:08,230 --> 00:51:11,550
wrath has this idea of snapshots and the

1035
00:51:11,750 --> 00:51:15,030
sort of idea behind snapshots is to be

1036
00:51:15,230 --> 00:51:18,210
able to save or ask the application to

1037
00:51:18,409 --> 00:51:20,639
save a copy of its state as of a

1038
00:51:20,838 --> 00:51:23,070
particular log entry so we've been

1039
00:51:23,269 --> 00:51:24,720
mostly kind of ignoring the application

1040
00:51:24,920 --> 00:51:27,960
but the fact is that you know if we have

1041
00:51:28,159 --> 00:51:29,940
a suppose we're building a key value

1042
00:51:30,139 --> 00:51:33,149
store under BRAF you know the log is

1043
00:51:33,349 --> 00:51:34,740
gonna contain a bunch of you know

1044
00:51:34,940 --> 00:51:36,899
putting gets or read and write request

1045
00:51:37,099 --> 00:51:39,480
so maybe a law contains you know a put

1046
00:51:39,679 --> 00:51:42,210
that some client wants to set X to one

1047
00:51:42,409 --> 00:51:44,159
and then another one where it says X to

1048
00:51:44,358 --> 00:51:47,490
2 and then you know y equals 7 or

1049
00:51:47,690 --> 00:51:50,850
whatever and if there's no crashes as

1050
00:51:51,050 --> 00:51:53,369
the raft is executing along there's

1051
00:51:53,568 --> 00:51:55,530
going to be this if the layer above Rath

1052
00:51:55,730 --> 00:51:57,060
there's going to be this application and

1053
00:51:57,260 --> 00:51:59,190
the application if it's a key value

1054
00:51:59,389 --> 00:52:01,320
store databases it's going to be meeting

1055
00:52:01,519 --> 00:52:05,220
this table and as raft hands it one

1056
00:52:05,420 --> 00:52:07,019
command after our next

1057
00:52:07,219 --> 00:52:08,940
the applications going to update its

1058
00:52:09,139 --> 00:52:10,680
table so you know after the first

1059
00:52:10,880 --> 00:52:12,690
command it's going to set X to one and

1060
00:52:12,889 --> 00:52:14,100
it's stable after the second command

1061
00:52:14,300 --> 00:52:18,400
it's going to update its table you know

1062
00:52:19,630 --> 00:52:21,840
one interesting fact is that for most

1063
00:52:22,039 --> 00:52:24,120
applications the application state is

1064
00:52:24,320 --> 00:52:26,789
likely to be much smaller than the

1065
00:52:26,989 --> 00:52:29,640
corresponding log right at some level we

1066
00:52:29,840 --> 00:52:31,350
know that the the you know the log and

1067
00:52:31,550 --> 00:52:33,510
the state are the log in that and the

1068
00:52:33,710 --> 00:52:34,950
state as of some point in the log are

1069
00:52:35,150 --> 00:52:38,120
kind of interchangeable right they both

1070
00:52:38,320 --> 00:52:40,620
sort of implied the same thing about the

1071
00:52:40,820 --> 00:52:44,370
state of the application but the log may

1072
00:52:44,570 --> 00:52:45,900
contain a lot of you know a lot of

1073
00:52:46,099 --> 00:52:47,970
multiple assignments 2x they use up a

1074
00:52:48,170 --> 00:52:49,650
lot of space in the log but are also to

1075
00:52:49,849 --> 00:52:51,660
effectively compact it down to a single

1076
00:52:51,860 --> 00:52:53,310
entry in the table and that's pretty

1077
00:52:53,510 --> 00:52:56,100
typical of these replicated applications

1078
00:52:56,300 --> 00:52:59,910
but the point is that instead of storing

1079
00:53:00,110 --> 00:53:02,490
the log which may go to be huge we have

1080
00:53:02,690 --> 00:53:05,130
the option of storing instead the table

1081
00:53:05,329 --> 00:53:07,860
which might be a lot smaller and that's

1082
00:53:08,059 --> 00:53:11,430
what the snapshots are doing so when

1083
00:53:11,630 --> 00:53:14,220
raft feels that it's log has gotten to

1084
00:53:14,420 --> 00:53:17,490
be too large you know more than a

1085
00:53:17,690 --> 00:53:18,990
megabyte or ten megabytes or whatever

1086
00:53:19,190 --> 00:53:21,420
some arbitrary limit raft will ask the

1087
00:53:21,619 --> 00:53:24,060
application to take make a snapshot of

1088
00:53:24,260 --> 00:53:26,789
it the application state as of a certain

1089
00:53:26,989 --> 00:53:28,170
point in the log

1090
00:53:28,369 --> 00:53:30,560
so if we add if raft asked the

1091
00:53:30,760 --> 00:53:32,910
application for a snapshot reference it

1092
00:53:33,110 --> 00:53:35,100
would pick a point in the log that the

1093
00:53:35,300 --> 00:53:37,170
snapshot referred to and require the

1094
00:53:37,369 --> 00:53:39,570
application to produce a snapshot as at

1095
00:53:39,769 --> 00:53:41,370
that point this is extremely critical

1096
00:53:41,570 --> 00:53:44,280
because the because what we're about to

1097
00:53:44,480 --> 00:53:45,780
do is throw away everything before that

1098
00:53:45,980 --> 00:53:47,160
point so if there's not a will to find

1099
00:53:47,360 --> 00:53:48,660
point that corresponds to a snapshot

1100
00:53:48,860 --> 00:53:51,090
then we can't safely throw away the log

1101
00:53:51,289 --> 00:53:54,710
before that point so that means that

1102
00:53:54,909 --> 00:53:56,820
Rath is gonna have you know ask for

1103
00:53:57,019 --> 00:53:58,140
snaps on the snap so it's basically just

1104
00:53:58,340 --> 00:54:00,450
the table it's just about a database

1105
00:54:00,650 --> 00:54:04,320
server and we also need to annotate the

1106
00:54:04,519 --> 00:54:07,200
snapshot with the entry number that are

1107
00:54:07,400 --> 00:54:09,690
corresponds to you so it's basically you

1108
00:54:09,889 --> 00:54:12,180
know if the entries are 1 2 3 this

1109
00:54:12,380 --> 00:54:16,200
snapshot corresponds to just after log

1110
00:54:16,400 --> 00:54:19,609
index 3 with the snapshot in hand

1111
00:54:19,809 --> 00:54:23,129
if we persist it to disk rats persistent

1112
00:54:23,329 --> 00:54:26,669
to disk raft never again will need this

1113
00:54:26,869 --> 00:54:33,690
part of the logs and it can simply throw

1114
00:54:33,889 --> 00:54:36,450
it away as long as it persists a

1115
00:54:36,650 --> 00:54:39,389
snapshot as of a certain in debt log

1116
00:54:39,588 --> 00:54:42,510
index plus the log after that index as

1117
00:54:42,710 --> 00:54:44,250
long as that's persisted to disk we

1118
00:54:44,449 --> 00:54:46,280
never going to need to log before that

1119
00:54:46,480 --> 00:54:49,589
and so this is what RAF does the rocks

1120
00:54:49,789 --> 00:54:51,329
ask the application for snapshot gets

1121
00:54:51,528 --> 00:54:52,769
the snapshot saves it to disk with the

1122
00:54:52,969 --> 00:54:54,269
log after that it just throws away this

1123
00:54:54,469 --> 00:54:58,169
log here right and so it really operates

1124
00:54:58,369 --> 00:55:00,750
or the sort of persistence story is all

1125
00:55:00,949 --> 00:55:03,329
about pairs of a snapshot in the log

1126
00:55:03,528 --> 00:55:06,030
after that after the point in the log

1127
00:55:06,230 --> 00:55:09,690
associated with snapshot I don't see

1128
00:55:09,889 --> 00:55:12,699
this yes

1129
00:55:24,309 --> 00:55:27,480
no it's still it's it's you know there's

1130
00:55:27,679 --> 00:55:29,070
these sort of phantom entries one two

1131
00:55:29,269 --> 00:55:31,230
three and this you know suffix of the

1132
00:55:31,429 --> 00:55:37,190
log is indeed viewed as still the it's

1133
00:55:37,389 --> 00:55:39,030
maybe the right way to think of it is

1134
00:55:39,230 --> 00:55:41,039
still there's just one log except these

1135
00:55:41,239 --> 00:55:43,310
entries are sort of phantom entries that

1136
00:55:43,510 --> 00:55:46,379
we that we can view as being kind of

1137
00:55:46,579 --> 00:55:48,570
there in principle but since we're we

1138
00:55:48,769 --> 00:55:50,820
never need to look at them because we

1139
00:55:51,019 --> 00:55:52,349
have the snapshot the fact that they

1140
00:55:52,548 --> 00:55:53,669
just happened not to be stored anywhere

1141
00:55:53,869 --> 00:55:57,629
is neither here nor there but it's but

1142
00:55:57,829 --> 00:55:58,500
yeah you should think of it as being

1143
00:55:58,699 --> 00:56:01,440
stole the same log it's just not just

1144
00:56:01,639 --> 00:56:04,619
threw away their early entries did this

1145
00:56:04,818 --> 00:56:06,240
that's a maybe a little bit too glib of

1146
00:56:06,440 --> 00:56:07,379
an answer because the fact is that

1147
00:56:07,579 --> 00:56:09,930
figure two talks about the log in ways

1148
00:56:10,130 --> 00:56:12,359
that makes it that if you just follow

1149
00:56:12,559 --> 00:56:14,039
figure to you sometimes still need these

1150
00:56:14,239 --> 00:56:15,599
earlier entries and so you'll have to

1151
00:56:15,798 --> 00:56:17,220
reinterpret figure two a little bit in

1152
00:56:17,420 --> 00:56:19,470
light of the fact that sometimes it says

1153
00:56:19,670 --> 00:56:22,109
blah blah blah a log entry where the log

1154
00:56:22,309 --> 00:56:32,680
entry doesn't exist okay

1155
00:56:39,389 --> 00:56:42,919
okay and so what happens on a restart

1156
00:56:43,119 --> 00:56:44,690
so the restart story is a little more

1157
00:56:44,889 --> 00:56:46,129
complicated in it than it used to be

1158
00:56:46,329 --> 00:56:48,500
with just a log what happens on a

1159
00:56:48,699 --> 00:56:50,089
restart is that there needs to be away

1160
00:56:50,289 --> 00:56:54,349
for raft to give the latest for graph to

1161
00:56:54,548 --> 00:56:56,780
find the latest snapshot log pair on its

1162
00:56:56,980 --> 00:57:00,859
disk and hand the snapshot to the

1163
00:57:01,059 --> 00:57:02,930
application because we no longer are

1164
00:57:03,130 --> 00:57:04,789
able to replay you know all the log

1165
00:57:04,989 --> 00:57:06,260
entries so there must be some other way

1166
00:57:06,460 --> 00:57:08,539
to initialize the application basically

1167
00:57:08,739 --> 00:57:10,039
not only is the application have to be

1168
00:57:10,239 --> 00:57:11,240
able to produce a snapshot of

1169
00:57:11,440 --> 00:57:13,730
application state but but it has to be

1170
00:57:13,929 --> 00:57:15,639
able to absorb a previously made

1171
00:57:15,838 --> 00:57:17,780
snapshot and sort of reconstruct it

1172
00:57:17,980 --> 00:57:20,539
stable in memory from a snapshot and so

1173
00:57:20,739 --> 00:57:22,039
this now even though raft is kind of

1174
00:57:22,239 --> 00:57:23,510
managing this whole snapshotting stuff

1175
00:57:23,710 --> 00:57:26,000
the snapshot contents are really the

1176
00:57:26,199 --> 00:57:28,099
property to the application and RAF

1177
00:57:28,298 --> 00:57:29,750
doesn't even understand what's in here

1178
00:57:29,949 --> 00:57:31,220
only the application does because it's

1179
00:57:31,420 --> 00:57:32,810
all full of application specific

1180
00:57:33,010 --> 00:57:36,079
information so after a restart the

1181
00:57:36,278 --> 00:57:39,589
application has to be able to absorb the

1182
00:57:39,789 --> 00:57:45,589
latest snapshot that raft found so for

1183
00:57:45,789 --> 00:57:48,550
just this simple it would be simple

1184
00:57:48,750 --> 00:57:51,889
unfortunately this snapshotting and in

1185
00:57:52,088 --> 00:57:54,379
particular the idea that the leader

1186
00:57:54,579 --> 00:57:56,720
might throw away part of its log

1187
00:57:56,920 --> 00:57:59,480
introduces a major piece of complexity

1188
00:57:59,679 --> 00:58:01,609
and that is that if there's some

1189
00:58:01,809 --> 00:58:05,740
follower out there whose log ends before

1190
00:58:05,940 --> 00:58:10,609
the point at which the leaders log

1191
00:58:10,809 --> 00:58:13,940
starts then unless we invent something

1192
00:58:14,139 --> 00:58:15,619
new we need monney install snapshot

1193
00:58:15,818 --> 00:58:17,720
unless we invent something new that

1194
00:58:17,920 --> 00:58:20,659
follower can never get up-to-date right

1195
00:58:20,858 --> 00:58:22,820
because if the followers you know if

1196
00:58:23,019 --> 00:58:25,010
there's some follower whose log only is

1197
00:58:25,210 --> 00:58:27,200
the first two log entries we no longer

1198
00:58:27,400 --> 00:58:29,690
have the log entry three that's required

1199
00:58:29,889 --> 00:58:32,510
to send it to that follower in an append

1200
00:58:32,710 --> 00:58:35,210
entries RPC to allow its log to catch up

1201
00:58:35,409 --> 00:58:40,950
to the leaders now

1202
00:58:41,150 --> 00:58:44,619
we could avoid this problem by having

1203
00:58:44,818 --> 00:58:47,680
the leader never drop part of its log if

1204
00:58:47,880 --> 00:58:50,230
there's any follower out there that

1205
00:58:50,429 --> 00:58:53,169
hasn't caught up to the point at which

1206
00:58:53,369 --> 00:58:54,760
the leader is thinking about doing a

1207
00:58:54,960 --> 00:58:56,289
snapshot because the leader knows

1208
00:58:56,489 --> 00:58:58,720
through next index

1209
00:58:58,920 --> 00:59:00,760
well actually leader doesn't really know

1210
00:59:00,960 --> 00:59:02,369
but the leader could know in principle

1211
00:59:02,568 --> 00:59:05,349
how far each follower had gotten and the

1212
00:59:05,548 --> 00:59:06,460
leader could say well I'm just never

1213
00:59:06,659 --> 00:59:09,099
gonna drop the part of my log before the

1214
00:59:09,298 --> 00:59:11,859
end of the follower with the shortest

1215
00:59:12,059 --> 00:59:16,690
log and that would be okay they might

1216
00:59:16,889 --> 00:59:19,839
actually just be a good idea period the

1217
00:59:20,039 --> 00:59:21,099
reason why that's maybe not such a great

1218
00:59:21,298 --> 00:59:22,839
idea is that of course if a follower

1219
00:59:23,039 --> 00:59:26,530
shut down for a week you know it's not

1220
00:59:26,730 --> 00:59:28,570
gonna be acknowledging log entries and

1221
00:59:28,769 --> 00:59:31,060
that means that the leader can't reduce

1222
00:59:31,260 --> 00:59:34,149
its memory use by snapshotting so the

1223
00:59:34,349 --> 00:59:35,800
way the raft designs chosen to go is

1224
00:59:36,000 --> 00:59:40,089
that the leader is allowed to throw away

1225
00:59:40,289 --> 00:59:41,859
parts of its logs that would be needed

1226
00:59:42,059 --> 00:59:43,419
by some follower and so we need some

1227
00:59:43,619 --> 00:59:45,570
other scheme that append entries to deal

1228
00:59:45,769 --> 00:59:47,829
with the gap between the end of some

1229
00:59:48,028 --> 00:59:49,149
followers log in the beginning of the

1230
00:59:49,349 --> 00:59:51,639
leaders log and so that solution is the

1231
00:59:51,838 --> 01:00:02,680
install snapshot RPC and the deal is

1232
01:00:02,880 --> 01:00:06,730
that when a leader we have some follower

1233
01:00:06,929 --> 01:00:09,280
whose log is that you know just powered

1234
01:00:09,480 --> 01:00:12,039
on its log as short the leaders gonna

1235
01:00:12,239 --> 01:00:14,349
send it and append entries and you know

1236
01:00:14,548 --> 01:00:15,669
it's gonna be forced the leaders gonna

1237
01:00:15,869 --> 01:00:17,050
be forced to backup and at some point

1238
01:00:17,250 --> 01:00:18,879
the leader you know failure or fail

1239
01:00:19,079 --> 01:00:20,619
dependent recalls will cause the leader

1240
01:00:20,818 --> 01:00:23,139
to realize it it's reached the beginning

1241
01:00:23,338 --> 01:00:24,940
of the actual log its doors and at that

1242
01:00:25,139 --> 01:00:26,950
point instead of sending in append

1243
01:00:27,150 --> 01:00:30,129
entries the leader will send its current

1244
01:00:30,329 --> 01:00:33,369
snapshot plus current law well send its

1245
01:00:33,568 --> 01:00:35,470
current snapshot to the follower and

1246
01:00:35,670 --> 01:00:37,690
then presumably immediately follow it

1247
01:00:37,889 --> 01:00:39,879
with an append entries that has the

1248
01:00:40,079 --> 01:00:43,190
leaders current law

1249
01:00:46,769 --> 01:00:49,769
questions

1250
01:00:52,369 --> 01:00:55,048
yeah I'm the sad truth this is like this

1251
01:00:55,248 --> 01:00:58,940
is adds significant complexity here

1252
01:00:59,139 --> 01:01:02,339
Jarrell I'm three partially because of

1253
01:01:02,539 --> 01:01:04,829
the kind of cooperation that's required

1254
01:01:05,028 --> 01:01:07,019
between raff this is sort of a little

1255
01:01:07,219 --> 01:01:08,579
bit of a violation of modularity it

1256
01:01:08,778 --> 01:01:11,849
requires a good deal cooperation like

1257
01:01:12,048 --> 01:01:13,379
for example when an install snapshot

1258
01:01:13,579 --> 01:01:15,778
comes in it's delivered to raft but raft

1259
01:01:15,978 --> 01:01:17,579
really requires the application to

1260
01:01:17,778 --> 01:01:23,039
absorb the snapshot so they have to talk

1261
01:01:23,239 --> 01:01:23,909
to each other more than they otherwise

1262
01:01:24,108 --> 01:01:33,419
might yes the question is that this is

1263
01:01:33,619 --> 01:01:35,010
the way the snapshot is created

1264
01:01:35,210 --> 01:01:36,690
dependent on the application

1265
01:01:36,889 --> 01:01:38,519
it's absolutely it so the snapshot

1266
01:01:38,719 --> 01:01:40,769
creation function is part of the

1267
01:01:40,969 --> 01:01:42,480
application as part of like the key

1268
01:01:42,679 --> 01:01:45,059
value server so raffle you know somehow

1269
01:01:45,259 --> 01:01:46,589
call up to the application and say geez

1270
01:01:46,789 --> 01:01:47,940
you know I really like a snapshot right

1271
01:01:48,139 --> 01:01:50,129
now in the application because only the

1272
01:01:50,329 --> 01:01:53,690
application understands what it's status

1273
01:01:53,889 --> 01:01:57,450
and you know the inverse function by

1274
01:01:57,650 --> 01:01:59,250
which an application reconstructs a

1275
01:01:59,449 --> 01:02:01,528
state from a snapshot files also totally

1276
01:02:01,728 --> 01:02:04,859
application dependent where there's

1277
01:02:05,059 --> 01:02:06,659
intertwining because of course every

1278
01:02:06,858 --> 01:02:09,298
snapshot has to be labeled with a point

1279
01:02:09,498 --> 01:02:12,788
in a log that it corresponds to

1280
01:02:25,269 --> 01:02:27,030
talking about rule six and figure

1281
01:02:27,230 --> 01:02:39,480
thirteen okay so yeah the question here

1282
01:02:39,679 --> 01:02:42,360
is that and you will be faced with this

1283
01:02:42,559 --> 01:02:46,050
in lab three that because the RPC system

1284
01:02:46,250 --> 01:02:48,450
isn't perfectly reliable and perfectly

1285
01:02:48,650 --> 01:02:50,700
sequenced and RBC's can arrive out of

1286
01:02:50,900 --> 01:02:52,440
order or not at all or you may send an

1287
01:02:52,639 --> 01:02:54,450
RPC and get no response and think it was

1288
01:02:54,650 --> 01:02:56,250
lost but actually was delivered and was

1289
01:02:56,449 --> 01:02:58,110
the reply that was lost all these things

1290
01:02:58,309 --> 01:03:02,340
happen including to send to whatever

1291
01:03:02,539 --> 01:03:04,410
install snapshot our pcs and the leaders

1292
01:03:04,610 --> 01:03:06,660
almost certainly sending out many our

1293
01:03:06,860 --> 01:03:08,550
pcs concurrently you know both append

1294
01:03:08,750 --> 01:03:12,000
entries and install snapshots that means

1295
01:03:12,199 --> 01:03:14,820
that you can get things like install

1296
01:03:15,019 --> 01:03:19,509
snapshot our pcs from deep in the past

1297
01:03:20,559 --> 01:03:24,840
almost anything else right and therefore

1298
01:03:25,039 --> 01:03:29,789
the the follower has to be careful you

1299
01:03:29,989 --> 01:03:31,019
know has to think carefully about an

1300
01:03:31,219 --> 01:03:35,649
install snapshot that arrives and the

1301
01:03:37,269 --> 01:03:39,240
yeah I think the specific thing you're

1302
01:03:39,440 --> 01:03:41,789
asking is that if follower receives that

1303
01:03:41,989 --> 01:03:43,590
an install snapshot that appears to be

1304
01:03:43,789 --> 01:03:46,110
completely redundant that is the install

1305
01:03:46,309 --> 01:03:47,580
snapshot contains information that's

1306
01:03:47,780 --> 01:03:50,190
older than the information the follower

1307
01:03:50,389 --> 01:03:51,240
already has

1308
01:03:51,440 --> 01:03:55,050
what should the follower do and rule six

1309
01:03:55,250 --> 01:03:57,150
and figure thirteen says something but I

1310
01:03:57,349 --> 01:03:59,280
think equally valid response to that is

1311
01:03:59,480 --> 01:04:01,140
that the follower can ignore a snapshot

1312
01:04:01,340 --> 01:04:07,260
that clearly is from the past I don't

1313
01:04:07,460 --> 01:04:11,870
really understand that rule six okay I

1314
01:04:12,070 --> 01:04:17,789
want to move on to sort of somewhat more

1315
01:04:17,989 --> 01:04:21,510
conceptual topic for a bit so far we

1316
01:04:21,710 --> 01:04:24,530
haven't really tried to nail down

1317
01:04:24,730 --> 01:04:26,820
anything about what it meant to be

1318
01:04:27,019 --> 01:04:28,410
correct

1319
01:04:28,610 --> 01:04:33,660
what I meant for a replicated service

1320
01:04:33,860 --> 01:04:36,090
already any other kind of service to be

1321
01:04:36,289 --> 01:04:38,850
behaving correctly and the reason why

1322
01:04:39,050 --> 01:04:42,120
and you know whatever for most of my

1323
01:04:42,320 --> 01:04:44,039
life I managed to get by without

1324
01:04:44,239 --> 01:04:45,870
worrying too much about precise

1325
01:04:46,070 --> 01:04:47,760
definitions of correctness but the fact

1326
01:04:47,960 --> 01:04:49,530
is that you know if you're trying to

1327
01:04:49,730 --> 01:04:51,180
optimize something or you're trying to

1328
01:04:51,380 --> 01:04:52,830
think through some weird corner case

1329
01:04:53,030 --> 01:04:55,620
it's often handy to actually have a more

1330
01:04:55,820 --> 01:04:57,900
or less formal way of deciding is that

1331
01:04:58,099 --> 01:05:00,269
behavior correct or not correct and so

1332
01:05:00,469 --> 01:05:01,710
you know for here what we're talking

1333
01:05:01,909 --> 01:05:03,480
about is you know clients are sending in

1334
01:05:03,679 --> 01:05:05,340
requests to the to our replicated

1335
01:05:05,539 --> 01:05:07,500
service with our PC maybe they'll be

1336
01:05:07,699 --> 01:05:09,510
sending who knows well maybe the service

1337
01:05:09,710 --> 01:05:11,640
is crash it can be starting and you know

1338
01:05:11,840 --> 01:05:14,010
loading snapshots or whatever the client

1339
01:05:14,210 --> 01:05:15,750
sends in a request and gets a response

1340
01:05:15,949 --> 01:05:18,120
like is that response correct how are we

1341
01:05:18,320 --> 01:05:19,890
supposed to how are we supposed to tell

1342
01:05:20,090 --> 01:05:22,230
whether response a would be correct or

1343
01:05:22,429 --> 01:05:26,010
response B so we need a notion we need a

1344
01:05:26,210 --> 01:05:27,539
pretty formal notion of distinguishing

1345
01:05:27,739 --> 01:05:29,850
oh that's okay from now that would be a

1346
01:05:30,050 --> 01:05:33,570
wrong answer and for this lab the our

1347
01:05:33,769 --> 01:05:36,030
notion of correctness is linearize

1348
01:05:36,230 --> 01:05:42,210
ability and I mentioned strong

1349
01:05:42,409 --> 01:05:43,710
consistency and some of the papers I

1350
01:05:43,909 --> 01:05:45,289
mentioned strong consistency and

1351
01:05:45,489 --> 01:05:47,070
basically equivalent to linearize

1352
01:05:47,269 --> 01:05:50,340
ability linearize ability is a sort of a

1353
01:05:50,539 --> 01:05:54,380
formalization of more or less of the

1354
01:05:54,579 --> 01:05:57,210
behavior you would expect if there was

1355
01:05:57,409 --> 01:05:59,519
just one server and it didn't crash and

1356
01:05:59,719 --> 01:06:02,010
it executed the command client requests

1357
01:06:02,210 --> 01:06:04,710
one at a time and you know nothing funny

1358
01:06:04,909 --> 01:06:08,970
ever happened so it has it has a

1359
01:06:09,170 --> 01:06:12,150
definition and the definition I'll write

1360
01:06:12,349 --> 01:06:13,910
out the definition then talk about it so

1361
01:06:14,110 --> 01:06:24,410
so an execution history is linearizable

1362
01:06:24,610 --> 01:06:30,630
linearizable and this is in the notes if

1363
01:06:30,829 --> 01:06:32,940
there exists a total order so an

1364
01:06:33,139 --> 01:06:34,710
execution history is a sequence of

1365
01:06:34,909 --> 01:06:37,019
client requests maybe many requests from

1366
01:06:37,219 --> 01:06:39,310
many clients

1367
01:06:39,510 --> 01:06:46,690
if there's some total order of the

1368
01:06:46,889 --> 01:06:53,440
operations in the history it matches the

1369
01:06:53,639 --> 01:06:55,360
real-time order of requests so if one

1370
01:06:55,559 --> 01:06:56,050
request

1371
01:06:56,250 --> 01:06:57,789
if client sends out a request and gets a

1372
01:06:57,989 --> 01:07:01,000
response and then later in time another

1373
01:07:01,199 --> 01:07:02,530
client sends out a request and I get a

1374
01:07:02,730 --> 01:07:04,690
response those two requests are ordered

1375
01:07:04,889 --> 01:07:07,570
because one of them's started after the

1376
01:07:07,769 --> 01:07:08,740
other one finished

1377
01:07:08,940 --> 01:07:12,100
so it's linearizable history is

1378
01:07:12,300 --> 01:07:13,660
linearizable if there exists an order of

1379
01:07:13,860 --> 01:07:15,700
the operations in the history that

1380
01:07:15,900 --> 01:07:23,050
matches real-time for non concurrent

1381
01:07:23,250 --> 01:07:25,660
requests that is for a request to didn't

1382
01:07:25,860 --> 01:07:42,070
overlap in time and each read you can

1383
01:07:42,269 --> 01:07:44,289
think of it as each read sees the value

1384
01:07:44,489 --> 01:07:46,539
from the most immediately preceding

1385
01:07:46,739 --> 01:07:56,560
right to the the same piece of data most

1386
01:07:56,760 --> 01:08:08,200
recent right in the order all right this

1387
01:08:08,400 --> 01:08:10,630
is the definition let me illustrate what

1388
01:08:10,829 --> 01:08:12,420
it means by running through an example

1389
01:08:12,619 --> 01:08:15,010
so first of all the history is a record

1390
01:08:15,210 --> 01:08:16,420
of client operations so this is a

1391
01:08:16,619 --> 01:08:18,310
definition that you can apply from

1392
01:08:18,510 --> 01:08:20,380
outside this definition doesn't appeal

1393
01:08:20,579 --> 01:08:23,230
in any way to what happens inside the

1394
01:08:23,430 --> 01:08:24,340
implementation or how the implementation

1395
01:08:24,539 --> 01:08:26,980
works it's something that we can if we

1396
01:08:27,180 --> 01:08:29,800
see a system operating and we can watch

1397
01:08:30,000 --> 01:08:32,260
the messages that come in and out we can

1398
01:08:32,460 --> 01:08:34,090
answer the question was that execution

1399
01:08:34,289 --> 01:08:42,409
that we observe linearizable so let me

1400
01:08:44,829 --> 01:08:47,400
let me write out of history and talk

1401
01:08:47,600 --> 01:08:51,160
about why it is or isn't linearizable

1402
01:08:53,529 --> 01:09:01,500
all right so here's an example the new

1403
01:09:01,699 --> 01:09:03,180
eyes ability talks about operations that

1404
01:09:03,380 --> 01:09:05,340
start at one point and end at another

1405
01:09:05,539 --> 01:09:07,050
and so this corresponds to the time at

1406
01:09:07,250 --> 01:09:10,079
which a client sends a request and then

1407
01:09:10,279 --> 01:09:13,770
later receives a reply so let us suppose

1408
01:09:13,970 --> 01:09:15,900
that our history says that at at some

1409
01:09:16,100 --> 01:09:18,989
particular time this time some client

1410
01:09:19,189 --> 01:09:21,960
sent a write request for the data item

1411
01:09:22,159 --> 01:09:24,380
named X and asked for it to be set to 1

1412
01:09:24,579 --> 01:09:28,470
and then time passed and at the second

1413
01:09:28,670 --> 01:09:29,970
vertical bar is when that client got a

1414
01:09:30,170 --> 01:09:31,710
reply through send a request at this

1415
01:09:31,909 --> 01:09:33,090
point you know time pass who knows

1416
01:09:33,289 --> 01:09:34,500
what's happening when the client got a

1417
01:09:34,699 --> 01:09:37,529
reply there and then later in time that

1418
01:09:37,729 --> 01:09:38,820
client or some other client doesn't

1419
01:09:39,020 --> 01:09:40,079
really matter

1420
01:09:40,279 --> 01:09:42,900
sends a write request again for item X

1421
01:09:43,100 --> 01:09:45,270
and value 2 and gets a response to that

1422
01:09:45,470 --> 01:09:52,170
right meanwhile some client sends a read

1423
01:09:52,369 --> 01:09:56,789
for X and gets value 2 and sent the

1424
01:09:56,989 --> 01:09:58,619
request there and got the response with

1425
01:09:58,819 --> 01:10:00,690
value 2 there and there's another

1426
01:10:00,890 --> 01:10:03,119
request that we observed it's a part of

1427
01:10:03,319 --> 01:10:07,079
the history request was sent to read

1428
01:10:07,279 --> 01:10:12,630
value X and it got value 1 back and so

1429
01:10:12,829 --> 01:10:14,550
when we have a history like this you

1430
01:10:14,750 --> 01:10:15,960
know the question were that you asked

1431
01:10:16,159 --> 01:10:17,489
about this history is is this a

1432
01:10:17,689 --> 01:10:19,980
linearizable history that is did the

1433
01:10:20,180 --> 01:10:22,110
machinery did the service did the system

1434
01:10:22,310 --> 01:10:23,730
that produced this history and was that

1435
01:10:23,930 --> 01:10:28,230
a linearizable system or did it produce

1436
01:10:28,430 --> 01:10:30,180
a linearizable history in this case if

1437
01:10:30,380 --> 01:10:31,590
this history is not linear inaudible

1438
01:10:31,789 --> 01:10:36,360
then then Lisa we're talking about I

1439
01:10:36,560 --> 01:10:38,550
have 3 we know we have a problem there

1440
01:10:38,750 --> 01:10:42,060
must be some some bug ok so we need to

1441
01:10:42,260 --> 01:10:43,260
analyze this to figure out if it's

1442
01:10:43,460 --> 01:10:45,779
linearizable there's linear linearize

1443
01:10:45,979 --> 01:10:48,630
ability requires us to produce an order

1444
01:10:48,829 --> 01:10:52,199
you know one by one order of the four

1445
01:10:52,399 --> 01:10:54,600
operations in that history so we know

1446
01:10:54,800 --> 01:10:55,650
we're looking for an order and there's

1447
01:10:55,850 --> 01:10:56,850
two constraints on the

1448
01:10:57,050 --> 01:11:03,690
order one is if one operation finished

1449
01:11:03,890 --> 01:11:07,440
before another started then the one that

1450
01:11:07,640 --> 01:11:08,699
finished first has to come first in the

1451
01:11:08,899 --> 01:11:13,590
history the other is if some read sees a

1452
01:11:13,789 --> 01:11:17,730
particular written value then the read

1453
01:11:17,930 --> 01:11:20,720
must come after the write in the order

1454
01:11:20,920 --> 01:11:22,890
all right so we want to order so we're

1455
01:11:23,090 --> 01:11:24,180
gonna produce an order that has four

1456
01:11:24,380 --> 01:11:26,449
entries the two rights and the two leads

1457
01:11:26,649 --> 01:11:28,829
I'm gonna draw with arrows that

1458
01:11:29,029 --> 01:11:31,140
constraints implied by those two rules

1459
01:11:31,340 --> 01:11:33,600
and then our order is gonna have to obey

1460
01:11:33,800 --> 01:11:36,239
these constraints so one constraint is

1461
01:11:36,439 --> 01:11:39,000
that this write finished before this

1462
01:11:39,199 --> 01:11:41,070
write started and therefore one of the

1463
01:11:41,270 --> 01:11:44,220
ordering constraints is that this write

1464
01:11:44,420 --> 01:11:47,279
must appear in the total order before

1465
01:11:47,479 --> 01:11:51,090
this write this read saw the value of

1466
01:11:51,289 --> 01:11:56,670
two so in the total order the most

1467
01:11:56,869 --> 01:11:58,890
recent right that this read must come

1468
01:11:59,090 --> 01:12:00,539
after this right and this write must be

1469
01:12:00,739 --> 01:12:03,409
the most recent right so that means that

1470
01:12:03,609 --> 01:12:06,119
in the total order we must see the right

1471
01:12:06,319 --> 01:12:08,730
of X - 2 and then after it the read of X

1472
01:12:08,930 --> 01:12:19,470
it yields - and this this read of X of 1

1473
01:12:19,670 --> 01:12:20,850
if we assume that the X didn't already

1474
01:12:21,050 --> 01:12:23,010
have the value 1 there there must be in

1475
01:12:23,210 --> 01:12:26,820
this relationship and that is the read

1476
01:12:27,020 --> 01:12:29,039
must come after the right and this read

1477
01:12:29,239 --> 01:12:32,550
also must become for this right and

1478
01:12:32,750 --> 01:12:35,279
maybe there's some other restrictions -

1479
01:12:35,479 --> 01:12:37,710
anyway we can take these we can take

1480
01:12:37,909 --> 01:12:39,060
this set of arrows and flatten it out

1481
01:12:39,260 --> 01:12:40,890
into an order and that actually works so

1482
01:12:41,090 --> 01:12:43,829
the order that's the total order that

1483
01:12:44,029 --> 01:12:45,390
demonstrates that this history is

1484
01:12:45,590 --> 01:12:49,820
linearizable is first the right of x - 1

1485
01:12:50,020 --> 01:12:56,310
then the read of x yielding 1 then the

1486
01:12:56,510 --> 01:13:00,449
right of x - 2 and the read of x that

1487
01:13:00,649 --> 01:13:03,189
yields 2

1488
01:13:03,920 --> 01:13:06,190
alright so the fact that there is this

1489
01:13:06,390 --> 01:13:07,720
order that does obey the ordering

1490
01:13:07,920 --> 01:13:09,248
constraints shows that this history is

1491
01:13:09,448 --> 01:13:13,779
linearize ability and doesn't you know

1492
01:13:13,979 --> 01:13:15,100
if we're worried about the system that

1493
01:13:15,300 --> 01:13:17,739
produced this history whether it's a but

1494
01:13:17,939 --> 01:13:20,409
that system is linearizable then this

1495
01:13:20,609 --> 01:13:21,909
particular example we saw it doesn't

1496
01:13:22,109 --> 01:13:24,460
contradict the presumption that the

1497
01:13:24,659 --> 01:13:28,840
system is linearizable any questions

1498
01:13:29,039 --> 01:13:45,159
about what I just did each read sees you

1499
01:13:45,359 --> 01:13:47,949
know read of X the value it sees must be

1500
01:13:48,149 --> 01:13:51,400
them value written by the most the most

1501
01:13:51,600 --> 01:13:56,130
recent proceeding right in the order so

1502
01:13:56,329 --> 01:13:58,720
you know in this case in this case we're

1503
01:13:58,920 --> 01:14:00,038
totally ok with this order because this

1504
01:14:00,238 --> 01:14:03,248
read the value it saw is indeed the

1505
01:14:03,448 --> 01:14:04,570
value written by the most recent write

1506
01:14:04,770 --> 01:14:08,050
in this order and this read the value it

1507
01:14:08,250 --> 01:14:12,430
sighs I mean in informally it's that

1508
01:14:12,630 --> 01:14:15,220
reads can't real should not be yielding

1509
01:14:15,420 --> 01:14:17,739
stale data if I write something in Rita

1510
01:14:17,939 --> 01:14:19,840
back gosh I should see the value I wrote

1511
01:14:20,039 --> 01:14:21,670
and that's like a formalization of the

1512
01:14:21,869 --> 01:14:24,229
notion that

1513
01:14:27,529 --> 01:14:33,930
oh yes oh yeah yeah all right let me let

1514
01:14:34,130 --> 01:14:40,230
me he's right up example that's not

1515
01:14:40,430 --> 01:14:44,610
indeed linearizable so example two let's

1516
01:14:44,810 --> 01:14:47,909
suppose our history is we had a right of

1517
01:14:48,109 --> 01:14:57,880
X value one right back with value two

1518
01:15:14,090 --> 01:15:16,440
and so this one we also want to write

1519
01:15:16,640 --> 01:15:19,920
out the arrows and so we know what the

1520
01:15:20,119 --> 01:15:21,720
constraints are on any total order we

1521
01:15:21,920 --> 01:15:25,920
might find the right of X to one because

1522
01:15:26,119 --> 01:15:28,380
of time because it finished in real time

1523
01:15:28,579 --> 01:15:30,930
before the right x to started and must

1524
01:15:31,130 --> 01:15:36,000
come before in any satisfying order we

1525
01:15:36,199 --> 01:15:38,310
produce the right of Ecsta two has to

1526
01:15:38,510 --> 01:15:40,860
come before the right before the read of

1527
01:15:41,060 --> 01:15:45,280
X that yields two so we have this arrow

1528
01:15:46,840 --> 01:15:49,199
the read of X had to finished before the

1529
01:15:49,399 --> 01:15:51,210
read of X to one started so we have this

1530
01:15:51,409 --> 01:16:00,060
arrow and the read of X to one because

1531
01:16:00,260 --> 01:16:03,630
it saw value one has to come after the

1532
01:16:03,829 --> 01:16:05,940
right of X - 1 and more crucially before

1533
01:16:06,140 --> 01:16:09,570
the right of X 2 - right so we can't

1534
01:16:09,770 --> 01:16:12,029
have this read of X yielding one if it's

1535
01:16:12,229 --> 01:16:14,039
immediately preceded by I'll write out X

1536
01:16:14,239 --> 01:16:18,050
- 2 so we also have this arrow like this

1537
01:16:18,250 --> 01:16:22,860
and because there's a cycle in these

1538
01:16:23,060 --> 01:16:26,909
constraints there's no order that can

1539
01:16:27,109 --> 01:16:28,949
obey all these constraints and therefore

1540
01:16:29,149 --> 01:16:34,980
this history is not linearizable and so

1541
01:16:35,180 --> 01:16:37,460
the system that produced it is

1542
01:16:37,659 --> 01:16:42,680
is not a linearizable system you know

1543
01:16:42,880 --> 01:16:44,119
would be linearizable the history was

1544
01:16:44,319 --> 01:16:47,539
missing any one of these three and I

1545
01:16:47,739 --> 01:17:05,570
would break the cycle yes maybe I'm not

1546
01:17:05,770 --> 01:17:08,420
sure because suppose or I don't know how

1547
01:17:08,619 --> 01:17:11,029
to incorporate very strange things like

1548
01:17:11,229 --> 01:17:16,670
supposing somebody red 27 you know it

1549
01:17:16,869 --> 01:17:18,710
doesn't really if there's no right of 27

1550
01:17:18,909 --> 01:17:22,159
a read of 27 doesn't at least the way

1551
01:17:22,359 --> 01:17:23,510
I've written out the rules doesn't sort

1552
01:17:23,710 --> 01:17:26,420
of well there may be some sort of anti

1553
01:17:26,619 --> 01:17:29,000
dependency that you would construct okay

1554
01:17:29,199 --> 01:17:32,930
um I will continue this discussion next

1555
01:17:33,130 --> 01:17:38,130
week

